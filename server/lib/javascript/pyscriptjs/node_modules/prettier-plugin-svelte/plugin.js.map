{"version":3,"file":"plugin.js","sources":["src/lib/elements.ts","src/lib/extractAttributes.ts","src/lib/getText.ts","src/lib/snipTagContent.ts","src/options.ts","src/print/helpers.ts","src/print/doc-helpers.ts","src/print/node-helpers.ts","src/print/index.ts","src/embed.ts","src/index.ts"],"sourcesContent":["export type TagName = keyof HTMLElementTagNameMap | 'svg';\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nexport const selfClosingTags = [\n    'area',\n    'base',\n    'br',\n    'col',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr',\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\nexport const blockElements: TagName[] = [\n    'address',\n    'article',\n    'aside',\n    'blockquote',\n    'details',\n    'dialog',\n    'dd',\n    'div',\n    'dl',\n    'dt',\n    'fieldset',\n    'figcaption',\n    'figure',\n    'footer',\n    'form',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'header',\n    'hgroup',\n    'hr',\n    'li',\n    'main',\n    'nav',\n    'ol',\n    'p',\n    'pre',\n    'section',\n    'table',\n    'ul',\n];\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n    // None at the moment\n    // Prettier HTML does not format attributes at all\n    // and to be consistent we leave this array empty for now\n];\n","import { AttributeNode, TextNode } from '../print/nodes';\n\nexport function extractAttributes(html: string): AttributeNode[] {\n    const extractAttributesRegex = /<[a-z]+\\s*(.*?)>/i;\n    const attributeRegex = /([^\\s=]+)(?:=(\"|')(.*?)\\2)?/gi;\n\n    const [, attributesString] = html.match(extractAttributesRegex)!;\n\n    const attrs: AttributeNode[] = [];\n\n    let match: RegExpMatchArray | null;\n    while ((match = attributeRegex.exec(attributesString))) {\n        const [all, name, quotes, value] = match;\n        const attrStart = match.index!;\n\n        let valueNode: AttributeNode['value'];\n        if (!value) {\n            valueNode = true;\n        } else {\n            let valueStart = attrStart + name.length;\n            if (quotes) {\n                valueStart += 2;\n            }\n\n            valueNode = [\n                {\n                    type: 'Text',\n                    data: value,\n                    start: valueStart,\n                    end: valueStart + value.length,\n                } as TextNode,\n            ];\n        }\n\n        attrs.push({\n            type: 'Attribute',\n            name,\n            value: valueNode,\n            start: attrStart,\n            end: attrStart + all.length,\n        });\n    }\n\n    return attrs;\n}\n","import { ParserOptions } from 'prettier';\nimport { Node } from '../print/nodes';\n\nexport function getText(node: Node, options: ParserOptions) {\n    const leadingComments: Node[] = (node as any).leadingComments\n\n    return options.originalText.slice(\n        options.locStart(\n            // if there are comments before the node they are not included \n            // in the `start` of the node itself\n            leadingComments && leadingComments[0] || node,\n        ),\n        options.locEnd(node),\n    );\n}\n","export const snippedTagContentAttribute = '✂prettier:content✂';\n\nexport function snipScriptAndStyleTagContent(source: string): string {\n    let scriptMatchSpans = getMatchIndexes('script');\n    let styleMatchSpans = getMatchIndexes('style');\n\n    return snipTagContent(\n        snipTagContent(source, 'script', '{}', styleMatchSpans),\n        'style',\n        '',\n        scriptMatchSpans,\n    );\n\n    function getMatchIndexes(tagName: string) {\n        const regex = getRegexp(tagName);\n        const indexes: [number, number][] = [];\n        let match = null;\n        while ((match = regex.exec(source)) != null) {\n            if (source.slice(match.index, match.index + 4) !== '<!--') {\n                indexes.push([match.index, regex.lastIndex]);\n            }\n        }\n        return indexes;\n    }\n\n    function snipTagContent(\n        _source: string,\n        tagName: string,\n        placeholder: string,\n        otherSpans: [number, number][],\n    ) {\n        const regex = getRegexp(tagName);\n        let newScriptMatchSpans = scriptMatchSpans;\n        let newStyleMatchSpans = styleMatchSpans;\n        // Replace valid matches\n        const newSource = _source.replace(regex, (match, attributes, content, index) => {\n            if (match.startsWith('<!--') || withinOtherSpan(index)) {\n                return match;\n            }\n            const encodedContent = Buffer.from(content).toString('base64');\n            const newContent = `<${tagName}${attributes} ${snippedTagContentAttribute}=\"${encodedContent}\">${placeholder}</${tagName}>`;\n\n            // Adjust the spans because the source now has a different content length\n            const lengthDiff = match.length - newContent.length;\n            newScriptMatchSpans = adjustSpans(scriptMatchSpans, newScriptMatchSpans);\n            newStyleMatchSpans = adjustSpans(styleMatchSpans, newStyleMatchSpans);\n            function adjustSpans(\n                oldSpans: [number, number][],\n                newSpans: [number, number][],\n            ): [number, number][] {\n                return oldSpans.map((oldSpan, idx) => {\n                    const newSpan = newSpans[idx];\n                    // Do the check using the old spans because the replace function works\n                    // on the old spans. Replace oldSpans with newSpans afterwards.\n                    if (oldSpan[0] > index) {\n                        // span is after the match -> adjust start and end\n                        return [newSpan[0] - lengthDiff, newSpan[1] - lengthDiff];\n                    } else if (oldSpan[0] === index) {\n                        // span is the match -> adjust end only\n                        return [newSpan[0], newSpan[1] - lengthDiff];\n                    } else {\n                        // span is before the match -> nothing to adjust\n                        return newSpan;\n                    }\n                });\n            }\n\n            return newContent;\n        });\n\n        // Now that the replacement function ran, we can adjust the spans for the next run\n        scriptMatchSpans = newScriptMatchSpans;\n        styleMatchSpans = newStyleMatchSpans;\n\n        return newSource;\n\n        function withinOtherSpan(idx: number) {\n            return otherSpans.some((otherSpan) => idx > otherSpan[0] && idx < otherSpan[1]);\n        }\n    }\n\n    function getRegexp(tagName: string) {\n        return new RegExp(`<!--[^]*?-->|<${tagName}([^]*?)>([^]*?)<\\/${tagName}>`, 'g');\n    }\n}\n\nexport function hasSnippedContent(text: string) {\n    return text.includes(snippedTagContentAttribute);\n}\n\nexport function unsnipContent(text: string): string {\n    const regex = /(<\\w+.*?)\\s*✂prettier:content✂=\"(.*?)\">.*?(?=<\\/)/gi;\n\n    return text.replace(regex, (_, start, encodedContent) => {\n        const content = Buffer.from(encodedContent, 'base64').toString('utf8');\n        return `${start}>${content}`;\n    });\n}\n","import { ParserOptions, SupportOption } from 'prettier';\n\ndeclare module 'prettier' {\n    interface RequiredOptions extends PluginOptions {}\n}\n\nexport interface PluginOptions {\n    svelteSortOrder: SortOrder;\n    svelteStrictMode: boolean;\n    svelteBracketNewLine: boolean;\n    svelteAllowShorthand: boolean;\n    svelteIndentScriptAndStyle: boolean;\n}\n\nfunction makeChoice(choice: string) {\n    return { value: choice, description: choice };\n}\n\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n    svelteSortOrder: {\n        since: '0.6.0',\n        category: 'Svelte',\n        type: 'choice',\n        default: 'options-scripts-markup-styles',\n        description: 'Sort order for scripts, markup, and styles',\n        choices: [\n            makeChoice('options-scripts-markup-styles'),\n            makeChoice('options-scripts-styles-markup'),\n            makeChoice('options-markup-styles-scripts'),\n            makeChoice('options-markup-scripts-styles'),\n            makeChoice('options-styles-markup-scripts'),\n            makeChoice('options-styles-scripts-markup'),\n            makeChoice('scripts-options-markup-styles'),\n            makeChoice('scripts-options-styles-markup'),\n            makeChoice('markup-options-styles-scripts'),\n            makeChoice('markup-options-scripts-styles'),\n            makeChoice('styles-options-markup-scripts'),\n            makeChoice('styles-options-scripts-markup'),\n            makeChoice('scripts-markup-options-styles'),\n            makeChoice('scripts-styles-options-markup'),\n            makeChoice('markup-styles-options-scripts'),\n            makeChoice('markup-scripts-options-styles'),\n            makeChoice('styles-markup-options-scripts'),\n            makeChoice('styles-scripts-options-markup'),\n            makeChoice('scripts-markup-styles-options'),\n            makeChoice('scripts-styles-markup-options'),\n            makeChoice('markup-styles-scripts-options'),\n            makeChoice('markup-scripts-styles-options'),\n            makeChoice('styles-markup-scripts-options'),\n            makeChoice('styles-scripts-markup-options'),\n            // Deprecated, keep in 2.x for backwards-compatibility. svelte:options will be moved to the top\n            makeChoice('scripts-markup-styles'),\n            makeChoice('scripts-styles-markup'),\n            makeChoice('markup-styles-scripts'),\n            makeChoice('markup-scripts-styles'),\n            makeChoice('styles-markup-scripts'),\n            makeChoice('styles-scripts-markup'),\n        ],\n    },\n    svelteStrictMode: {\n        since: '0.7.0',\n        category: 'Svelte',\n        type: 'boolean',\n        default: false,\n        description: 'More strict HTML syntax: self-closed tags, quotes in attributes',\n    },\n    svelteBracketNewLine: {\n        since: '0.6.0',\n        category: 'Svelte',\n        type: 'boolean',\n        description: 'Put the `>` of a multiline element on a new line',\n        deprecated: '2.5.0',\n    },\n    svelteAllowShorthand: {\n        since: '1.0.0',\n        category: 'Svelte',\n        type: 'boolean',\n        default: true,\n        description:\n            'Option to enable/disable component attribute shorthand if attribute name and expressions are same',\n    },\n    svelteIndentScriptAndStyle: {\n        since: '1.2.0',\n        category: 'Svelte',\n        type: 'boolean',\n        default: true,\n        description:\n            'Whether or not to indent the code inside <script> and <style> tags in Svelte files',\n    },\n};\n\nexport type SortOrder =\n    | 'options-scripts-markup-styles'\n    | 'options-scripts-styles-markup'\n    | 'options-markup-styles-scripts'\n    | 'options-markup-scripts-styles'\n    | 'options-styles-markup-scripts'\n    | 'options-styles-scripts-markup'\n    | 'scripts-options-markup-styles'\n    | 'scripts-options-styles-markup'\n    | 'markup-options-styles-scripts'\n    | 'markup-options-scripts-styles'\n    | 'styles-options-markup-scripts'\n    | 'styles-options-scripts-markup'\n    | 'scripts-markup-options-styles'\n    | 'scripts-styles-options-markup'\n    | 'markup-styles-options-scripts'\n    | 'markup-scripts-options-styles'\n    | 'styles-markup-options-scripts'\n    | 'styles-scripts-options-markup'\n    | 'scripts-markup-styles-options'\n    | 'scripts-styles-markup-options'\n    | 'markup-styles-scripts-options'\n    | 'markup-scripts-styles-options'\n    | 'styles-markup-scripts-options'\n    | 'styles-scripts-markup-options'\n    | DeprecatedSortOrder;\n\nexport type DeprecatedSortOrder =\n    | 'scripts-markup-styles'\n    | 'scripts-styles-markup'\n    | 'markup-styles-scripts'\n    | 'markup-scripts-styles'\n    | 'styles-markup-scripts'\n    | 'styles-scripts-markup';\n\nexport type SortOrderPart = 'scripts' | 'markup' | 'styles' | 'options';\n\nconst sortOrderSeparator = '-';\n\nexport function parseSortOrder(sortOrder: SortOrder): SortOrderPart[] {\n    const order = sortOrder.split(sortOrderSeparator) as SortOrderPart[];\n    // For backwards compatibility: Add options to beginning if not present\n    if (!order.includes('options')) {\n        console.warn(\n            'svelteSortOrder is missing option `options`. This will be an error in prettier-plugin-svelte version 3.',\n        );\n        order.unshift('options');\n    }\n    return order;\n}\n\nexport function isBracketSameLine(options: ParserOptions): boolean {\n    return options.svelteBracketNewLine != null\n        ? !options.svelteBracketNewLine\n        : options.bracketSameLine != null\n        ? options.bracketSameLine\n        : false;\n}\n","import { ASTNode, Node } from './nodes';\nimport { Doc, FastPath } from 'prettier';\nimport { formattableAttributes } from '../lib/elements';\n\n/**\n * Determines whether or not given node\n * is the root of the Svelte AST.\n */\nexport function isASTNode(n: any): n is ASTNode {\n    return n && n.__isRoot;\n}\n\nexport function isPreTagContent(path: FastPath): boolean {\n    const stack = path.stack as Node[];\n\n    return stack.some(\n        (node) =>\n            (node.type === 'Element' && node.name.toLowerCase() === 'pre') ||\n            (node.type === 'Attribute' && !formattableAttributes.includes(node.name)),\n    );\n}\n\nexport function flatten<T>(arrays: T[][]): T[] {\n    return ([] as T[]).concat.apply([], arrays);\n}\n\nexport function findLastIndex<T>(isMatch: (item: T, idx: number) => boolean, items: T[]) {\n    for (let i = items.length - 1; i >= 0; i--) {\n        if (isMatch(items[i], i)) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nexport function replaceEndOfLineWith(text: string, replacement: Doc) {\n    const parts: Doc[] = [];\n    for (const part of text.split('\\n')) {\n        if (parts.length > 0) {\n            parts.push(replacement);\n        }\n        if (part.endsWith('\\r')) {\n            parts.push(part.slice(0, -1));\n        } else {\n            parts.push(part);\n        }\n    }\n    return parts;\n}\n","import { Doc, doc } from 'prettier';\nimport { findLastIndex } from './helpers';\n\n/**\n * Check if doc is a hardline.\n * We can't just rely on a simple equality check because the doc could be created with another\n * runtime version of prettier than what we import, making a reference check fail.\n */\nexport function isHardline(docToCheck: Doc): boolean {\n    return docToCheck === doc.builders.hardline || deepEqual(docToCheck, doc.builders.hardline);\n}\n\n/**\n * Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.\n */\nfunction deepEqual(x: any, y: any): boolean {\n    if (x === y) {\n        return true;\n    } else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {\n        if (Object.keys(x).length != Object.keys(y).length) return false;\n\n        for (var prop in x) {\n            if (y.hasOwnProperty(prop)) {\n                if (!deepEqual(x[prop], y[prop])) return false;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isDocCommand(doc: Doc): doc is doc.builders.DocCommand {\n    return typeof doc === 'object' && doc !== null;\n}\n\nexport function isLine(docToCheck: Doc): boolean {\n    return (\n        isHardline(docToCheck) ||\n        (isDocCommand(docToCheck) && docToCheck.type === 'line') ||\n        (isDocCommand(docToCheck) &&\n            docToCheck.type === 'concat' &&\n            docToCheck.parts.every(isLine)) ||\n        // Since Prettier 2.3.0, concats are represented as flat arrays\n        (Array.isArray(docToCheck) && docToCheck.every(isLine))\n    );\n}\n\n/**\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\n */\nexport function isEmptyDoc(doc: Doc): boolean {\n    if (typeof doc === 'string') {\n        return doc.length === 0;\n    }\n\n    if (isDocCommand(doc) && doc.type === 'line') {\n        return !doc.keepIfLonely;\n    }\n\n    // Since Prettier 2.3.0, concats are represented as flat arrays\n    if (Array.isArray(doc)) {\n        return doc.length === 0;\n    }\n\n    const { contents } = doc as { contents?: Doc };\n\n    if (contents) {\n        return isEmptyDoc(contents);\n    }\n\n    const { parts } = doc as { parts?: Doc[] };\n\n    if (parts) {\n        return isEmptyGroup(parts);\n    }\n\n    return false;\n}\n\nexport function isEmptyGroup(group: Doc[]): boolean {\n    return !group.find((doc) => !isEmptyDoc(doc));\n}\n\n/**\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\n */\nexport function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\n    trimLeft(docs, isWhitespace);\n    trimRight(docs, isWhitespace);\n\n    return docs;\n}\n\n/**\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs before the first whitespace, they are removed, too.\n */\nexport function trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n    let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));\n\n    if (firstNonWhitespace < 0 && group.length) {\n        firstNonWhitespace = group.length;\n    }\n\n    if (firstNonWhitespace > 0) {\n        const removed = group.splice(0, firstNonWhitespace);\n        if (removed.every(isEmptyDoc)) {\n            return trimLeft(group, isWhitespace);\n        }\n    } else {\n        const parts = getParts(group[0]);\n\n        if (parts) {\n            return trimLeft(parts, isWhitespace);\n        }\n    }\n}\n\n/**\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs after the last whitespace, they are removed, too.\n */\nexport function trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n    let lastNonWhitespace = group.length\n        ? findLastIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc), group)\n        : 0;\n\n    if (lastNonWhitespace < group.length - 1) {\n        const removed = group.splice(lastNonWhitespace + 1);\n        if (removed.every(isEmptyDoc)) {\n            return trimRight(group, isWhitespace);\n        }\n    } else {\n        const parts = getParts(group[group.length - 1]);\n\n        if (parts) {\n            return trimRight(parts, isWhitespace);\n        }\n    }\n}\n\nfunction getParts(doc: Doc): Doc[] | undefined {\n    if (typeof doc === 'object') {\n        // Since Prettier 2.3.0, concats are represented as flat arrays\n        if (Array.isArray(doc)) {\n            return doc;\n        }\n        if (doc.type === 'fill' || doc.type === 'concat') {\n            return doc.parts;\n        }\n        if (doc.type === 'group') {\n            return getParts(doc.contents);\n        }\n    }\n}\n\n/**\n * `(foo = bar)` => `foo = bar`\n */\nexport function removeParentheses(doc: Doc): Doc {\n    return trim([doc], (_doc: Doc) => _doc === '(' || _doc === ')')[0];\n}\n","import {\n    Node,\n    ElementNode,\n    TextNode,\n    AttributeNode,\n    MustacheTagNode,\n    AttributeShorthandNode,\n    HeadNode,\n    InlineComponentNode,\n    SlotNode,\n    TitleNode,\n    WindowNode,\n    IfBlockNode,\n    AwaitBlockNode,\n    CatchBlockNode,\n    EachBlockNode,\n    ElseBlockNode,\n    KeyBlockNode,\n    PendingBlockNode,\n    ThenBlockNode,\n    CommentNode,\n    SlotTemplateNode,\n    StyleDirectiveNode,\n} from './nodes';\nimport { blockElements, TagName } from '../lib/elements';\nimport { FastPath, ParserOptions } from 'prettier';\nimport { findLastIndex, isASTNode, isPreTagContent } from './helpers';\nimport { isBracketSameLine } from '../options';\n\nconst unsupportedLanguages = ['coffee', 'coffeescript', 'styl', 'stylus', 'sass'];\n\nexport function isInlineElement(path: FastPath, options: ParserOptions, node: Node) {\n    return (\n        node && node.type === 'Element' && !isBlockElement(node, options) && !isPreTagContent(path)\n    );\n}\n\nexport function isBlockElement(node: Node, options: ParserOptions): node is ElementNode {\n    return (\n        node &&\n        node.type === 'Element' &&\n        options.htmlWhitespaceSensitivity !== 'strict' &&\n        (options.htmlWhitespaceSensitivity === 'ignore' ||\n            blockElements.includes(node.name as TagName))\n    );\n}\n\nexport function isSvelteBlock(\n    node: Node,\n): node is\n    | IfBlockNode\n    | AwaitBlockNode\n    | CatchBlockNode\n    | EachBlockNode\n    | ElseBlockNode\n    | KeyBlockNode\n    | PendingBlockNode\n    | ThenBlockNode {\n    return [\n        'IfBlock',\n        'AwaitBlock',\n        'CatchBlock',\n        'EachBlock',\n        'ElseBlock',\n        'KeyBlock',\n        'PendingBlock',\n        'ThenBlock',\n    ].includes(node.type);\n}\n\nexport function isNodeWithChildren(node: Node): node is Node & { children: Node[] } {\n    return (node as any).children;\n}\n\nexport function getChildren(node: Node): Node[] {\n    return isNodeWithChildren(node) ? node.children : [];\n}\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\nexport function getSiblings(path: FastPath): Node[] {\n    let parent: Node = path.getParentNode();\n\n    if (isASTNode(parent)) {\n        parent = parent.html;\n    }\n\n    return getChildren(parent);\n}\n\n/**\n * Returns the previous sibling node.\n */\nexport function getPreviousNode(path: FastPath): Node | undefined {\n    const node: Node = path.getNode();\n    return getSiblings(path).find((child) => child.end === node.start);\n}\n\n/**\n * Returns the next sibling node.\n */\nexport function getNextNode(path: FastPath, node: Node = path.getNode()): Node | undefined {\n    return getSiblings(path).find((child) => child.start === node.end);\n}\n\n/**\n * Returns the comment that is above the current node.\n */\nexport function getLeadingComment(path: FastPath): CommentNode | undefined {\n    const siblings = getSiblings(path);\n\n    let node: Node = path.getNode();\n    let prev: Node | undefined = siblings.find((child) => child.end === node.start);\n    while (prev) {\n        if (\n            prev.type === 'Comment' &&\n            !isIgnoreStartDirective(prev) &&\n            !isIgnoreEndDirective(prev)\n        ) {\n            return prev;\n        } else if (isEmptyTextNode(prev)) {\n            node = prev;\n            prev = siblings.find((child) => child.end === node.start);\n        } else {\n            return undefined;\n        }\n    }\n}\n\n/**\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\n * at the specified position?\n */\nexport function doesEmbedStartAfterNode(node: Node, path: FastPath, siblings = getSiblings(path)) {\n    // If node is not at the top level of html, an embed cannot start after it,\n    // because embeds are only at the top level\n    if (!isNodeTopLevelHTML(node, path)) {\n        return false;\n    }\n\n    const position = node.end;\n    const root = path.stack[0];\n\n    const embeds = [root.css, root.html, root.instance, root.js, root.module] as Node[];\n\n    const nextNode = siblings[siblings.indexOf(node) + 1];\n    return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));\n}\n\nexport function isNodeTopLevelHTML(node: Node, path: FastPath): boolean {\n    const root = path.stack[0];\n    return !!root.html && !!root.html.children && root.html.children.includes(node);\n}\n\nexport function isEmptyTextNode(node: Node | undefined): node is TextNode {\n    return !!node && node.type === 'Text' && getUnencodedText(node).trim() === '';\n}\n\nexport function isIgnoreDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore';\n}\n\nexport function isIgnoreStartDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore-start';\n}\n\nexport function isIgnoreEndDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore-end';\n}\n\nexport function printRaw(\n    node:\n        | ElementNode\n        | InlineComponentNode\n        | SlotNode\n        | WindowNode\n        | HeadNode\n        | TitleNode\n        | SlotTemplateNode,\n    originalText: string,\n    stripLeadingAndTrailingNewline: boolean = false,\n): string {\n    if (node.children.length === 0) {\n        return '';\n    }\n\n    const firstChild = node.children[0];\n    const lastChild = node.children[node.children.length - 1];\n\n    let raw = originalText.substring(firstChild.start, lastChild.end);\n\n    if (!stripLeadingAndTrailingNewline) {\n        return raw;\n    }\n\n    if (startsWithLinebreak(raw)) {\n        raw = raw.substring(raw.indexOf('\\n') + 1);\n    }\n    if (endsWithLinebreak(raw)) {\n        raw = raw.substring(0, raw.lastIndexOf('\\n'));\n        if (raw.charAt(raw.length - 1) === '\\r') {\n            raw = raw.substring(0, raw.length - 1);\n        }\n    }\n\n    return raw;\n}\n\nfunction isTextNode(node: Node): node is TextNode {\n    return node.type === 'Text';\n}\n\nfunction getAttributeValue(attributeName: string, node: Node) {\n    const attributes = (node as ElementNode)['attributes'] as AttributeNode[];\n\n    const langAttribute = attributes.find(\n        (attribute) => attribute.name === attributeName,\n    ) as AttributeNode | null;\n\n    return langAttribute && langAttribute.value;\n}\n\nexport function getAttributeTextValue(attributeName: string, node: Node): string | null {\n    const value = getAttributeValue(attributeName, node);\n\n    if (value != null && typeof value === 'object') {\n        const textValue = value.find(isTextNode);\n\n        if (textValue) {\n            return textValue.data;\n        }\n    }\n\n    return null;\n}\n\nfunction getLangAttribute(node: Node): string | null {\n    const value = getAttributeTextValue('lang', node) || getAttributeTextValue('type', node);\n\n    if (value != null) {\n        return value.replace(/^text\\//, '');\n    } else {\n        return null;\n    }\n}\n\n/**\n * Checks whether the node contains a `lang` or `type` attribute with a value corresponding to\n * a language we cannot format. This might for example be `<template lang=\"pug\">`.\n * If the node does not contain a `lang` attribute, the result is true.\n */\nexport function isNodeSupportedLanguage(node: Node) {\n    const lang = getLangAttribute(node);\n\n    return !(lang && unsupportedLanguages.includes(lang));\n}\n\n/**\n * Checks whether the node contains a `lang` or `type` attribute which indicates that\n * the script contents are written in TypeScript. Note that the absence of the tag\n * does not mean it's not TypeScript, because the user could have set the default\n * to TypeScript in his settings.\n */\nexport function isTypeScript(node: Node) {\n    const lang = getLangAttribute(node) || '';\n    return ['typescript', 'ts'].includes(lang);\n}\n\nexport function isPugTemplate(node: Node): boolean {\n    return node.type === 'Element' && node.name === 'template' && getLangAttribute(node) === 'pug';\n}\n\nexport function isLoneMustacheTag(node: true | Node[]): node is [MustacheTagNode] {\n    return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\n}\n\nexport function isAttributeShorthand(node: true | Node[]): node is [AttributeShorthandNode] {\n    return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\n}\n\n/**\n * True if node is of type `{a}` or `a={a}`\n */\nexport function isOrCanBeConvertedToShorthand(node: AttributeNode | StyleDirectiveNode): boolean {\n    if (isAttributeShorthand(node.value)) {\n        return true;\n    }\n\n    if (isLoneMustacheTag(node.value)) {\n        const expression = node.value[0].expression;\n        return expression.type === 'Identifier' && expression.name === node.name;\n    }\n\n    return false;\n}\n\nexport function getUnencodedText(node: TextNode) {\n    // `raw` will contain HTML entities in unencoded form\n    return node.raw || node.data;\n}\n\nexport function isTextNodeStartingWithLinebreak(node: Node, nrLines = 1): node is TextNode {\n    return node.type === 'Text' && startsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function startsWithLinebreak(text: string, nrLines = 1): boolean {\n    return new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\n}\n\nexport function isTextNodeEndingWithLinebreak(node: Node, nrLines = 1): node is TextNode {\n    return node.type === 'Text' && endsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function endsWithLinebreak(text: string, nrLines = 1): boolean {\n    return new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\n}\n\nexport function isTextNodeStartingWithWhitespace(node: Node): node is TextNode {\n    return node.type === 'Text' && /^\\s/.test(getUnencodedText(node));\n}\n\nexport function isTextNodeEndingWithWhitespace(node: Node): node is TextNode {\n    return node.type === 'Text' && /\\s$/.test(getUnencodedText(node));\n}\n\nexport function trimTextNodeRight(node: TextNode): void {\n    node.raw = node.raw && node.raw.trimRight();\n    node.data = node.data && node.data.trimRight();\n}\n\nexport function trimTextNodeLeft(node: TextNode): void {\n    node.raw = node.raw && node.raw.trimLeft();\n    node.data = node.data && node.data.trimLeft();\n}\n\n/**\n * Remove all leading whitespace up until the first non-empty text node,\n * and all trailing whitespace from the last non-empty text node onwards.\n */\nexport function trimChildren(children: Node[], path: FastPath): void {\n    let firstNonEmptyNode = children.findIndex(\n        (n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path),\n    );\n    firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;\n\n    let lastNonEmptyNode = findLastIndex((n, idx) => {\n        // Last node is ok to end at the start of an embedded region,\n        // if it's not a comment (which should stick to the region)\n        return (\n            !isEmptyTextNode(n) &&\n            ((idx === children.length - 1 && n.type !== 'Comment') ||\n                !doesEmbedStartAfterNode(n, path))\n        );\n    }, children);\n    lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;\n\n    for (let i = 0; i <= firstNonEmptyNode; i++) {\n        const n = children[i];\n        if (n.type === 'Text') {\n            trimTextNodeLeft(n);\n        }\n    }\n\n    for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {\n        const n = children[i];\n        if (n.type === 'Text') {\n            trimTextNodeRight(n);\n        }\n    }\n}\n\n/**\n * Check if given node's start tag should hug its first child. This is the case for inline elements when there's\n * no whitespace between the `>` and the first child.\n */\nexport function shouldHugStart(\n    node: Node,\n    isSupportedLanguage: boolean,\n    options: ParserOptions,\n): boolean {\n    if (!isSupportedLanguage) {\n        return true;\n    }\n\n    if (isBlockElement(node, options)) {\n        return false;\n    }\n\n    if (!isNodeWithChildren(node)) {\n        return false;\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return true;\n    }\n\n    if (options.htmlWhitespaceSensitivity === 'ignore') {\n        return false;\n    }\n\n    const firstChild = children[0];\n    return !isTextNodeStartingWithWhitespace(firstChild);\n}\n\n/**\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\n * no whitespace between the last child and the `</`.\n */\nexport function shouldHugEnd(\n    node: Node,\n    isSupportedLanguage: boolean,\n    options: ParserOptions,\n): boolean {\n    if (!isSupportedLanguage) {\n        return true;\n    }\n\n    if (isBlockElement(node, options)) {\n        return false;\n    }\n\n    if (!isNodeWithChildren(node)) {\n        return false;\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return true;\n    }\n\n    if (options.htmlWhitespaceSensitivity === 'ignore') {\n        return false;\n    }\n\n    const lastChild = children[children.length - 1];\n    return !isTextNodeEndingWithWhitespace(lastChild);\n}\n\n/**\n * Check for a svelte block if there's whitespace at the start and if it's a space or a line.\n */\nexport function checkWhitespaceAtStartOfSvelteBlock(\n    node: Node,\n    options: ParserOptions,\n): 'none' | 'space' | 'line' {\n    if (!isSvelteBlock(node) || !isNodeWithChildren(node)) {\n        return 'none';\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return 'none';\n    }\n\n    const firstChild = children[0];\n\n    if (isTextNodeStartingWithLinebreak(firstChild)) {\n        return 'line';\n    } else if (isTextNodeStartingWithWhitespace(firstChild)) {\n        return 'space';\n    }\n\n    // This extra check is necessary because the Svelte AST might swallow whitespace between\n    // the block's starting end and its first child.\n    const parentOpeningEnd = options.originalText.lastIndexOf('}', firstChild.start);\n    if (parentOpeningEnd > 0 && firstChild.start > parentOpeningEnd + 1) {\n        const textBetween = options.originalText.substring(parentOpeningEnd + 1, firstChild.start);\n        if (textBetween.trim() === '') {\n            return startsWithLinebreak(textBetween) ? 'line' : 'space';\n        }\n    }\n\n    return 'none';\n}\n\n/**\n * Check for a svelte block if there's whitespace at the end and if it's a space or a line.\n */\nexport function checkWhitespaceAtEndOfSvelteBlock(\n    node: Node,\n    options: ParserOptions,\n): 'none' | 'space' | 'line' {\n    if (!isSvelteBlock(node) || !isNodeWithChildren(node)) {\n        return 'none';\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return 'none';\n    }\n\n    const lastChild = children[children.length - 1];\n    if (isTextNodeEndingWithLinebreak(lastChild)) {\n        return 'line';\n    } else if (isTextNodeEndingWithWhitespace(lastChild)) {\n        return 'space';\n    }\n\n    // This extra check is necessary because the Svelte AST might swallow whitespace between\n    // the last child and the block's ending start.\n    const parentClosingStart = options.originalText.indexOf('{', lastChild.end);\n    if (parentClosingStart > 0 && lastChild.end < parentClosingStart) {\n        const textBetween = options.originalText.substring(lastChild.end, parentClosingStart);\n        if (textBetween.trim() === '') {\n            return endsWithLinebreak(textBetween) ? 'line' : 'space';\n        }\n    }\n\n    return 'none';\n}\n\nexport function isInsideQuotedAttribute(path: FastPath, options: ParserOptions): boolean {\n    const stack = path.stack as Node[];\n\n    return stack.some(\n        (node) =>\n            node.type === 'Attribute' &&\n            (!isLoneMustacheTag(node.value) || options.svelteStrictMode),\n    );\n}\n\n/**\n * Returns true if the softline between `</tagName` and `>` can be omitted.\n */\nexport function canOmitSoftlineBeforeClosingTag(\n    node: Node,\n    path: FastPath,\n    options: ParserOptions,\n): boolean {\n    return (\n        isBracketSameLine(options) &&\n        (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options))\n    );\n}\n\n/**\n * Return true if given node does not hug the next node, meaning there's whitespace\n * or the end of the doc afterwards.\n */\nfunction hugsStartOfNextNode(node: Node, options: ParserOptions): boolean {\n    if (node.end === options.originalText.length) {\n        // end of document\n        return false;\n    }\n\n    return !options.originalText.substring(node.end).match(/^\\s/);\n}\n\nfunction isLastChildWithinParentBlockElement(path: FastPath, options: ParserOptions): boolean {\n    const parent = path.getParentNode() as Node | undefined;\n    if (!parent || !isBlockElement(parent, options)) {\n        return false;\n    }\n\n    const children = getChildren(parent);\n    const lastChild = children[children.length - 1];\n    return lastChild === path.getNode();\n}\n","import { Doc, doc, FastPath, ParserOptions } from 'prettier';\nimport { formattableAttributes, selfClosingTags } from '../lib/elements';\nimport { extractAttributes } from '../lib/extractAttributes';\nimport { getText } from '../lib/getText';\nimport { hasSnippedContent, unsnipContent } from '../lib/snipTagContent';\nimport { isBracketSameLine, parseSortOrder, SortOrderPart } from '../options';\nimport { isEmptyDoc, isLine, trim, trimRight } from './doc-helpers';\nimport { flatten, isASTNode, isPreTagContent, replaceEndOfLineWith } from './helpers';\nimport {\n    checkWhitespaceAtEndOfSvelteBlock,\n    checkWhitespaceAtStartOfSvelteBlock,\n    doesEmbedStartAfterNode,\n    endsWithLinebreak,\n    getUnencodedText,\n    isBlockElement,\n    isEmptyTextNode,\n    isIgnoreDirective,\n    isInlineElement,\n    isInsideQuotedAttribute,\n    isLoneMustacheTag,\n    isNodeSupportedLanguage,\n    isOrCanBeConvertedToShorthand,\n    isTextNodeEndingWithLinebreak,\n    isTextNodeEndingWithWhitespace,\n    isTextNodeStartingWithLinebreak,\n    isTextNodeStartingWithWhitespace,\n    printRaw,\n    shouldHugEnd,\n    shouldHugStart,\n    startsWithLinebreak,\n    trimChildren,\n    trimTextNodeLeft,\n    trimTextNodeRight,\n    canOmitSoftlineBeforeClosingTag,\n    getNextNode,\n    isIgnoreStartDirective,\n    isIgnoreEndDirective,\n    isNodeTopLevelHTML,\n} from './node-helpers';\nimport {\n    ASTNode,\n    AttributeNode,\n    CommentNode,\n    IfBlockNode,\n    Node,\n    OptionsNode,\n    StyleDirectiveNode,\n    TextNode,\n} from './nodes';\n\nconst {\n    concat,\n    join,\n    line,\n    group,\n    indent,\n    dedent,\n    softline,\n    hardline,\n    fill,\n    breakParent,\n    literalline,\n} = doc.builders;\n\nexport type PrintFn = (path: FastPath) => Doc;\n\ndeclare module 'prettier' {\n    export namespace doc {\n        namespace builders {\n            interface Line {\n                keepIfLonely?: boolean;\n            }\n        }\n    }\n}\n\nlet ignoreNext = false;\nlet ignoreRange = false;\nlet svelteOptionsDoc: Doc | undefined;\n\nfunction groupConcat(contents: doc.builders.Doc[]): doc.builders.Doc {\n    return group(concat(contents));\n}\n\nexport function print(path: FastPath, options: ParserOptions, print: PrintFn): Doc {\n    const bracketSameLine = isBracketSameLine(options);\n\n    const n = path.getValue();\n    if (!n) {\n        return '';\n    }\n\n    if (isASTNode(n)) {\n        return printTopLevelParts(n, options, path, print);\n    }\n\n    const [open, close] = options.svelteStrictMode ? ['\"{', '}\"'] : ['{', '}'];\n    const printJsExpression = () => [\n        open,\n        printJS(path, print, options.svelteStrictMode, false, false, 'expression'),\n        close,\n    ];\n    const node = n as Node;\n\n    if (\n        (ignoreNext || (ignoreRange && !isIgnoreEndDirective(node))) &&\n        (node.type !== 'Text' || !isEmptyTextNode(node))\n    ) {\n        if (ignoreNext) {\n            ignoreNext = false;\n        }\n        return concat(\n            flatten(\n                options.originalText\n                    .slice(options.locStart(node), options.locEnd(node))\n                    .split('\\n')\n                    .map((o, i) => (i == 0 ? [o] : [literalline, o])),\n            ),\n        );\n    }\n\n    switch (node.type) {\n        case 'Fragment':\n            const children = node.children;\n\n            if (children.length === 0 || children.every(isEmptyTextNode)) {\n                return '';\n            }\n            if (!isPreTagContent(path)) {\n                trimChildren(node.children, path);\n                const output = trim(\n                    [printChildren(path, print, options)],\n                    (n) =>\n                        isLine(n) ||\n                        (typeof n === 'string' && n.trim() === '') ||\n                        // Because printChildren may append this at the end and\n                        // may hide other lines before it\n                        n === breakParent,\n                );\n                if (output.every((doc) => isEmptyDoc(doc))) {\n                    return '';\n                }\n                return groupConcat([...output, hardline]);\n            } else {\n                return groupConcat(path.map(print, 'children'));\n            }\n        case 'Text':\n            if (!isPreTagContent(path)) {\n                if (isEmptyTextNode(node)) {\n                    const hasWhiteSpace =\n                        getUnencodedText(node).trim().length < getUnencodedText(node).length;\n                    const hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\n                    const hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node));\n                    if (hasTwoOrMoreNewlines) {\n                        return concat([hardline, hardline]);\n                    }\n                    if (hasOneOrMoreNewlines) {\n                        return hardline;\n                    }\n                    if (hasWhiteSpace) {\n                        return line;\n                    }\n                    return '';\n                }\n\n                /**\n                 * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n                 * each \"word\") is joined by a single `line`, which will be rendered as a single space\n                 * until this node's current line is out of room, at which `fill` will break at the\n                 * most convenient instance of `line`.\n                 */\n                return fill(splitTextToDocs(node));\n            } else {\n                const rawText = getUnencodedText(node);\n                if (path.getParentNode().type === 'Attribute') {\n                    // Direct child of attribute value -> add literallines at end of lines\n                    // so that other things don't break in unexpected places\n                    return concat(replaceEndOfLineWith(rawText, literalline));\n                }\n                return rawText;\n            }\n        case 'Element':\n        case 'InlineComponent':\n        case 'Slot':\n        case 'SlotTemplate':\n        case 'Window':\n        case 'Head':\n        case 'Title': {\n            const isSupportedLanguage = !(\n                node.name === 'template' && !isNodeSupportedLanguage(node)\n            );\n            const isEmpty = node.children.every((child) => isEmptyTextNode(child));\n\n            const isSelfClosingTag =\n                isEmpty &&\n                (!options.svelteStrictMode ||\n                    node.type !== 'Element' ||\n                    selfClosingTags.indexOf(node.name) !== -1);\n\n            // Order important: print attributes first\n            const attributes = path.map((childPath) => childPath.call(print), 'attributes');\n            const possibleThisBinding =\n                node.type === 'InlineComponent' && node.expression\n                    ? concat([line, 'this=', ...printJsExpression()])\n                    : node.type === 'Element' && node.tag\n                    ? concat([\n                          line,\n                          'this=',\n                          ...(typeof node.tag === 'string'\n                              ? [`\"${node.tag}\"`]\n                              : [\n                                    open,\n                                    printJS(\n                                        path,\n                                        print,\n                                        options.svelteStrictMode,\n                                        false,\n                                        false,\n                                        'tag',\n                                    ),\n                                    close,\n                                ]),\n                      ])\n                    : '';\n\n            if (isSelfClosingTag) {\n                return groupConcat([\n                    '<',\n                    node.name,\n\n                    indent(\n                        groupConcat([\n                            possibleThisBinding,\n                            ...attributes,\n                            bracketSameLine ? '' : dedent(line),\n                        ]),\n                    ),\n\n                    ...[bracketSameLine ? ' ' : '', `/>`],\n                ]);\n            }\n\n            const children = node.children;\n            const firstChild = children[0];\n            const lastChild = children[children.length - 1];\n\n            // Is a function which is invoked later because printChildren will manipulate child nodes\n            // which would wrongfully change the other checks about hugging etc done beforehand\n            let body: () => Doc;\n\n            const hugStart = shouldHugStart(node, isSupportedLanguage, options);\n            const hugEnd = shouldHugEnd(node, isSupportedLanguage, options);\n\n            if (isEmpty) {\n                body =\n                    isInlineElement(path, options, node) &&\n                    node.children.length &&\n                    isTextNodeStartingWithWhitespace(node.children[0]) &&\n                    !isPreTagContent(path)\n                        ? () => line\n                        : () => (bracketSameLine ? softline : '');\n            } else if (isPreTagContent(path)) {\n                body = () => printPre(node, options.originalText, path, print);\n            } else if (!isSupportedLanguage) {\n                body = () => printRaw(node, options.originalText, true);\n            } else if (isInlineElement(path, options, node) && !isPreTagContent(path)) {\n                body = () => printChildren(path, print, options);\n            } else {\n                body = () => printChildren(path, print, options);\n            }\n\n            const openingTag = [\n                '<',\n                node.name,\n\n                indent(\n                    groupConcat([\n                        possibleThisBinding,\n                        ...attributes,\n                        hugStart\n                            ? ''\n                            : !bracketSameLine && !isPreTagContent(path)\n                            ? dedent(softline)\n                            : '',\n                    ]),\n                ),\n            ];\n\n            if (!isSupportedLanguage && !isEmpty) {\n                // Format template tags so that there's a hardline but no indention.\n                // That way the `lang=\"X\"` and the closing `>` of the start tag stay in one line\n                // which is the 99% use case.\n                return groupConcat([\n                    ...openingTag,\n                    '>',\n                    groupConcat([hardline, body(), hardline]),\n                    `</${node.name}>`,\n                ]);\n            }\n\n            if (hugStart && hugEnd) {\n                const huggedContent = concat([\n                    softline,\n                    groupConcat(['>', body(), `</${node.name}`]),\n                ]);\n                const omitSoftlineBeforeClosingTag =\n                    (isEmpty && !bracketSameLine) ||\n                    canOmitSoftlineBeforeClosingTag(node, path, options);\n                return groupConcat([\n                    ...openingTag,\n                    isEmpty ? group(huggedContent) : group(indent(huggedContent)),\n                    omitSoftlineBeforeClosingTag ? '' : softline,\n                    '>',\n                ]);\n            }\n\n            // No hugging of content means it's either a block element and/or there's whitespace at the start/end\n            let noHugSeparatorStart: Doc = softline;\n            let noHugSeparatorEnd: Doc = softline;\n            if (isPreTagContent(path)) {\n                noHugSeparatorStart = '';\n                noHugSeparatorEnd = '';\n            } else {\n                let didSetEndSeparator = false;\n\n                if (!hugStart && firstChild && firstChild.type === 'Text') {\n                    if (\n                        isTextNodeStartingWithLinebreak(firstChild) &&\n                        firstChild !== lastChild &&\n                        (!isInlineElement(path, options, node) ||\n                            isTextNodeEndingWithWhitespace(lastChild))\n                    ) {\n                        noHugSeparatorStart = hardline;\n                        noHugSeparatorEnd = hardline;\n                        didSetEndSeparator = true;\n                    } else if (isInlineElement(path, options, node)) {\n                        noHugSeparatorStart = line;\n                    }\n                    trimTextNodeLeft(firstChild);\n                }\n                if (!hugEnd && lastChild && lastChild.type === 'Text') {\n                    if (isInlineElement(path, options, node) && !didSetEndSeparator) {\n                        noHugSeparatorEnd = line;\n                    }\n                    trimTextNodeRight(lastChild);\n                }\n            }\n\n            if (hugStart) {\n                return groupConcat([\n                    ...openingTag,\n                    indent(concat([softline, groupConcat(['>', body()])])),\n                    noHugSeparatorEnd,\n                    `</${node.name}>`,\n                ]);\n            }\n\n            if (hugEnd) {\n                return groupConcat([\n                    ...openingTag,\n                    '>',\n                    indent(concat([noHugSeparatorStart, groupConcat([body(), `</${node.name}`])])),\n                    canOmitSoftlineBeforeClosingTag(node, path, options) ? '' : softline,\n                    '>',\n                ]);\n            }\n\n            if (isEmpty) {\n                return groupConcat([...openingTag, '>', body(), `</${node.name}>`]);\n            }\n\n            return groupConcat([\n                ...openingTag,\n                '>',\n                indent(concat([noHugSeparatorStart, body()])),\n                noHugSeparatorEnd,\n                `</${node.name}>`,\n            ]);\n        }\n        case 'Options':\n            throw new Error('Options tags should have been handled by prepareChildren');\n        case 'Body':\n            return groupConcat([\n                '<',\n                node.name,\n\n                indent(groupConcat(path.map((childPath) => childPath.call(print), 'attributes'))),\n\n                ' />',\n            ]);\n        case 'Identifier':\n            return node.name;\n        case 'AttributeShorthand': {\n            return (node.expression as any).name;\n        }\n        case 'Attribute': {\n            if (isOrCanBeConvertedToShorthand(node)) {\n                if (options.svelteStrictMode) {\n                    return concat([line, node.name, '=\"{', node.name, '}\"']);\n                } else if (options.svelteAllowShorthand) {\n                    return concat([line, '{', node.name, '}']);\n                } else {\n                    return concat([line, node.name, '={', node.name, '}']);\n                }\n            } else {\n                if (node.value === true) {\n                    return concat([line, node.name]);\n                }\n\n                const quotes = !isLoneMustacheTag(node.value) || options.svelteStrictMode;\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\n                if (quotes) {\n                    return concat([line, node.name, '=', '\"', attrNodeValue, '\"']);\n                } else {\n                    return concat([line, node.name, '=', attrNodeValue]);\n                }\n            }\n        }\n        case 'MustacheTag':\n            return concat([\n                '{',\n                printJS(\n                    path,\n                    print,\n                    isInsideQuotedAttribute(path, options),\n                    false,\n                    false,\n                    'expression',\n                ),\n                '}',\n            ]);\n        case 'IfBlock': {\n            const def: Doc[] = [\n                '{#if ',\n                printSvelteBlockJS(path, print, 'expression'),\n                '}',\n                printSvelteBlockChildren(path, print, options),\n            ];\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/if}');\n\n            return concat([groupConcat(def), breakParent]);\n        }\n        case 'ElseBlock': {\n            // Else if\n            const parent = path.getParentNode() as Node;\n\n            if (\n                node.children.length === 1 &&\n                node.children[0].type === 'IfBlock' &&\n                parent.type !== 'EachBlock'\n            ) {\n                const ifNode = node.children[0] as IfBlockNode;\n                const def: Doc[] = [\n                    '{:else if ',\n                    path.map(\n                        (ifPath) => printSvelteBlockJS(ifPath, print, 'expression'),\n                        'children',\n                    )[0],\n                    '}',\n                    path.map(\n                        (ifPath) => printSvelteBlockChildren(ifPath, print, options),\n                        'children',\n                    )[0],\n                ];\n\n                if (ifNode.else) {\n                    def.push(path.map((ifPath) => ifPath.call(print, 'else'), 'children')[0]);\n                }\n                return concat(def);\n            }\n\n            return concat(['{:else}', printSvelteBlockChildren(path, print, options)]);\n        }\n        case 'EachBlock': {\n            const def: Doc[] = [\n                '{#each ',\n                printSvelteBlockJS(path, print, 'expression'),\n                ' as',\n                expandNode(node.context),\n            ];\n\n            if (node.index) {\n                def.push(', ', node.index);\n            }\n\n            if (node.key) {\n                def.push(' (', printSvelteBlockJS(path, print, 'key'), ')');\n            }\n\n            def.push('}', printSvelteBlockChildren(path, print, options));\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/each}');\n\n            return concat([groupConcat(def), breakParent]);\n        }\n        case 'AwaitBlock': {\n            const hasPendingBlock = node.pending.children.some((n) => !isEmptyTextNode(n));\n            const hasThenBlock = node.then.children.some((n) => !isEmptyTextNode(n));\n            const hasCatchBlock = node.catch.children.some((n) => !isEmptyTextNode(n));\n\n            let block = [];\n\n            if (!hasPendingBlock && hasThenBlock) {\n                block.push(\n                    groupConcat([\n                        '{#await ',\n                        printSvelteBlockJS(path, print, 'expression'),\n                        ' then',\n                        expandNode(node.value),\n                        '}',\n                    ]),\n                    path.call(print, 'then'),\n                );\n            } else {\n                block.push(\n                    groupConcat(['{#await ', printSvelteBlockJS(path, print, 'expression'), '}']),\n                );\n\n                if (hasPendingBlock) {\n                    block.push(path.call(print, 'pending'));\n                }\n\n                if (hasThenBlock) {\n                    block.push(\n                        groupConcat(['{:then', expandNode(node.value), '}']),\n                        path.call(print, 'then'),\n                    );\n                }\n            }\n\n            if (hasCatchBlock) {\n                block.push(\n                    groupConcat(['{:catch', expandNode(node.error), '}']),\n                    path.call(print, 'catch'),\n                );\n            }\n\n            block.push('{/await}');\n\n            return groupConcat(block);\n        }\n        case 'KeyBlock': {\n            const def: Doc[] = [\n                '{#key ',\n                printSvelteBlockJS(path, print, 'expression'),\n                '}',\n                printSvelteBlockChildren(path, print, options),\n            ];\n\n            def.push('{/key}');\n\n            return concat([groupConcat(def), breakParent]);\n        }\n        case 'ThenBlock':\n        case 'PendingBlock':\n        case 'CatchBlock':\n            return printSvelteBlockChildren(path, print, options);\n        case 'EventHandler':\n            return concat([\n                line,\n                'on:',\n                node.name,\n                node.modifiers && node.modifiers.length\n                    ? concat(['|', join('|', node.modifiers)])\n                    : '',\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\n            ]);\n        case 'Binding':\n            return concat([\n                line,\n                'bind:',\n                node.name,\n                node.expression.type === 'Identifier' && node.expression.name === node.name\n                    ? ''\n                    : concat(['=', ...printJsExpression()]),\n            ]);\n        case 'Class':\n            return concat([\n                line,\n                'class:',\n                node.name,\n                node.expression.type === 'Identifier' && node.expression.name === node.name\n                    ? ''\n                    : concat(['=', ...printJsExpression()]),\n            ]);\n        case 'StyleDirective':\n            if (isOrCanBeConvertedToShorthand(node)) {\n                if (options.svelteStrictMode) {\n                    return concat([line, 'style:', node.name, '=\"{', node.name, '}\"']);\n                } else if (options.svelteAllowShorthand) {\n                    return concat([line, 'style:', node.name]);\n                } else {\n                    return concat([line, 'style:', node.name, '={', node.name, '}']);\n                }\n            } else {\n                if (node.value === true) {\n                    return concat([line, 'style:', node.name]);\n                }\n\n                const quotes = !isLoneMustacheTag(node.value) || options.svelteStrictMode;\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\n                if (quotes) {\n                    return concat([line, 'style:', node.name, '=', '\"', attrNodeValue, '\"']);\n                } else {\n                    return concat([line, 'style:', node.name, '=', attrNodeValue]);\n                }\n            }\n        case 'Let':\n            return concat([\n                line,\n                'let:',\n                node.name,\n                // shorthand let directives have `null` expressions\n                !node.expression ||\n                (node.expression.type === 'Identifier' && node.expression.name === node.name)\n                    ? ''\n                    : concat(['=', ...printJsExpression()]),\n            ]);\n        case 'DebugTag':\n            return concat([\n                '{@debug',\n                node.identifiers.length > 0\n                    ? concat([' ', join(', ', path.map(print, 'identifiers'))])\n                    : '',\n                '}',\n            ]);\n        case 'Ref':\n            return concat([line, 'ref:', node.name]);\n        case 'Comment': {\n            const nodeAfterComment = getNextNode(path);\n\n            if (isIgnoreStartDirective(node) && isNodeTopLevelHTML(node, path)) {\n                ignoreRange = true;\n            } else if (isIgnoreEndDirective(node) && isNodeTopLevelHTML(node, path)) {\n                ignoreRange = false;\n            } else if (\n                // If there is no sibling node that starts right after us but the parent indicates\n                // that there used to be, that means that node was actually an embedded `<style>`\n                // or `<script>` node that was cut out.\n                // If so, the comment does not refer to the next line we will see.\n                // The `embed` function handles printing the comment in the right place.\n                doesEmbedStartAfterNode(node, path) ||\n                (isEmptyTextNode(nodeAfterComment) &&\n                    doesEmbedStartAfterNode(nodeAfterComment, path))\n            ) {\n                return '';\n            } else if (isIgnoreDirective(node)) {\n                ignoreNext = true;\n            }\n\n            return printComment(node);\n        }\n        case 'Transition':\n            const kind = node.intro && node.outro ? 'transition' : node.intro ? 'in' : 'out';\n            return concat([\n                line,\n                kind,\n                ':',\n                node.name,\n                node.modifiers && node.modifiers.length\n                    ? concat(['|', join('|', node.modifiers)])\n                    : '',\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\n            ]);\n        case 'Action':\n            return concat([\n                line,\n                'use:',\n                node.name,\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\n            ]);\n        case 'Animation':\n            return concat([\n                line,\n                'animate:',\n                node.name,\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\n            ]);\n        case 'RawMustacheTag':\n            return concat([\n                '{@html ',\n                printJS(path, print, false, false, false, 'expression'),\n                '}',\n            ]);\n        case 'Spread':\n            return concat([\n                line,\n                '{...',\n                printJS(path, print, false, false, false, 'expression'),\n                '}',\n            ]);\n        case 'ConstTag':\n            return concat([\n                '{@const ',\n                printJS(path, print, false, false, true, 'expression'),\n                '}',\n            ]);\n    }\n\n    console.error(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n\nfunction printTopLevelParts(\n    n: ASTNode,\n    options: ParserOptions,\n    path: FastPath<any>,\n    print: PrintFn,\n): Doc {\n    const parts: Record<SortOrderPart, Doc[]> = {\n        options: [],\n        scripts: [],\n        markup: [],\n        styles: [],\n    };\n\n    // scripts\n    if (n.module) {\n        n.module.type = 'Script';\n        n.module.attributes = extractAttributes(getText(n.module, options));\n        parts.scripts.push(path.call(print, 'module'));\n    }\n    if (n.instance) {\n        n.instance.type = 'Script';\n        n.instance.attributes = extractAttributes(getText(n.instance, options));\n        parts.scripts.push(path.call(print, 'instance'));\n    }\n\n    // styles\n    if (n.css) {\n        n.css.type = 'Style';\n        n.css.content.type = 'StyleProgram';\n        parts.styles.push(path.call(print, 'css'));\n    }\n\n    // markup\n    const htmlDoc = path.call(print, 'html');\n    if (htmlDoc) {\n        parts.markup.push(htmlDoc);\n    }\n    if (svelteOptionsDoc) {\n        parts.options.push(svelteOptionsDoc);\n    }\n\n    const docs = flatten(parseSortOrder(options.svelteSortOrder).map((p) => parts[p]));\n\n    // Need to reset these because they are global and could affect the next formatting run\n    ignoreNext = false;\n    ignoreRange = false;\n    svelteOptionsDoc = undefined;\n\n    // If this is invoked as an embed of markdown, remove the last hardline.\n    // The markdown parser tries this, too, but fails because it does not\n    // recurse into concats. Doing this will prevent an empty line\n    // at the end of the embedded code block.\n    if (options.parentParser === 'markdown') {\n        const lastDoc = docs[docs.length - 1];\n        trimRight([lastDoc], isLine);\n    }\n\n    return groupConcat([join(hardline, docs)]);\n}\n\nfunction printAttributeNodeValue(\n    path: FastPath<any>,\n    print: PrintFn,\n    quotes: boolean,\n    node: AttributeNode | StyleDirectiveNode,\n) {\n    const valueDocs = path.map((childPath) => childPath.call(print), 'value');\n\n    if (!quotes || !formattableAttributes.includes(node.name)) {\n        return concat(valueDocs);\n    } else {\n        return indent(groupConcat(trim(valueDocs, isLine)));\n    }\n}\n\nfunction printSvelteBlockChildren(path: FastPath, print: PrintFn, options: ParserOptions): Doc {\n    const node = path.getValue();\n    const children = node.children;\n    if (!children || children.length === 0) {\n        return '';\n    }\n\n    const whitespaceAtStartOfBlock = checkWhitespaceAtStartOfSvelteBlock(node, options);\n    const whitespaceAtEndOfBlock = checkWhitespaceAtEndOfSvelteBlock(node, options);\n    const startline =\n        whitespaceAtStartOfBlock === 'none'\n            ? ''\n            : whitespaceAtEndOfBlock === 'line' || whitespaceAtStartOfBlock === 'line'\n            ? hardline\n            : line;\n    const endline =\n        whitespaceAtEndOfBlock === 'none'\n            ? ''\n            : whitespaceAtEndOfBlock === 'line' || whitespaceAtStartOfBlock === 'line'\n            ? hardline\n            : line;\n\n    const firstChild = children[0];\n    const lastChild = children[children.length - 1];\n    if (isTextNodeStartingWithWhitespace(firstChild)) {\n        trimTextNodeLeft(firstChild);\n    }\n    if (isTextNodeEndingWithWhitespace(lastChild)) {\n        trimTextNodeRight(lastChild);\n    }\n\n    return concat([\n        indent(concat([startline, group(printChildren(path, print, options))])),\n        endline,\n    ]);\n}\n\nfunction printPre(\n    node: Parameters<typeof printRaw>[0],\n    originalText: string,\n    path: FastPath,\n    print: PrintFn,\n): Doc {\n    const result: Doc = [];\n    const length = node.children.length;\n    for (let i = 0; i < length; i++) {\n        const child = node.children[i];\n        if (child.type === 'Text') {\n            const lines = originalText.substring(child.start, child.end).split(/\\r?\\n/);\n            lines.forEach((line, j) => {\n                if (j > 0) result.push(literalline);\n                result.push(line);\n            });\n        } else {\n            result.push(path.call(print, 'children', i));\n        }\n    }\n    return concat(result);\n}\n\nfunction printChildren(path: FastPath, print: PrintFn, options: ParserOptions): Doc {\n    if (isPreTagContent(path)) {\n        return concat(path.map(print, 'children'));\n    }\n\n    const childNodes: Node[] = prepareChildren(path.getValue().children, path, print);\n    // modify original array because it's accessed later through map(print, 'children', idx)\n    path.getValue().children = childNodes;\n    if (childNodes.length === 0) {\n        return '';\n    }\n\n    const childDocs: Doc[] = [];\n    let handleWhitespaceOfPrevTextNode = false;\n\n    for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n        if (childNode.type === 'Text') {\n            handleTextChild(i, childNode);\n        } else if (isBlockElement(childNode, options)) {\n            handleBlockChild(i);\n        } else if (isInlineElement(path, options, childNode)) {\n            handleInlineChild(i);\n        } else {\n            childDocs.push(printChild(i));\n            handleWhitespaceOfPrevTextNode = false;\n        }\n    }\n\n    // If there's at least one block element and more than one node, break content\n    const forceBreakContent =\n        childNodes.length > 1 && childNodes.some((child) => isBlockElement(child, options));\n    if (forceBreakContent) {\n        childDocs.push(breakParent);\n    }\n\n    return concat(childDocs);\n\n    function printChild(idx: number): Doc {\n        return path.call(print, 'children', idx);\n    }\n\n    /**\n     * Print inline child. Hug whitespace of previous text child if there was one.\n     */\n    function handleInlineChild(idx: number) {\n        if (handleWhitespaceOfPrevTextNode) {\n            childDocs.push(groupConcat([line, printChild(idx)]));\n        } else {\n            childDocs.push(printChild(idx));\n        }\n        handleWhitespaceOfPrevTextNode = false;\n    }\n\n    /**\n     * Print block element. Add softlines around it if needed\n     * so it breaks into a separate line if children are broken up.\n     * Don't add lines at the start/end if it's the first/last child because this\n     * kind of whitespace handling is done in the parent already.\n     */\n    function handleBlockChild(idx: number) {\n        const prevChild = childNodes[idx - 1];\n        if (\n            prevChild &&\n            !isBlockElement(prevChild, options) &&\n            (prevChild.type !== 'Text' ||\n                handleWhitespaceOfPrevTextNode ||\n                !isTextNodeEndingWithWhitespace(prevChild))\n        ) {\n            childDocs.push(softline);\n        }\n\n        childDocs.push(printChild(idx));\n\n        const nextChild = childNodes[idx + 1];\n        if (\n            nextChild &&\n            (nextChild.type !== 'Text' ||\n                // Only handle text which starts with a whitespace and has text afterwards,\n                // or is empty but followed by an inline element. The latter is done\n                // so that if the children break, the inline element afterwards is in a separate line.\n                ((!isEmptyTextNode(nextChild) ||\n                    (childNodes[idx + 2] && isInlineElement(path, options, childNodes[idx + 2]))) &&\n                    !isTextNodeStartingWithLinebreak(nextChild)))\n        ) {\n            childDocs.push(softline);\n        }\n        handleWhitespaceOfPrevTextNode = false;\n    }\n\n    /**\n     * Print text child. First/last child white space handling\n     * is done in parent already. By definition of the Svelte AST,\n     * a text node always is inbetween other tags. Add hardlines\n     * if the users wants to have them inbetween.\n     * If the text is trimmed right, toggle flag telling\n     * subsequent (inline)block element to alter its printing logic\n     * to check if they need to hug or print lines themselves.\n     */\n    function handleTextChild(idx: number, childNode: TextNode) {\n        handleWhitespaceOfPrevTextNode = false;\n\n        if (idx === 0 || idx === childNodes.length - 1) {\n            childDocs.push(printChild(idx));\n            return;\n        }\n\n        const prevNode = childNodes[idx - 1];\n        const nextNode = childNodes[idx + 1];\n\n        if (\n            isTextNodeStartingWithWhitespace(childNode) &&\n            // If node is empty, go straight through to checking the right end\n            !isEmptyTextNode(childNode)\n        ) {\n            if (\n                isInlineElement(path, options, prevNode) &&\n                !isTextNodeStartingWithLinebreak(childNode)\n            ) {\n                trimTextNodeLeft(childNode);\n                const lastChildDoc = childDocs.pop()!;\n                childDocs.push(groupConcat([lastChildDoc, line]));\n            }\n\n            if (isBlockElement(prevNode, options) && !isTextNodeStartingWithLinebreak(childNode)) {\n                trimTextNodeLeft(childNode);\n            }\n        }\n\n        if (isTextNodeEndingWithWhitespace(childNode)) {\n            if (\n                isInlineElement(path, options, nextNode) &&\n                !isTextNodeEndingWithLinebreak(childNode)\n            ) {\n                handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);\n                trimTextNodeRight(childNode);\n            }\n            if (isBlockElement(nextNode, options) && !isTextNodeEndingWithLinebreak(childNode, 2)) {\n                handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);\n                trimTextNodeRight(childNode);\n            }\n        }\n\n        childDocs.push(printChild(idx));\n    }\n}\n\n/**\n * `svelte:options` is part of the html part but needs to be snipped out and handled\n * separately to reorder it as configured. The comment above it should be moved with it.\n * Do that here.\n */\nfunction prepareChildren(children: Node[], path: FastPath, print: PrintFn): Node[] {\n    let svelteOptionsComment: Doc | undefined;\n    const childrenWithoutOptions = [];\n\n    for (let idx = 0; idx < children.length; idx++) {\n        const currentChild = children[idx];\n\n        if (currentChild.type === 'Text' && getUnencodedText(currentChild) === '') {\n            continue;\n        }\n\n        if (isEmptyTextNode(currentChild) && doesEmbedStartAfterNode(currentChild, path)) {\n            continue;\n        }\n\n        if (isCommentFollowedByOptions(currentChild, idx)) {\n            svelteOptionsComment = printComment(currentChild);\n            const nextChild = children[idx + 1];\n            idx += nextChild && isEmptyTextNode(nextChild) ? 1 : 0;\n            continue;\n        }\n\n        if (currentChild.type === 'Options') {\n            printSvelteOptions(currentChild, idx, path, print);\n            continue;\n        }\n\n        childrenWithoutOptions.push(currentChild);\n    }\n\n    const mergedChildrenWithoutOptions = [];\n\n    for (let idx = 0; idx < childrenWithoutOptions.length; idx++) {\n        const currentChild = childrenWithoutOptions[idx];\n        const nextChild = childrenWithoutOptions[idx + 1];\n\n        if (currentChild.type === 'Text' && nextChild && nextChild.type === 'Text') {\n            // A tag was snipped out (f.e. svelte:options). Join text\n            currentChild.raw += nextChild.raw;\n            currentChild.data += nextChild.data;\n            idx++;\n        }\n\n        mergedChildrenWithoutOptions.push(currentChild);\n    }\n\n    return mergedChildrenWithoutOptions;\n\n    function printSvelteOptions(\n        node: OptionsNode,\n        idx: number,\n        path: FastPath,\n        print: PrintFn,\n    ): void {\n        svelteOptionsDoc = groupConcat([\n            groupConcat([\n                '<',\n                node.name,\n\n                indent(groupConcat(path.map(print, 'children', idx, 'attributes'))),\n\n                ' />',\n            ]),\n            hardline,\n        ]);\n        if (svelteOptionsComment) {\n            svelteOptionsDoc = groupConcat([svelteOptionsComment, hardline, svelteOptionsDoc]);\n        }\n    }\n\n    function isCommentFollowedByOptions(node: Node, idx: number): node is CommentNode {\n        if (node.type !== 'Comment' || isIgnoreEndDirective(node) || isIgnoreStartDirective(node)) {\n            return false;\n        }\n\n        const nextChild = children[idx + 1];\n        if (nextChild) {\n            if (isEmptyTextNode(nextChild)) {\n                const afterNext = children[idx + 2];\n                return afterNext && afterNext.type === 'Options';\n            }\n            return nextChild.type === 'Options';\n        }\n\n        return false;\n    }\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, two of those should be kept.\n */\nfunction splitTextToDocs(node: TextNode): Doc[] {\n    const text = getUnencodedText(node);\n    let docs: Doc[] = text.split(/[\\t\\n\\f\\r ]+/);\n\n    docs = join(line, docs).parts.filter((s) => s !== '');\n\n    if (startsWithLinebreak(text)) {\n        docs[0] = hardline;\n    }\n    if (startsWithLinebreak(text, 2)) {\n        docs = [hardline, ...docs];\n    }\n\n    if (endsWithLinebreak(text)) {\n        docs[docs.length - 1] = hardline;\n    }\n    if (endsWithLinebreak(text, 2)) {\n        docs = [...docs, hardline];\n    }\n\n    return docs;\n}\n\nfunction printSvelteBlockJS(path: FastPath, print: PrintFn, name: string) {\n    return printJS(path, print, false, true, false, name);\n}\n\nfunction printJS(\n    path: FastPath,\n    print: PrintFn,\n    forceSingleQuote: boolean,\n    forceSingleLine: boolean,\n    removeParentheses: boolean,\n    name: string,\n) {\n    path.getValue()[name].isJS = true;\n    path.getValue()[name].forceSingleQuote = forceSingleQuote;\n    path.getValue()[name].forceSingleLine = forceSingleLine;\n    path.getValue()[name].removeParentheses = removeParentheses;\n    return path.call(print, name);\n}\n\nfunction expandNode(node: any, parent?: any): string {\n    if (node === null) {\n        return '';\n    }\n\n    if (typeof node === 'string') {\n        // pre-v3.20 AST\n        return ' ' + node;\n    }\n\n    switch (node.type) {\n        case 'ArrayExpression':\n        case 'ArrayPattern':\n            return ' [' + node.elements.map(expandNode).join(',').slice(1) + ']';\n        case 'AssignmentPattern':\n            return expandNode(node.left) + ' =' + expandNode(node.right);\n        case 'Identifier':\n            return ' ' + node.name;\n        case 'Literal':\n            return ' ' + node.raw;\n        case 'ObjectExpression':\n            return ' {' + node.properties.map((p: any) => expandNode(p, node)).join(',') + ' }';\n        case 'ObjectPattern':\n            return ' {' + node.properties.map(expandNode).join(',') + ' }';\n        case 'Property':\n            if (node.value.type === 'ObjectPattern' || node.value.type === 'ArrayPattern') {\n                return ' ' + node.key.name + ':' + expandNode(node.value);\n            } else if (\n                (node.value.type === 'Identifier' && node.key.name !== node.value.name) ||\n                (parent && parent.type === 'ObjectExpression')\n            ) {\n                return expandNode(node.key) + ':' + expandNode(node.value);\n            } else {\n                return expandNode(node.value);\n            }\n        case 'RestElement':\n            return ' ...' + node.argument.name;\n    }\n\n    console.error(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n\nfunction printComment(node: CommentNode) {\n    let text = node.data;\n\n    if (hasSnippedContent(text)) {\n        text = unsnipContent(text);\n    }\n\n    return groupConcat(['<!--', text, '-->']);\n}\n","import { Doc, doc, FastPath, ParserOptions } from 'prettier';\nimport { getText } from './lib/getText';\nimport { snippedTagContentAttribute } from './lib/snipTagContent';\nimport { PrintFn } from './print';\nimport { isLine, removeParentheses, trimRight } from './print/doc-helpers';\nimport {\n    getAttributeTextValue,\n    getLeadingComment,\n    isIgnoreDirective,\n    isNodeSupportedLanguage,\n    isPugTemplate,\n    isTypeScript,\n    printRaw,\n} from './print/node-helpers';\nimport { ElementNode, Node } from './print/nodes';\n\nconst {\n    builders: { concat, hardline, group, indent, literalline },\n    utils: { removeLines },\n} = doc;\n\nexport function embed(\n    path: FastPath,\n    print: PrintFn,\n    textToDoc: (text: string, options: object) => Doc,\n    options: ParserOptions,\n): Doc | null {\n    const node: Node = path.getNode();\n\n    if (node.isJS) {\n        try {\n            const embeddedOptions: any = {\n                parser: expressionParser,\n            };\n            if (node.forceSingleQuote) {\n                embeddedOptions.singleQuote = true;\n            }\n\n            let docs = textToDoc(forceIntoExpression(getText(node, options)), embeddedOptions);\n            if (node.forceSingleLine) {\n                docs = removeLines(docs);\n            }\n            if (node.removeParentheses) {\n                docs = removeParentheses(docs);\n            }\n            return docs;\n        } catch (e) {\n            return getText(node, options);\n        }\n    }\n\n    const embedType = (\n        tag: 'script' | 'style' | 'template',\n        parser: 'typescript' | 'babel-ts' | 'css' | 'pug',\n        isTopLevel: boolean,\n    ) =>\n        embedTag(\n            tag,\n            options.originalText,\n            path,\n            (content) => formatBodyContent(content, parser, textToDoc, options),\n            print,\n            isTopLevel,\n            options,\n        );\n\n    const embedScript = (isTopLevel: boolean) =>\n        embedType(\n            'script',\n            // Use babel-ts as fallback because the absence does not mean the content is not TS,\n            // the user could have set the default language. babel-ts will format things a little\n            // bit different though, especially preserving parentheses around dot notation which\n            // fixes https://github.com/sveltejs/prettier-plugin-svelte/issues/218\n            isTypeScript(node) ? 'typescript' : 'babel-ts',\n            isTopLevel,\n        );\n    const embedStyle = (isTopLevel: boolean) => embedType('style', 'css', isTopLevel);\n    const embedPug = () => embedType('template', 'pug', false);\n\n    switch (node.type) {\n        case 'Script':\n            return embedScript(true);\n        case 'Style':\n            return embedStyle(true);\n        case 'Element': {\n            if (node.name === 'script') {\n                return embedScript(false);\n            } else if (node.name === 'style') {\n                return embedStyle(false);\n            } else if (isPugTemplate(node)) {\n                return embedPug();\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction forceIntoExpression(statement: string) {\n    // note the trailing newline: if the statement ends in a // comment,\n    // we can't add the closing bracket right afterwards\n    return `(${statement}\\n)`;\n}\n\nfunction expressionParser(text: string, parsers: any, options: any) {\n    const ast = parsers.babel(text, parsers, options);\n\n    return { ...ast, program: ast.program.body[0].expression };\n}\n\nfunction preformattedBody(str: string): Doc {\n    const firstNewline = /^[\\t\\f\\r ]*\\n/;\n    const lastNewline = /\\n[\\t\\f\\r ]*$/;\n\n    // If we do not start with a new line prettier might try to break the opening tag\n    // to keep it together with the string. Use a literal line to skip indentation.\n    return concat([literalline, str.replace(firstNewline, '').replace(lastNewline, ''), hardline]);\n}\n\nfunction getSnippedContent(node: Node) {\n    const encodedContent = getAttributeTextValue(snippedTagContentAttribute, node);\n\n    if (encodedContent) {\n        return Buffer.from(encodedContent, 'base64').toString('utf-8');\n    } else {\n        return '';\n    }\n}\n\nfunction formatBodyContent(\n    content: string,\n    parser: 'typescript' | 'babel-ts' | 'css' | 'pug',\n    textToDoc: (text: string, options: object) => Doc,\n    options: ParserOptions & { pugTabWidth?: number },\n) {\n    try {\n        const body = textToDoc(content, { parser });\n\n        if (parser === 'pug' && typeof body === 'string') {\n            // Pug returns no docs but a final string.\n            // Therefore prepend the line offsets\n            const whitespace = options.useTabs\n                ? '\\t'\n                : ' '.repeat(\n                      options.pugTabWidth && options.pugTabWidth > 0\n                          ? options.pugTabWidth\n                          : options.tabWidth,\n                  );\n            const pugBody = body\n                .split('\\n')\n                .map((line) => (line ? whitespace + line : line))\n                .join('\\n');\n            return concat([hardline, pugBody]);\n        }\n\n        const indentIfDesired = (doc: Doc) =>\n            options.svelteIndentScriptAndStyle ? indent(doc) : doc;\n        trimRight([body], isLine);\n        return concat([indentIfDesired(concat([hardline, body])), hardline]);\n    } catch (error) {\n        if (process.env.PRETTIER_DEBUG) {\n            throw error;\n        }\n\n        // We will wind up here if there is a syntax error in the embedded code. If we throw an error,\n        // prettier will try to print the node with the printer. That will fail with a hard-to-interpret\n        // error message (e.g. \"Unsupported node type\", referring to `<script>`).\n        // Therefore, fall back on just returning the unformatted text.\n        console.error(error);\n\n        return preformattedBody(content);\n    }\n}\n\nfunction embedTag(\n    tag: 'script' | 'style' | 'template',\n    text: string,\n    path: FastPath,\n    formatBodyContent: (content: string) => Doc,\n    print: PrintFn,\n    isTopLevel: boolean,\n    options: ParserOptions,\n) {\n    const node: Node = path.getNode();\n    const content =\n        tag === 'template' ? printRaw(node as ElementNode, text) : getSnippedContent(node);\n    const previousComment = getLeadingComment(path);\n\n    const canFormat =\n        isNodeSupportedLanguage(node) &&\n        !isIgnoreDirective(previousComment) &&\n        (tag !== 'template' ||\n            options.plugins.some(\n                (plugin) => typeof plugin !== 'string' && plugin.parsers && plugin.parsers.pug,\n            ));\n    const body: Doc = canFormat\n        ? content.trim() !== ''\n            ? formatBodyContent(content)\n            : content === ''\n            ? ''\n            : hardline\n        : preformattedBody(content);\n\n    const attributes = concat(\n        path.map(\n            (childPath) =>\n                childPath.getNode().name !== snippedTagContentAttribute\n                    ? childPath.call(print)\n                    : '',\n            'attributes',\n        ),\n    );\n\n    let result: Doc = group(\n        concat(['<', tag, indent(group(attributes)), '>', body, '</', tag, '>']),\n    );\n\n    if (isTopLevel) {\n        // top level embedded nodes have been moved from their normal position in the\n        // node tree. if there is a comment referring to it, it must be recreated at\n        // the new position.\n        if (previousComment) {\n            result = concat(['<!--', previousComment.data, '-->', hardline, result, hardline]);\n        } else {\n            result = concat([result, hardline]);\n        }\n    }\n\n    return result;\n}\n","import { SupportLanguage, Parser, Printer } from 'prettier';\nimport { print } from './print';\nimport { ASTNode } from './print/nodes';\nimport { embed } from './embed';\nimport { snipScriptAndStyleTagContent } from './lib/snipTagContent';\n\nfunction locStart(node: any) {\n    return node.start;\n}\n\nfunction locEnd(node: any) {\n    return node.end;\n}\n\nexport const languages: Partial<SupportLanguage>[] = [\n    {\n        name: 'svelte',\n        parsers: ['svelte'],\n        extensions: ['.svelte'],\n        vscodeLanguageIds: ['svelte'],\n    },\n];\n\nexport const parsers: Record<string, Parser> = {\n    svelte: {\n        parse: (text) => {\n            try {\n                return <ASTNode>{ ...require(`svelte/compiler`).parse(text), __isRoot: true };\n            } catch (err: any) {\n                if (err.start != null && err.end != null) {\n                    // Prettier expects error objects to have loc.start and loc.end fields.\n                    // Svelte uses start and end directly on the error.\n                    err.loc = {\n                        start: err.start,\n                        end: err.end,\n                    };\n                }\n\n                throw err;\n            }\n        },\n        preprocess: (text, options) => {\n            text = snipScriptAndStyleTagContent(text);\n            text = text.trim();\n            // Prettier sets the preprocessed text as the originalText in case\n            // the Svelte formatter is called directly. In case it's called\n            // as an embedded parser (for example when there's a Svelte code block\n            // inside markdown), the originalText is not updated after preprocessing.\n            // Therefore we do it ourselves here.\n            options.originalText = text;\n            return text;\n        },\n        locStart,\n        locEnd,\n        astFormat: 'svelte-ast',\n    },\n};\n\nexport const printers: Record<string, Printer> = {\n    'svelte-ast': {\n        print,\n        embed,\n    },\n};\n\nexport { options } from './options';\n"],"names":["doc","concat","hardline","group","indent","literalline"],"mappings":"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"}