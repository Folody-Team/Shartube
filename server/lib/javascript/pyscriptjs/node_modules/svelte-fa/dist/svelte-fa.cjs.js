'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var internal = require('svelte/internal');

const parseNumber = parseFloat;

function joinCss(obj, separator = ';') {
  let texts;
  if (Array.isArray(obj)) {
    texts = obj.filter((text) => text);
  } else {
    texts = [];
    for (const prop in obj) {
      if (obj[prop]) {
        texts.push(`${prop}:${obj[prop]}`);
      }
    }
  }
  return texts.join(separator);
}

function getStyles(style, size, pull, fw) {
  let float;
  let width;
  const height = '1em';
  let lineHeight;
  let fontSize;
  let textAlign;
  let verticalAlign = '-.125em';
  const overflow = 'visible';

  if (fw) {
    textAlign = 'center';
    width = '1.25em';
  }

  if (pull) {
    float = pull;
  }

  if (size) {
    if (size == 'lg') {
      fontSize = '1.33333em';
      lineHeight = '.75em';
      verticalAlign = '-.225em';
    } else if (size == 'xs') {
      fontSize = '.75em';
    } else if (size == 'sm') {
      fontSize = '.875em';
    } else {
      fontSize = size.replace('x', 'em');
    }
  }

  return joinCss([
    joinCss({
      float,
      width,
      height,
      'line-height': lineHeight,
      'font-size': fontSize,
      'text-align': textAlign,
      'vertical-align': verticalAlign,
      'transform-origin': 'center',
      overflow,
    }),
    style,
  ]);
}

function getTransform(
  scale,
  translateX,
  translateY,
  rotate,
  flip,
  translateTimes = 1,
  translateUnit = '',
  rotateUnit = '',
) {
  let flipX = 1;
  let flipY = 1;

  if (flip) {
    if (flip == 'horizontal') {
      flipX = -1;
    } else if (flip == 'vertical') {
      flipY = -1;
    } else {
      flipX = flipY = -1;
    }
  }

  return joinCss(
    [
      `translate(${parseNumber(translateX) * translateTimes}${translateUnit},${parseNumber(translateY) * translateTimes}${translateUnit})`,
      `scale(${flipX * parseNumber(scale)},${flipY * parseNumber(scale)})`,
      rotate && `rotate(${rotate}${rotateUnit})`,
    ],
    ' ',
  );
}

/* src\fa.svelte generated by Svelte v3.16.7 */

function add_css$1() {
	var style = internal.element("style");
	style.id = "svelte-1cj2gr0-style";
	style.textContent = ".spin.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 2s 0s infinite linear}.pulse.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 1s infinite steps(8)}@keyframes svelte-1cj2gr0-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
	internal.append(document.head, style);
}

// (78:0) {#if i[4]}
function create_if_block(ctx) {
	let svg;
	let g1;
	let g0;
	let g1_transform_value;
	let g1_transform_origin_value;
	let svg_class_value;
	let svg_viewBox_value;

	function select_block_type(ctx, dirty) {
		if (typeof /*i*/ ctx[7][4] == "string") return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			svg = internal.svg_element("svg");
			g1 = internal.svg_element("g");
			g0 = internal.svg_element("g");
			if_block.c();
			internal.attr(g0, "transform", /*transform*/ ctx[10]);
			internal.attr(g1, "transform", g1_transform_value = `translate(${/*i*/ ctx[7][0] / 2} ${/*i*/ ctx[7][1] / 2})`);
			internal.attr(g1, "transform-origin", g1_transform_origin_value = `${/*i*/ ctx[7][0] / 4} 0`);
			internal.attr(svg, "id", /*id*/ ctx[0]);
			internal.attr(svg, "class", svg_class_value = "" + (internal.null_to_empty(/*c*/ ctx[8]) + " svelte-1cj2gr0"));
			internal.attr(svg, "style", /*s*/ ctx[9]);
			internal.attr(svg, "viewBox", svg_viewBox_value = `0 0 ${/*i*/ ctx[7][0]} ${/*i*/ ctx[7][1]}`);
			internal.attr(svg, "aria-hidden", "true");
			internal.attr(svg, "role", "img");
			internal.attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			internal.insert(target, svg, anchor);
			internal.append(svg, g1);
			internal.append(g1, g0);
			if_block.m(g0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(g0, null);
				}
			}

			if (dirty & /*transform*/ 1024) {
				internal.attr(g0, "transform", /*transform*/ ctx[10]);
			}

			if (dirty & /*i*/ 128 && g1_transform_value !== (g1_transform_value = `translate(${/*i*/ ctx[7][0] / 2} ${/*i*/ ctx[7][1] / 2})`)) {
				internal.attr(g1, "transform", g1_transform_value);
			}

			if (dirty & /*i*/ 128 && g1_transform_origin_value !== (g1_transform_origin_value = `${/*i*/ ctx[7][0] / 4} 0`)) {
				internal.attr(g1, "transform-origin", g1_transform_origin_value);
			}

			if (dirty & /*id*/ 1) {
				internal.attr(svg, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*c*/ 256 && svg_class_value !== (svg_class_value = "" + (internal.null_to_empty(/*c*/ ctx[8]) + " svelte-1cj2gr0"))) {
				internal.attr(svg, "class", svg_class_value);
			}

			if (dirty & /*s*/ 512) {
				internal.attr(svg, "style", /*s*/ ctx[9]);
			}

			if (dirty & /*i*/ 128 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*i*/ ctx[7][0]} ${/*i*/ ctx[7][1]}`)) {
				internal.attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(svg);
			if_block.d();
		}
	};
}

// (99:8) {:else}
function create_else_block(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path0_fill_opacity_value;
	let path0_transform_value;
	let path1;
	let path1_d_value;
	let path1_fill_value;
	let path1_fill_opacity_value;
	let path1_transform_value;

	return {
		c() {
			path0 = internal.svg_element("path");
			path1 = internal.svg_element("path");
			internal.attr(path0, "d", path0_d_value = /*i*/ ctx[7][4][0]);
			internal.attr(path0, "fill", path0_fill_value = /*secondaryColor*/ ctx[3] || /*color*/ ctx[1] || "currentColor");

			internal.attr(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*primaryOpacity*/ ctx[4]
			: /*secondaryOpacity*/ ctx[5]);

			internal.attr(path0, "transform", path0_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`);
			internal.attr(path1, "d", path1_d_value = /*i*/ ctx[7][4][1]);
			internal.attr(path1, "fill", path1_fill_value = /*primaryColor*/ ctx[2] || /*color*/ ctx[1] || "currentColor");

			internal.attr(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*secondaryOpacity*/ ctx[5]
			: /*primaryOpacity*/ ctx[4]);

			internal.attr(path1, "transform", path1_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`);
		},
		m(target, anchor) {
			internal.insert(target, path0, anchor);
			internal.insert(target, path1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 128 && path0_d_value !== (path0_d_value = /*i*/ ctx[7][4][0])) {
				internal.attr(path0, "d", path0_d_value);
			}

			if (dirty & /*secondaryColor, color*/ 10 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/ ctx[3] || /*color*/ ctx[1] || "currentColor")) {
				internal.attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/ 112 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*primaryOpacity*/ ctx[4]
			: /*secondaryOpacity*/ ctx[5])) {
				internal.attr(path0, "fill-opacity", path0_fill_opacity_value);
			}

			if (dirty & /*i*/ 128 && path0_transform_value !== (path0_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`)) {
				internal.attr(path0, "transform", path0_transform_value);
			}

			if (dirty & /*i*/ 128 && path1_d_value !== (path1_d_value = /*i*/ ctx[7][4][1])) {
				internal.attr(path1, "d", path1_d_value);
			}

			if (dirty & /*primaryColor, color*/ 6 && path1_fill_value !== (path1_fill_value = /*primaryColor*/ ctx[2] || /*color*/ ctx[1] || "currentColor")) {
				internal.attr(path1, "fill", path1_fill_value);
			}

			if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/ 112 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*secondaryOpacity*/ ctx[5]
			: /*primaryOpacity*/ ctx[4])) {
				internal.attr(path1, "fill-opacity", path1_fill_opacity_value);
			}

			if (dirty & /*i*/ 128 && path1_transform_value !== (path1_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`)) {
				internal.attr(path1, "transform", path1_transform_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(path0);
			if (detaching) internal.detach(path1);
		}
	};
}

// (93:8) {#if typeof i[4] == 'string'}
function create_if_block_1(ctx) {
	let path;
	let path_d_value;
	let path_fill_value;
	let path_transform_value;

	return {
		c() {
			path = internal.svg_element("path");
			internal.attr(path, "d", path_d_value = /*i*/ ctx[7][4]);
			internal.attr(path, "fill", path_fill_value = /*color*/ ctx[1] || /*primaryColor*/ ctx[2] || "currentColor");
			internal.attr(path, "transform", path_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`);
		},
		m(target, anchor) {
			internal.insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 128 && path_d_value !== (path_d_value = /*i*/ ctx[7][4])) {
				internal.attr(path, "d", path_d_value);
			}

			if (dirty & /*color, primaryColor*/ 6 && path_fill_value !== (path_fill_value = /*color*/ ctx[1] || /*primaryColor*/ ctx[2] || "currentColor")) {
				internal.attr(path, "fill", path_fill_value);
			}

			if (dirty & /*i*/ 128 && path_transform_value !== (path_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`)) {
				internal.attr(path, "transform", path_transform_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(path);
		}
	};
}

function create_fragment$2(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[7][4] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = internal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			internal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*i*/ ctx[7][4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: internal.noop,
		o: internal.noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) internal.detach(if_block_anchor);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { icon } = $$props;
	let { size = "" } = $$props;
	let { color = "" } = $$props;
	let { fw = false } = $$props;
	let { pull = "" } = $$props;
	let { scale = 1 } = $$props;
	let { translateX = 0 } = $$props;
	let { translateY = 0 } = $$props;
	let { rotate = "" } = $$props;
	let { flip = false } = $$props;
	let { spin = false } = $$props;
	let { pulse = false } = $$props;
	let { primaryColor = "" } = $$props;
	let { secondaryColor = "" } = $$props;
	let { primaryOpacity = 1 } = $$props;
	let { secondaryOpacity = 0.4 } = $$props;
	let { swapOpacity = false } = $$props;
	let i;
	let c;
	let s;
	let transform;

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(11, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("style" in $$props) $$invalidate(12, style = $$props.style);
		if ("icon" in $$props) $$invalidate(13, icon = $$props.icon);
		if ("size" in $$props) $$invalidate(14, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("fw" in $$props) $$invalidate(15, fw = $$props.fw);
		if ("pull" in $$props) $$invalidate(16, pull = $$props.pull);
		if ("scale" in $$props) $$invalidate(17, scale = $$props.scale);
		if ("translateX" in $$props) $$invalidate(18, translateX = $$props.translateX);
		if ("translateY" in $$props) $$invalidate(19, translateY = $$props.translateY);
		if ("rotate" in $$props) $$invalidate(20, rotate = $$props.rotate);
		if ("flip" in $$props) $$invalidate(21, flip = $$props.flip);
		if ("spin" in $$props) $$invalidate(22, spin = $$props.spin);
		if ("pulse" in $$props) $$invalidate(23, pulse = $$props.pulse);
		if ("primaryColor" in $$props) $$invalidate(2, primaryColor = $$props.primaryColor);
		if ("secondaryColor" in $$props) $$invalidate(3, secondaryColor = $$props.secondaryColor);
		if ("primaryOpacity" in $$props) $$invalidate(4, primaryOpacity = $$props.primaryOpacity);
		if ("secondaryOpacity" in $$props) $$invalidate(5, secondaryOpacity = $$props.secondaryOpacity);
		if ("swapOpacity" in $$props) $$invalidate(6, swapOpacity = $$props.swapOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*icon*/ 8192) {
			$$invalidate(7, i = icon && icon.icon || [0, 0, "", [], ""]);
		}

		if ($$self.$$.dirty & /*clazz, spin, pulse*/ 12584960) {
			$$invalidate(8, c = joinCss([clazz, "svelte-fa", spin && "spin", pulse && "pulse"], " "));
		}

		if ($$self.$$.dirty & /*style, size, pull, fw*/ 118784) {
			$$invalidate(9, s = getStyles(style, size, pull, fw));
		}

		if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/ 4063232) {
			$$invalidate(10, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
		}
	};

	return [
		id,
		color,
		primaryColor,
		secondaryColor,
		primaryOpacity,
		secondaryOpacity,
		swapOpacity,
		i,
		c,
		s,
		transform,
		clazz,
		style,
		icon,
		size,
		fw,
		pull,
		scale,
		translateX,
		translateY,
		rotate,
		flip,
		spin,
		pulse
	];
}

class Fa extends internal.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1cj2gr0-style")) add_css$1();

		internal.init(this, options, instance$2, create_fragment$2, internal.safe_not_equal, {
			class: 11,
			id: 0,
			style: 12,
			icon: 13,
			size: 14,
			color: 1,
			fw: 15,
			pull: 16,
			scale: 17,
			translateX: 18,
			translateY: 19,
			rotate: 20,
			flip: 21,
			spin: 22,
			pulse: 23,
			primaryColor: 2,
			secondaryColor: 3,
			primaryOpacity: 4,
			secondaryOpacity: 5,
			swapOpacity: 6
		});
	}
}

/* src\fa-layers.svelte generated by Svelte v3.16.7 */

function add_css() {
	var style = internal.element("style");
	style.id = "svelte-66hu08-style";
	style.textContent = ".svelte-fa-layers.svelte-66hu08{display:inline-block;position:relative}.svelte-fa-layers.svelte-66hu08 .svelte-fa{position:absolute;bottom:0;left:0;right:0;top:0;margin:auto;text-align:center}.svelte-fa-layers.svelte-66hu08 .svelte-fa-layers-text{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.svelte-fa-layers.svelte-66hu08 .svelte-fa-layers-text span{display:inline-block}";
	internal.append(document.head, style);
}

function create_fragment$1(ctx) {
	let span;
	let span_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = internal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			span = internal.element("span");
			if (default_slot) default_slot.c();
			internal.attr(span, "id", /*id*/ ctx[0]);
			internal.attr(span, "class", span_class_value = "" + (internal.null_to_empty(/*c*/ ctx[1]) + " svelte-66hu08"));
			internal.attr(span, "style", /*s*/ ctx[2]);
		},
		m(target, anchor) {
			internal.insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 128) {
				default_slot.p(internal.get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), internal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				internal.attr(span, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*c*/ 2 && span_class_value !== (span_class_value = "" + (internal.null_to_empty(/*c*/ ctx[1]) + " svelte-66hu08"))) {
				internal.attr(span, "class", span_class_value);
			}

			if (!current || dirty & /*s*/ 4) {
				internal.attr(span, "style", /*s*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			internal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			internal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) internal.detach(span);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { size = "" } = $$props;
	let { pull = "" } = $$props;
	let c;
	let s;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(3, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("style" in $$props) $$invalidate(4, style = $$props.style);
		if ("size" in $$props) $$invalidate(5, size = $$props.size);
		if ("pull" in $$props) $$invalidate(6, pull = $$props.pull);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*clazz*/ 8) {
			$$invalidate(1, c = joinCss([clazz, "svelte-fa-layers"], " "));
		}

		if ($$self.$$.dirty & /*style, size, pull*/ 112) {
			$$invalidate(2, s = getStyles(style, size, pull, true));
		}
	};

	return [id, c, s, clazz, style, size, pull, $$scope, $$slots];
}

class Fa_layers extends internal.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-66hu08-style")) add_css();

		internal.init(this, options, instance$1, create_fragment$1, internal.safe_not_equal, {
			class: 3,
			id: 0,
			style: 4,
			size: 5,
			pull: 6
		});
	}
}

/* src\fa-layers-text.svelte generated by Svelte v3.16.7 */

function create_fragment(ctx) {
	let span1;
	let span0;
	let current;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = internal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			span1 = internal.element("span");
			span0 = internal.element("span");
			if (default_slot) default_slot.c();
			internal.attr(span0, "style", /*s*/ ctx[2]);
			internal.attr(span1, "id", /*id*/ ctx[0]);
			internal.attr(span1, "class", /*c*/ ctx[1]);
		},
		m(target, anchor) {
			internal.insert(target, span1, anchor);
			internal.append(span1, span0);

			if (default_slot) {
				default_slot.m(span0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 4096) {
				default_slot.p(internal.get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], null), internal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null));
			}

			if (!current || dirty & /*s*/ 4) {
				internal.attr(span0, "style", /*s*/ ctx[2]);
			}

			if (!current || dirty & /*id*/ 1) {
				internal.attr(span1, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*c*/ 2) {
				internal.attr(span1, "class", /*c*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			internal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			internal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) internal.detach(span1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { size = "" } = $$props;
	let { color = "" } = $$props;
	let { scale = 1 } = $$props;
	let { translateX = 0 } = $$props;
	let { translateY = 0 } = $$props;
	let { rotate = "" } = $$props;
	let { flip = false } = $$props;
	let c;
	let s;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(3, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("style" in $$props) $$invalidate(4, style = $$props.style);
		if ("size" in $$props) $$invalidate(5, size = $$props.size);
		if ("color" in $$props) $$invalidate(6, color = $$props.color);
		if ("scale" in $$props) $$invalidate(7, scale = $$props.scale);
		if ("translateX" in $$props) $$invalidate(8, translateX = $$props.translateX);
		if ("translateY" in $$props) $$invalidate(9, translateY = $$props.translateY);
		if ("rotate" in $$props) $$invalidate(10, rotate = $$props.rotate);
		if ("flip" in $$props) $$invalidate(11, flip = $$props.flip);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*clazz*/ 8) {
			$$invalidate(1, c = joinCss([clazz, "svelte-fa-layers-text"], " "));
		}

		if ($$self.$$.dirty & /*color, scale, translateX, translateY, rotate, flip, style, size*/ 4080) {
			$$invalidate(2, s = getStyles(
				joinCss([
					joinCss({
						color,
						display: "inline-block",
						height: "auto",
						transform: getTransform(scale, translateX, translateY, rotate, flip, undefined, "em", "deg")
					}),
					style
				]),
				size
			));
		}
	};

	return [
		id,
		c,
		s,
		clazz,
		style,
		size,
		color,
		scale,
		translateX,
		translateY,
		rotate,
		flip,
		$$scope,
		$$slots
	];
}

class Fa_layers_text extends internal.SvelteComponent {
	constructor(options) {
		super();

		internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {
			class: 3,
			id: 0,
			style: 4,
			size: 5,
			color: 6,
			scale: 7,
			translateX: 8,
			translateY: 9,
			rotate: 10,
			flip: 11
		});
	}
}

exports.Fa = Fa;
exports.FaLayers = Fa_layers;
exports.FaLayersText = Fa_layers_text;
exports.default = Fa;
