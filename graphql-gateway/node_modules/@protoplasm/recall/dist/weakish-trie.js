"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StrongTrie = exports.Trie = void 0;
class Trie {
    constructor(root) {
        this.root = root;
    }
    static weakish() {
        return new Trie(WeakishNode.empty());
    }
    static strong() {
        return new StrongTrie();
    }
    entry(...key) {
        let node = this.root;
        const len = key.length;
        for (let i = 0; i !== len; ++i) {
            const part = key[i];
            const next = node.child(part);
            if (!next)
                return new Vacant(node, key, i);
            node = next;
        }
        if (node.isEmpty())
            return new Vacant(node, key, len);
        return new Occupied(node, key);
    }
}
exports.Trie = Trie;
class StrongTrie extends Trie {
    entries() { return this.root.entries(); }
    constructor() { super(StrongNode.empty()); }
}
exports.StrongTrie = StrongTrie;
const EMPTY = Symbol('is empty');
class WeakishNode {
    constructor() {
        this.data = EMPTY;
    }
    static empty() {
        return new this();
    }
    child(keyPart) {
        var _a;
        return (_a = this[this.getRefType(keyPart)]) === null || _a === void 0 ? void 0 : _a.get(keyPart);
    }
    isEmpty() {
        return this.data === EMPTY;
    }
    hasData() {
        return this.data !== EMPTY;
    }
    findOrCreateChild(keyPart) {
        const type = this.getRefType(keyPart);
        const map = this.getOrCreateMap(type);
        const existing = map.get(keyPart);
        if (existing)
            return existing;
        const created = WeakishNode.empty();
        map.set(keyPart, created);
        return created;
    }
    getOrCreateMap(type) {
        if (type === 'strong')
            return this.strong ? this.strong : (this.strong = new Map);
        else
            return this.weak ? this.weak : (this.weak = new WeakMap);
    }
    getRefType(o) {
        if (o == null)
            return 'strong';
        if (typeof o === 'object')
            return 'weak';
        return 'strong';
    }
    *entries(...keyPrefix) {
        if (this.hasData())
            yield [keyPrefix, this.data];
        if (!this.strong)
            return;
        for (const [k, child] of this.strong.entries())
            if (child.entries)
                yield* child.entries(...keyPrefix, k);
    }
}
class StrongNode extends WeakishNode {
    getRefType(_) { return 'strong'; }
}
class Vacant {
    constructor(node, key, startIndex) {
        this.node = node;
        this.key = key;
        this.startIndex = startIndex;
        this.exists = false;
        this.node = node;
    }
    get value() { return undefined; }
    set(value) {
        let node = this.node;
        const { key, startIndex } = this;
        const len = key.length;
        for (let i = startIndex; i !== len; ++i) {
            const part = key[i];
            node = node.findOrCreateChild(part);
        }
        return node.data = value;
    }
    orSet(value) {
        return this.set(value);
    }
    orSetWith(create) {
        return this.set(create(this.key));
    }
    *entries() {
        if (this.node.entries && this.startIndex === this.key.length) {
            yield* this.node.entries(...this.key);
        }
    }
}
class Occupied {
    constructor(node, key) {
        this.node = node;
        this.key = key;
        this.exists = true;
    }
    get value() { return this.node.data; }
    set(value) {
        return this.node.data = value;
    }
    orSet(_) {
        return this.node.data;
    }
    orSetWith(_) {
        return this.node.data;
    }
    *entries() {
        if (this.node.entries)
            yield* this.node.entries(...this.key);
    }
}
exports.default = Trie;
//# sourceMappingURL=weakish-trie.js.map