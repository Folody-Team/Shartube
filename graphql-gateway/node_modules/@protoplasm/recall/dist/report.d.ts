export interface IResult<D = any> {
    isReturn(): this is Return<D>;
    isThrow(): this is Throw;
    unwrap(printReportedError?: (err: Error) => void): D;
    readonly log: Log;
    errors(): Iterable<Error>;
}
export interface Log extends Iterable<any> {
    readonly messages?: ReadonlyArray<any>;
    filter<S = any>(pred?: (e: any) => e is S): Iterable<S>;
}
export interface Return<D> extends IResult<D> {
    exit: 'return';
    data: D;
}
export interface Throw extends IResult {
    exit: 'throw';
    error: any;
}
export declare type Result<D> = Return<D> | Throw;
export declare type Fn = (...args: any[]) => any;
export declare class Exit<D = any> implements IResult<D> {
    readonly exit: 'return' | 'throw';
    readonly log: Log;
    readonly data: any;
    isThrow(): this is Throw;
    isReturn(): this is Return<D>;
    unwrap(printReportedError?: (err: Error) => void): D;
    get error(): any;
    errors(): Iterable<Error>;
    constructor(exit: 'return' | 'throw', log: Log, data: any);
}
export declare class Report implements Log {
    messages?: any[];
    [Symbol.iterator](): Iterator<any>;
    filter<S>(pred?: (e: any) => e is S): Iterable<S>;
    report(msg: any): void;
}
export declare function report<T>(msg: T): T;
export declare function execute<F extends Fn, T extends ThisParameterType<F>, A extends Parameters<F>>(fn: F, self: T, args: A): Result<ReturnType<F>>;
export declare function getResult<F extends (this: undefined) => any>(fn: F): Result<ReturnType<F>>;
//# sourceMappingURL=report.d.ts.map