export declare class Trie<K extends any[], V> {
    protected readonly root: Node<V>;
    static weakish<K extends any[], V>(): Trie<K, V>;
    static strong<K extends any[], V>(): StrongTrie<K, V>;
    constructor(root: Node<V>);
    entry(...key: K): Occupied<V> | Vacant<V>;
}
export declare class StrongTrie<K extends any[], V> extends Trie<K, V> {
    entries(): Iterable<[any[], any]>;
    constructor();
}
interface INode<V> {
    data: V | Empty;
    isEmpty(): this is EmptyNode;
    hasData(): this is FullNode<V>;
    child(keyPart: any): Node<V> | undefined;
    findOrCreateChild(keyPart: any): Node<V>;
    entries?(...keyPrefix: any[]): Iterable<[any[], V]>;
}
interface FullNode<V> extends INode<V> {
    data: V;
}
interface EmptyNode extends INode<any> {
    data: Empty;
}
declare type Node<V> = FullNode<V> | EmptyNode;
declare const EMPTY: unique symbol;
declare type Empty = typeof EMPTY;
declare class Vacant<V> {
    private readonly node;
    readonly key: any[];
    private readonly startIndex;
    constructor(node: Node<V>, key: any[], startIndex: number);
    readonly exists = false;
    get value(): undefined;
    set(value: V): V;
    orSet(value: V): V;
    orSetWith(create: (key: any[]) => V): V;
    entries(): Generator<[any[], any], void, undefined>;
}
declare class Occupied<V> {
    private readonly node;
    readonly key: any[];
    constructor(node: Node<V> & {
        data: V;
    }, key: any[]);
    readonly exists = true;
    get value(): V;
    set(value: V): V;
    orSet(_: V): V | (typeof EMPTY & V);
    orSetWith(_: (key: any[]) => V): V | (typeof EMPTY & V);
    entries(): Generator<[any[], any], void, undefined>;
}
export default Trie;
//# sourceMappingURL=weakish-trie.d.ts.map