"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeSubgraphs = exports.isMergeFailure = exports.isMergeSuccessful = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const hints_1 = require("../hints");
const linkSpec = federation_internals_1.LINK_VERSIONS.latest();
const joinSpec = federation_internals_1.JOIN_VERSIONS.latest();
const inaccessibleSpec = federation_internals_1.INACCESSIBLE_VERSIONS.latest();
class FieldMergeContext {
    constructor(sources) {
        this._props = (new Array(sources.length)).fill(true).map(_ => ({ usedOverridden: false, unusedOverridden: false }));
    }
    isUsedOverridden(idx) {
        return this._props[idx].usedOverridden;
    }
    isUnusedOverridden(idx) {
        return this._props[idx].unusedOverridden;
    }
    setUsedOverridden(idx) {
        this._props[idx].usedOverridden = true;
    }
    setUnusedOverridden(idx) {
        this._props[idx].unusedOverridden = true;
    }
    some(predicate) {
        return this._props.some(predicate);
    }
}
const defaultCompositionOptions = {
    allowedFieldTypeMergingSubtypingRules: federation_internals_1.DEFAULT_SUBTYPING_RULES
};
function isMergeSuccessful(mergeResult) {
    return !isMergeFailure(mergeResult);
}
exports.isMergeSuccessful = isMergeSuccessful;
function isMergeFailure(mergeResult) {
    return !!mergeResult.errors;
}
exports.isMergeFailure = isMergeFailure;
function mergeSubgraphs(subgraphs, options = {}) {
    (0, federation_internals_1.assert)(subgraphs.values().every((s) => s.isFed2Subgraph()), 'Merging should only be applied to federation 2 subgraphs');
    return new Merger(subgraphs, { ...defaultCompositionOptions, ...options }).merge();
}
exports.mergeSubgraphs = mergeSubgraphs;
function copyTypeReference(source, dest) {
    switch (source.kind) {
        case 'ListType':
            return new federation_internals_1.ListType(copyTypeReference(source.ofType, dest));
        case 'NonNullType':
            return new federation_internals_1.NonNullType(copyTypeReference(source.ofType, dest));
        default:
            const type = dest.type(source.name);
            (0, federation_internals_1.assert)(type, () => `Cannot find type ${source} in destination schema (with types: ${dest.types().join(', ')})`);
            return type;
    }
}
const NON_MERGED_CORE_FEATURES = [federation_internals_1.federationIdentity, federation_internals_1.linkIdentity, federation_internals_1.coreIdentity];
function isMergedType(type) {
    var _a;
    if (type.isIntrospectionType() || federation_internals_1.FEDERATION_OPERATION_TYPES.map((s) => s.name).includes(type.name)) {
        return false;
    }
    const coreFeatures = type.schema().coreFeatures;
    const typeFeature = (_a = coreFeatures === null || coreFeatures === void 0 ? void 0 : coreFeatures.sourceFeature(type)) === null || _a === void 0 ? void 0 : _a.url.identity;
    return !(typeFeature && NON_MERGED_CORE_FEATURES.includes(typeFeature));
}
function isMergedField(field) {
    return field.kind !== 'FieldDefinition' || !(0, federation_internals_1.isFederationField)(field);
}
function isGraphQLBuiltInDirective(def) {
    return !!def.schema().builtInDirective(def.name);
}
const MERGED_FEDERATION_DIRECTIVES = [
    { specInSupergraph: federation_internals_1.TAG_VERSIONS.latest(), definitionInSubgraph: (subgraph) => subgraph.metadata().tagDirective() },
    { specInSupergraph: federation_internals_1.INACCESSIBLE_VERSIONS.latest(), definitionInSubgraph: (subgraph) => subgraph.metadata().inaccessibleDirective() },
];
function filteredRoot(def, rootKind) {
    var _a;
    const type = (_a = def.root(rootKind)) === null || _a === void 0 ? void 0 : _a.type;
    return type && hasMergedFields(type) ? type : undefined;
}
function hasMergedFields(type) {
    for (const field of type.fields()) {
        if (isMergedField(field)) {
            return true;
        }
    }
    return false;
}
function indexOfMax(arr) {
    if (arr.length === 0) {
        return -1;
    }
    let indexOfMax = 0;
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > arr[indexOfMax]) {
            indexOfMax = i;
        }
    }
    return indexOfMax;
}
function descriptionString(toIndent, indentation) {
    return indentation + '"""\n' + indentation + toIndent.replace('\n', '\n' + indentation) + '\n' + indentation + '"""';
}
function typeKindToString(t) {
    return t.kind.replace("Type", " Type");
}
function locationString(locations) {
    if (locations.length === 0) {
        return "";
    }
    return (locations.length === 1 ? 'location ' : 'locations ') + '"' + locations.join(', ') + '"';
}
class Merger {
    constructor(subgraphs, options) {
        this.subgraphs = subgraphs;
        this.options = options;
        this.errors = [];
        this.hints = [];
        this.merged = new federation_internals_1.Schema();
        this.mergedFederationDirectiveNames = new Set();
        this.mergedFederationDirectiveInSupergraph = new Map();
        this.enumUsages = new Map();
        this.names = subgraphs.names();
        this.subgraphsSchema = subgraphs.values().map(subgraph => subgraph.schema);
        this.subgraphNamesToJoinSpecName = this.prepareSupergraph();
    }
    prepareSupergraph() {
        linkSpec.addToSchema(this.merged);
        const errors = linkSpec.applyFeatureToSchema(this.merged, joinSpec, undefined, joinSpec.defaultCorePurpose);
        (0, federation_internals_1.assert)(errors.length === 0, "We shouldn't have errors adding the join spec to the (still empty) supergraph schema");
        for (const mergedInfo of MERGED_FEDERATION_DIRECTIVES) {
            this.validateAndMaybeAddSpec(mergedInfo);
        }
        return joinSpec.populateGraphEnum(this.merged, this.subgraphs);
    }
    validateAndMaybeAddSpec({ specInSupergraph, definitionInSubgraph }) {
        var _a;
        let nameInSupergraph;
        for (const subgraph of this.subgraphs) {
            const directive = definitionInSubgraph(subgraph);
            if (directive.applications().length === 0) {
                continue;
            }
            if (!nameInSupergraph) {
                nameInSupergraph = directive.name;
            }
            else if (nameInSupergraph !== directive.name) {
                this.reportMismatchError(federation_internals_1.ERRORS.LINK_IMPORT_NAME_MISMATCH, `The federation "@${specInSupergraph.url.name}" directive is imported with mismatched name between subgraphs: it is imported as `, (_a = subgraph.metadata().federationFeature()) === null || _a === void 0 ? void 0 : _a.directive, this.subgraphs.values().map((s) => { var _a; return (_a = s.metadata().federationFeature()) === null || _a === void 0 ? void 0 : _a.directive; }), (linkDef) => { var _a, _b; return `"@${(_b = (_a = (0, federation_internals_1.federationMetadata)(linkDef.schema())) === null || _a === void 0 ? void 0 : _a.federationFeature()) === null || _b === void 0 ? void 0 : _b.directiveNameInSchema(specInSupergraph.url.name)}"`; });
                return;
            }
        }
        if (nameInSupergraph) {
            const errors = linkSpec.applyFeatureToSchema(this.merged, specInSupergraph, nameInSupergraph === specInSupergraph.url.name ? undefined : nameInSupergraph, specInSupergraph.defaultCorePurpose);
            (0, federation_internals_1.assert)(errors.length === 0, "We shouldn't have errors adding the join spec to the (still empty) supergraph schema");
            this.mergedFederationDirectiveNames.add(nameInSupergraph);
            this.mergedFederationDirectiveInSupergraph.set(specInSupergraph.url.name, this.merged.directive(nameInSupergraph));
        }
    }
    joinSpecName(subgraphIndex) {
        return this.subgraphNamesToJoinSpecName.get(this.names[subgraphIndex]);
    }
    metadata(idx) {
        return this.subgraphs.values()[idx].metadata();
    }
    isMergedDirective(definition) {
        if (definition instanceof federation_internals_1.Directive) {
            return this.mergedFederationDirectiveNames.has(definition.name) || isGraphQLBuiltInDirective(definition.definition);
        }
        else if (isGraphQLBuiltInDirective(definition)) {
            return false;
        }
        return definition.locations.some(loc => federation_internals_1.executableDirectiveLocations.includes(loc));
    }
    merge() {
        this.addTypesShallow();
        this.addDirectivesShallow();
        const typesToMerge = this.merged.types()
            .filter((type) => !linkSpec.isSpecType(type) && !joinSpec.isSpecType(type));
        for (const objectType of (0, federation_internals_1.filterTypesOfKind)(typesToMerge, 'ObjectType')) {
            this.mergeImplements(this.subgraphsTypes(objectType), objectType);
        }
        for (const interfaceType of (0, federation_internals_1.filterTypesOfKind)(typesToMerge, 'InterfaceType')) {
            this.mergeImplements(this.subgraphsTypes(interfaceType), interfaceType);
        }
        for (const unionType of (0, federation_internals_1.filterTypesOfKind)(typesToMerge, 'UnionType')) {
            this.mergeType(this.subgraphsTypes(unionType), unionType);
        }
        this.mergeSchemaDefinition(this.subgraphsSchema.map(s => s.schemaDefinition), this.merged.schemaDefinition);
        for (const type of typesToMerge) {
            if (type.kind === 'UnionType' || type.kind === 'EnumType') {
                continue;
            }
            this.mergeType(this.subgraphsTypes(type), type);
        }
        for (const definition of this.merged.directives()) {
            if (linkSpec.isSpecDirective(definition) || joinSpec.isSpecDirective(definition)) {
                continue;
            }
            this.mergeDirectiveDefinition(this.subgraphsSchema.map(s => s.directive(definition.name)), definition);
        }
        for (const enumType of (0, federation_internals_1.filterTypesOfKind)(typesToMerge, 'EnumType')) {
            this.mergeType(this.subgraphsTypes(enumType), enumType);
        }
        if (!this.merged.schemaDefinition.rootType('query')) {
            this.errors.push(federation_internals_1.ERRORS.NO_QUERIES.err({ message: "No queries found in any subgraph: a supergraph must have a query root type." }));
        }
        if (this.errors.length === 0) {
            this.postMergeValidations();
            if (this.errors.length === 0) {
                try {
                    this.merged.validate();
                    this.merged.toAPISchema();
                }
                catch (e) {
                    const causes = (0, federation_internals_1.errorCauses)(e);
                    if (causes) {
                        this.errors.push(...this.updateInaccessibleErrorsWithLinkToSubgraphs(causes));
                    }
                    else {
                        throw e;
                    }
                }
            }
        }
        if (this.errors.length > 0) {
            return { errors: this.errors };
        }
        else {
            return {
                supergraph: this.merged,
                hints: this.hints
            };
        }
    }
    addTypesShallow() {
        const mismatchedTypes = new Set();
        for (const subgraph of this.subgraphsSchema) {
            for (const type of subgraph.allTypes()) {
                if (!isMergedType(type)) {
                    continue;
                }
                const previous = this.merged.type(type.name);
                if (!previous) {
                    this.merged.addType((0, federation_internals_1.newNamedType)(type.kind, type.name));
                }
                else if (previous.kind !== type.kind) {
                    mismatchedTypes.add(type.name);
                }
            }
        }
        mismatchedTypes.forEach(t => this.reportMismatchedTypeDefinitions(t));
    }
    addDirectivesShallow() {
        for (const subgraph of this.subgraphsSchema) {
            for (const directive of subgraph.allDirectives()) {
                if (!this.isMergedDirective(directive)) {
                    continue;
                }
                if (!this.merged.directive(directive.name)) {
                    this.merged.addDirectiveDefinition(new federation_internals_1.DirectiveDefinition(directive.name));
                }
            }
        }
    }
    reportMismatchedTypeDefinitions(mismatchedType) {
        const supergraphType = this.merged.type(mismatchedType);
        this.reportMismatchError(federation_internals_1.ERRORS.TYPE_KIND_MISMATCH, `Type "${mismatchedType}" has mismatched kind: it is defined as `, supergraphType, this.subgraphsSchema.map(s => s.type(mismatchedType)), typeKindToString);
    }
    reportMismatchError(code, message, mismatchedElement, subgraphElements, mismatchAccessor) {
        this.reportMismatch(mismatchedElement, subgraphElements, mismatchAccessor, (elt, names) => `${elt} in ${names}`, (elt, names) => `${elt} in ${names}`, (distribution, nodes) => {
            this.errors.push(code.err({
                message: message + (0, federation_internals_1.joinStrings)(distribution, ' and ', ' but '),
                nodes
            }));
        }, elt => !elt);
    }
    reportMismatchErrorWithSpecifics({ code, message, mismatchedElement, subgraphElements, mismatchAccessor, supergraphElementPrinter, otherElementsPrinter, ignorePredicate, includeMissingSources = false, extraNodes, }) {
        this.reportMismatch(mismatchedElement, subgraphElements, mismatchAccessor, supergraphElementPrinter, otherElementsPrinter, (distribution, nodes) => {
            this.errors.push(code.err({
                message: message + distribution[0] + (0, federation_internals_1.joinStrings)(distribution.slice(1), ' and '),
                nodes: nodes.concat(extraNodes !== null && extraNodes !== void 0 ? extraNodes : [])
            }));
        }, ignorePredicate, includeMissingSources);
    }
    reportMismatchHint(hintId, message, supergraphElement, subgraphElements, mismatchAccessor, supergraphElementPrinter, otherElementsPrinter, ignorePredicate, includeMissingSources = false, noEndOfMessageDot = false) {
        this.reportMismatch(supergraphElement, subgraphElements, mismatchAccessor, supergraphElementPrinter, otherElementsPrinter, (distribution, astNodes) => {
            this.hints.push(new hints_1.CompositionHint(hintId, message + distribution[0] + (0, federation_internals_1.joinStrings)(distribution.slice(1), ' and ') + (noEndOfMessageDot ? '' : '.'), astNodes));
        }, ignorePredicate, includeMissingSources);
    }
    reportMismatch(supergraphElement, subgraphElements, mismatchAccessor, supergraphElementPrinter, otherElementsPrinter, reporter, ignorePredicate, includeMissingSources = false) {
        var _a;
        const distributionMap = new federation_internals_1.MultiMap();
        const astNodes = [];
        for (const [i, subgraphElt] of subgraphElements.entries()) {
            if (!subgraphElt) {
                if (includeMissingSources) {
                    distributionMap.add('', this.names[i]);
                }
                continue;
            }
            if (ignorePredicate && ignorePredicate(subgraphElt)) {
                continue;
            }
            const elt = mismatchAccessor(subgraphElt, false);
            distributionMap.add(elt !== null && elt !== void 0 ? elt : '', this.names[i]);
            if (subgraphElt.sourceAST) {
                astNodes.push((0, federation_internals_1.addSubgraphToASTNode)(subgraphElt.sourceAST, this.names[i]));
            }
        }
        const supergraphMismatch = (_a = mismatchAccessor(supergraphElement, true)) !== null && _a !== void 0 ? _a : '';
        (0, federation_internals_1.assert)(distributionMap.size > 1, () => `Should not have been called for ${supergraphElement}`);
        const distribution = [];
        const subgraphsLikeSupergraph = distributionMap.get(supergraphMismatch);
        distribution.push(supergraphElementPrinter(supergraphMismatch, subgraphsLikeSupergraph ? (0, federation_internals_1.printSubgraphNames)(subgraphsLikeSupergraph) : undefined));
        for (const [v, names] of distributionMap.entries()) {
            if (v === supergraphMismatch) {
                continue;
            }
            distribution.push(otherElementsPrinter(v === '' ? undefined : v, (0, federation_internals_1.printSubgraphNames)(names)));
        }
        reporter(distribution, astNodes);
    }
    subgraphsTypes(supergraphType) {
        return this.subgraphsSchema.map((subgraph) => {
            const type = subgraph.type(supergraphType.name);
            if (!type || type.kind !== supergraphType.kind) {
                return undefined;
            }
            return type;
        });
    }
    mergeImplements(sources, dest) {
        const implemented = new Set();
        const joinImplementsDirective = joinSpec.implementsDirective(this.merged);
        for (const [idx, source] of sources.entries()) {
            if (source) {
                const name = this.joinSpecName(idx);
                for (const itf of source.interfaces()) {
                    implemented.add(itf.name);
                    dest.applyDirective(joinImplementsDirective, { graph: name, interface: itf.name });
                }
            }
        }
        implemented.forEach(itf => dest.addImplementedInterface(itf));
    }
    mergeDescription(sources, dest) {
        const descriptions = [];
        const counts = [];
        for (const source of sources) {
            if (!source || source.description === undefined) {
                continue;
            }
            const idx = descriptions.indexOf(source.description);
            if (idx < 0) {
                descriptions.push(source.description);
                counts.push(source.description === '' ? Number.MIN_SAFE_INTEGER : 1);
            }
            else {
                counts[idx]++;
            }
        }
        if (descriptions.length > 0) {
            if (descriptions.length === 1) {
                dest.description = descriptions[0];
            }
            else {
                const idx = indexOfMax(counts);
                dest.description = descriptions[idx];
                const name = dest instanceof federation_internals_1.NamedSchemaElement ? `Element "${dest.coordinate}"` : 'The schema definition';
                this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_DESCRIPTION, `${name} has inconsistent descriptions across subgraphs. `, dest, sources, elt => elt.description, (desc, subgraphs) => `The supergraph will use description (from ${subgraphs}):\n${descriptionString(desc, '  ')}`, (desc, subgraphs) => `\nIn ${subgraphs}, the description is:\n${descriptionString(desc, '  ')}`, elt => (elt === null || elt === void 0 ? void 0 : elt.description) === undefined, false, true);
            }
        }
    }
    mergeType(sources, dest) {
        this.checkForExtensionWithNoBase(sources, dest);
        this.mergeDescription(sources, dest);
        this.addJoinType(sources, dest);
        this.mergeAppliedDirectives(sources, dest);
        switch (dest.kind) {
            case 'ScalarType':
                break;
            case 'ObjectType':
                this.mergeObject(sources, dest);
                break;
            case 'InterfaceType':
                this.mergeInterface(sources, dest);
                break;
            case 'UnionType':
                this.mergeUnion(sources, dest);
                break;
            case 'EnumType':
                this.mergeEnum(sources, dest);
                break;
            case 'InputObjectType':
                this.mergeInput(sources, dest);
                break;
        }
    }
    checkForExtensionWithNoBase(sources, dest) {
        if ((0, federation_internals_1.isObjectType)(dest) && dest.isRootType()) {
            return;
        }
        const defSubgraphs = [];
        const extensionSubgraphs = [];
        const extensionASTs = [];
        for (const [i, source] of sources.entries()) {
            if (!source) {
                continue;
            }
            if (source.hasNonExtensionElements()) {
                defSubgraphs.push(this.names[i]);
            }
            if (source.hasExtensionElements()) {
                extensionSubgraphs.push(this.names[i]);
                extensionASTs.push((0, federation_internals_1.firstOf)(source.extensions().values()).sourceAST);
            }
        }
        if (extensionSubgraphs.length > 0 && defSubgraphs.length === 0) {
            for (const [i, subgraph] of extensionSubgraphs.entries()) {
                this.errors.push(federation_internals_1.ERRORS.EXTENSION_WITH_NO_BASE.err({
                    message: `[${subgraph}] Type "${dest}" is an extension type, but there is no type definition for "${dest}" in any subgraph.`,
                    nodes: extensionASTs[i],
                }));
            }
        }
    }
    addJoinType(sources, dest) {
        const joinTypeDirective = joinSpec.typeDirective(this.merged);
        for (const [idx, source] of sources.entries()) {
            if (!source) {
                continue;
            }
            const sourceMetadata = this.subgraphs.values()[idx].metadata();
            const keys = source.appliedDirectivesOf(sourceMetadata.keyDirective());
            const name = this.joinSpecName(idx);
            if (!keys.length) {
                dest.applyDirective(joinTypeDirective, { graph: name });
            }
            else {
                for (const key of keys) {
                    const extension = key.ofExtension() || source.hasAppliedDirective(sourceMetadata.extendsDirective()) ? true : undefined;
                    const { resolvable } = key.arguments();
                    dest.applyDirective(joinTypeDirective, { graph: name, key: key.arguments().fields, extension, resolvable });
                }
            }
        }
    }
    mergeObject(sources, dest) {
        const isEntity = this.hintOnInconsistentEntity(sources, dest);
        const isValueType = !isEntity && !dest.isRootType();
        this.addFieldsShallow(sources, dest);
        if (!dest.hasFields()) {
            dest.remove();
        }
        else {
            for (const destField of dest.fields()) {
                if (isValueType) {
                    this.hintOnInconsistentValueTypeField(sources, dest, destField);
                }
                const subgraphFields = sources.map(t => t === null || t === void 0 ? void 0 : t.field(destField.name));
                const mergeContext = this.validateOverride(subgraphFields, destField);
                this.mergeField(subgraphFields, destField, mergeContext);
                this.validateFieldSharing(subgraphFields, destField, mergeContext);
            }
        }
    }
    hintOnInconsistentEntity(sources, dest) {
        const sourceAsEntity = [];
        const sourceAsNonEntity = [];
        for (const source of sources) {
            if (!source) {
                continue;
            }
            if (source.hasAppliedDirective('key')) {
                sourceAsEntity.push(source);
            }
            else {
                sourceAsNonEntity.push(source);
            }
        }
        if (sourceAsEntity.length > 0 && sourceAsNonEntity.length > 0) {
            this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_ENTITY, `Type "${dest}" is declared as an entity (has a @key applied) in some but not all defining subgraphs: `, dest, sources, type => type.hasAppliedDirective('key') ? 'yes' : 'no', (_, subgraphs) => `it has no @key in ${subgraphs}`, (_, subgraphs) => ` but has some @key in ${subgraphs}`);
        }
        return sourceAsEntity.length > 0;
    }
    hintOnInconsistentValueTypeField(sources, dest, field) {
        let hintId;
        let typeDescription;
        switch (dest.kind) {
            case 'ObjectType':
                hintId = hints_1.HINTS.INCONSISTENT_OBJECT_VALUE_TYPE_FIELD;
                typeDescription = 'non-entity object';
                break;
            case 'InterfaceType':
                hintId = hints_1.HINTS.INCONSISTENT_INTERFACE_VALUE_TYPE_FIELD;
                typeDescription = 'interface';
                break;
        }
        for (const source of sources) {
            if (source && !source.field(field.name)) {
                this.reportMismatchHint(hintId, `Field "${field.coordinate}" of ${typeDescription} type "${dest}" is defined in some but not all subgraphs that define "${dest}": `, dest, sources, type => type.field(field.name) ? 'yes' : 'no', (_, subgraphs) => `"${field.coordinate}" is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`);
            }
        }
    }
    addFieldsShallow(sources, dest) {
        for (const source of sources) {
            if (!source) {
                continue;
            }
            for (const field of source.fields()) {
                if (!isMergedField(field)) {
                    continue;
                }
                if (!dest.field(field.name)) {
                    dest.addField(field.name);
                }
            }
        }
    }
    isExternal(sourceIdx, field) {
        return this.metadata(sourceIdx).isFieldExternal(field);
    }
    isFullyExternal(sourceIdx, field) {
        return this.metadata(sourceIdx).isFieldFullyExternal(field);
    }
    validateAndFilterExternal(sources) {
        const filtered = [];
        for (const [i, source] of sources.entries()) {
            if (source == undefined || !this.isExternal(i, source)) {
                filtered.push(source);
            }
            else {
                filtered.push(undefined);
                for (const directive of source.appliedDirectives) {
                    if (this.isMergedDirective(directive)) {
                        this.errors.push(federation_internals_1.ERRORS.MERGED_DIRECTIVE_APPLICATION_ON_EXTERNAL.err({
                            message: `[${this.names[i]}] Cannot apply merged directive ${directive} to external field "${source.coordinate}"`,
                            nodes: directive.sourceAST
                        }));
                    }
                }
            }
        }
        return filtered;
    }
    hasExternal(sources) {
        return sources.some((s, i) => s !== undefined && this.isExternal(i, s));
    }
    isShareable(sourceIdx, field) {
        return this.metadata(sourceIdx).isFieldShareable(field);
    }
    getOverrideDirective(sourceIdx, field) {
        const metadata = this.metadata(sourceIdx);
        const overrideDirective = metadata.isFed2Schema() ? metadata.overrideDirective() : undefined;
        const allFieldOverrides = overrideDirective ? field.appliedDirectivesOf(overrideDirective) : [];
        return allFieldOverrides[0];
    }
    overrideConflictsWithOtherDirective({ idx, field, subgraphName, fromIdx, fromField, }) {
        const fromMetadata = this.metadata(fromIdx);
        for (const directive of [fromMetadata.requiresDirective(), fromMetadata.providesDirective()]) {
            if (fromField === null || fromField === void 0 ? void 0 : fromField.hasAppliedDirective(directive)) {
                return {
                    result: true,
                    conflictingDirective: directive,
                    subgraph: subgraphName,
                };
            }
        }
        if (field && this.isExternal(idx, field)) {
            return {
                result: true,
                conflictingDirective: fromMetadata.externalDirective(),
                subgraph: subgraphName,
            };
        }
        return { result: false };
    }
    validateOverride(sources, { coordinate }) {
        const result = new FieldMergeContext(sources);
        const { subgraphsWithOverride, subgraphMap } = sources.map((source, idx) => {
            if (!source) {
                return undefined;
            }
            return {
                idx,
                name: this.names[idx],
                overrideDirective: this.getOverrideDirective(idx, source),
            };
        }).reduce((acc, elem) => {
            if (elem !== undefined) {
                acc.subgraphMap[elem.name] = elem;
                if (elem.overrideDirective !== undefined) {
                    acc.subgraphsWithOverride.push(elem.name);
                }
            }
            return acc;
        }, { subgraphsWithOverride: [], subgraphMap: {} });
        subgraphsWithOverride.forEach((subgraphName) => {
            var _a;
            const { overrideDirective } = subgraphMap[subgraphName];
            const sourceSubgraphName = (_a = overrideDirective === null || overrideDirective === void 0 ? void 0 : overrideDirective.arguments()) === null || _a === void 0 ? void 0 : _a.from;
            const overridingSubgraphASTNode = (overrideDirective === null || overrideDirective === void 0 ? void 0 : overrideDirective.sourceAST) ? (0, federation_internals_1.addSubgraphToASTNode)(overrideDirective.sourceAST, subgraphName) : undefined;
            if (!this.names.includes(sourceSubgraphName)) {
                const suggestions = (0, federation_internals_1.suggestionList)(sourceSubgraphName, this.names);
                const extraMsg = (0, federation_internals_1.didYouMean)(suggestions);
                this.hints.push(new hints_1.CompositionHint(hints_1.HINTS.FROM_SUBGRAPH_DOES_NOT_EXIST, `Source subgraph "${sourceSubgraphName}" for field "${coordinate}" on subgraph "${subgraphName}" does not exist.${extraMsg}`, overridingSubgraphASTNode));
            }
            else if (sourceSubgraphName === subgraphName) {
                this.errors.push(federation_internals_1.ERRORS.OVERRIDE_FROM_SELF_ERROR.err({
                    message: `Source and destination subgraphs "${sourceSubgraphName}" are the same for overridden field "${coordinate}"`,
                    nodes: overrideDirective === null || overrideDirective === void 0 ? void 0 : overrideDirective.sourceAST,
                }));
            }
            else if (subgraphsWithOverride.includes(sourceSubgraphName)) {
                this.errors.push(federation_internals_1.ERRORS.OVERRIDE_SOURCE_HAS_OVERRIDE.err({
                    message: `Field "${coordinate}" on subgraph "${subgraphName}" is also marked with directive @override in subgraph "${sourceSubgraphName}". Only one @override directive is allowed per field.`,
                    nodes: (0, federation_internals_1.sourceASTs)(overrideDirective, subgraphMap[sourceSubgraphName].overrideDirective)
                }));
            }
            else if (subgraphMap[sourceSubgraphName] === undefined) {
                this.hints.push(new hints_1.CompositionHint(hints_1.HINTS.OVERRIDE_DIRECTIVE_CAN_BE_REMOVED, `Field "${coordinate}" on subgraph "${subgraphName}" no longer exists in the from subgraph. The @override directive can be removed.`, overridingSubgraphASTNode));
            }
            else {
                const fromIdx = this.names.indexOf(sourceSubgraphName);
                const fromField = sources[fromIdx];
                const { result: hasIncompatible, conflictingDirective, subgraph } = this.overrideConflictsWithOtherDirective({
                    idx: subgraphMap[subgraphName].idx,
                    field: sources[subgraphMap[subgraphName].idx],
                    subgraphName,
                    fromIdx: this.names.indexOf(sourceSubgraphName),
                    fromField: sources[fromIdx],
                });
                if (hasIncompatible) {
                    (0, federation_internals_1.assert)(conflictingDirective !== undefined, 'conflictingDirective should not be undefined');
                    this.errors.push(federation_internals_1.ERRORS.OVERRIDE_COLLISION_WITH_ANOTHER_DIRECTIVE.err({
                        message: `@override cannot be used on field "${fromField === null || fromField === void 0 ? void 0 : fromField.coordinate}" on subgraph "${subgraphName}" since "${fromField === null || fromField === void 0 ? void 0 : fromField.coordinate}" on "${subgraph}" is marked with directive "@${conflictingDirective.name}"`,
                        nodes: (0, federation_internals_1.sourceASTs)(overrideDirective, conflictingDirective)
                    }));
                }
                else {
                    (0, federation_internals_1.assert)(fromField, 'fromField should not be undefined');
                    const overriddenSubgraphASTNode = fromField.sourceAST ? (0, federation_internals_1.addSubgraphToASTNode)(fromField.sourceAST, sourceSubgraphName) : undefined;
                    if (this.isExternal(fromIdx, fromField)) {
                        this.hints.push(new hints_1.CompositionHint(hints_1.HINTS.OVERRIDE_DIRECTIVE_CAN_BE_REMOVED, `Field "${coordinate}" on subgraph "${subgraphName}" is not resolved anymore by the from subgraph (it is marked "@external" in "${sourceSubgraphName}"). The @override directive can be removed.`, overridingSubgraphASTNode));
                    }
                    else if (this.metadata(fromIdx).isFieldUsed(fromField)) {
                        result.setUsedOverridden(fromIdx);
                        this.hints.push(new hints_1.CompositionHint(hints_1.HINTS.OVERRIDDEN_FIELD_CAN_BE_REMOVED, `Field "${coordinate}" on subgraph "${sourceSubgraphName}" is overridden. It is still used in some federation directive(s) (@key, @requires, and/or @provides) and/or to satisfy interface constraint(s), but consider marking it @external explicitly or removing it along with its references.`, overriddenSubgraphASTNode));
                    }
                    else {
                        result.setUnusedOverridden(fromIdx);
                        this.hints.push(new hints_1.CompositionHint(hints_1.HINTS.OVERRIDDEN_FIELD_CAN_BE_REMOVED, `Field "${coordinate}" on subgraph "${sourceSubgraphName}" is overridden. Consider removing it.`, overriddenSubgraphASTNode));
                    }
                }
            }
        });
        return result;
    }
    mergeField(sources, dest, mergeContext = new FieldMergeContext(sources)) {
        if (sources.every((s, i) => s === undefined || this.isExternal(i, s))) {
            const definingSubgraphs = sources.map((source, i) => source ? this.names[i] : undefined).filter(s => s !== undefined);
            const nodes = sources.map(source => source === null || source === void 0 ? void 0 : source.sourceAST).filter(s => s !== undefined);
            this.errors.push(federation_internals_1.ERRORS.EXTERNAL_MISSING_ON_BASE.err({
                message: `Field "${dest.coordinate}" is marked @external on all the subgraphs in which it is listed (${(0, federation_internals_1.printSubgraphNames)(definingSubgraphs)}).`,
                nodes
            }));
            return;
        }
        const withoutExternal = this.validateAndFilterExternal(sources);
        this.mergeDescription(withoutExternal, dest);
        this.mergeAppliedDirectives(withoutExternal, dest);
        this.addArgumentsShallow(withoutExternal, dest);
        for (const destArg of dest.arguments()) {
            const subgraphArgs = withoutExternal.map(f => f === null || f === void 0 ? void 0 : f.argument(destArg.name));
            this.mergeArgument(subgraphArgs, destArg);
        }
        const allTypesEqual = this.mergeTypeReference(withoutExternal, dest);
        if (this.hasExternal(sources)) {
            this.validateExternalFields(sources, dest, allTypesEqual);
        }
        this.addJoinField({ sources, dest, allTypesEqual, mergeContext });
    }
    validateFieldSharing(sources, dest, mergeContext) {
        const shareableSources = [];
        const nonShareableSources = [];
        const allResolving = [];
        for (const [i, source] of sources.entries()) {
            const overridden = mergeContext.isUsedOverridden(i) || mergeContext.isUnusedOverridden(i);
            if (!source || this.isFullyExternal(i, source) || overridden) {
                continue;
            }
            allResolving.push(source);
            if (this.isShareable(i, source)) {
                shareableSources.push(i);
            }
            else {
                nonShareableSources.push(i);
            }
        }
        if (nonShareableSources.length > 0 && (shareableSources.length > 0 || nonShareableSources.length > 1)) {
            const resolvingSubgraphs = nonShareableSources.concat(shareableSources).map((s) => this.names[s]);
            const nonShareables = shareableSources.length > 0
                ? (0, federation_internals_1.printSubgraphNames)(nonShareableSources.map((s) => this.names[s]))
                : 'all of them';
            this.errors.push(federation_internals_1.ERRORS.INVALID_FIELD_SHARING.err({
                message: `Non-shareable field "${dest.coordinate}" is resolved from multiple subgraphs: it is resolved from ${(0, federation_internals_1.printSubgraphNames)(resolvingSubgraphs)} and defined as non-shareable in ${nonShareables}`,
                nodes: (0, federation_internals_1.sourceASTs)(...allResolving),
            }));
        }
    }
    validateExternalFields(sources, dest, allTypesEqual) {
        let hasInvalidTypes = false;
        const invalidArgsPresence = new Set();
        const invalidArgsTypes = new Set();
        const invalidArgsDefaults = new Set();
        for (const [i, source] of sources.entries()) {
            if (!source || !this.isExternal(i, source)) {
                continue;
            }
            if (!((0, federation_internals_1.sameType)(dest.type, source.type) || (!allTypesEqual && this.isStrictSubtype(dest.type, source.type)))) {
                hasInvalidTypes = true;
            }
            for (const destArg of dest.arguments()) {
                const name = destArg.name;
                const arg = source.argument(name);
                if (!arg) {
                    invalidArgsPresence.add(name);
                    continue;
                }
                if (!(0, federation_internals_1.sameType)(destArg.type, arg.type) && !this.isStrictSubtype(arg.type, destArg.type)) {
                    invalidArgsTypes.add(name);
                }
                if (destArg.defaultValue !== arg.defaultValue) {
                    invalidArgsDefaults.add(name);
                }
            }
        }
        if (hasInvalidTypes) {
            this.reportMismatchError(federation_internals_1.ERRORS.EXTERNAL_TYPE_MISMATCH, `Type of field "${dest.coordinate}" is incompatible across subgraphs (where marked @external): it has `, dest, sources, field => `type "${field.type}"`);
        }
        for (const arg of invalidArgsPresence) {
            const destArg = dest.argument(arg);
            this.reportMismatchErrorWithSpecifics({
                code: federation_internals_1.ERRORS.EXTERNAL_ARGUMENT_MISSING,
                message: `Field "${dest.coordinate}" is missing argument "${destArg.coordinate}" in some subgraphs where it is marked @external: `,
                mismatchedElement: destArg,
                subgraphElements: sources.map(s => s === null || s === void 0 ? void 0 : s.argument(destArg.name)),
                mismatchAccessor: arg => arg ? `argument "${arg.coordinate}"` : undefined,
                supergraphElementPrinter: (elt, subgraphs) => `${elt} is declared in ${subgraphs}`,
                otherElementsPrinter: (_, subgraphs) => ` but not in ${subgraphs} (where "${dest.coordinate}" is @external).`,
                includeMissingSources: true,
            });
        }
        for (const arg of invalidArgsTypes) {
            const destArg = dest.argument(arg);
            this.reportMismatchError(federation_internals_1.ERRORS.EXTERNAL_ARGUMENT_TYPE_MISMATCH, `Type of argument "${destArg.coordinate}" is incompatible across subgraphs (where "${dest.coordinate}" is marked @external): it has `, destArg, sources.map(s => s === null || s === void 0 ? void 0 : s.argument(destArg.name)), arg => `type "${arg.type}"`);
        }
        for (const arg of invalidArgsDefaults) {
            const destArg = dest.argument(arg);
            this.reportMismatchError(federation_internals_1.ERRORS.EXTERNAL_ARGUMENT_DEFAULT_MISMATCH, `Argument "${destArg.coordinate}" has incompatible defaults across subgraphs (where "${dest.coordinate}" is marked @external): it has `, destArg, sources.map(s => s === null || s === void 0 ? void 0 : s.argument(destArg.name)), arg => arg.defaultValue !== undefined ? `default value ${(0, federation_internals_1.valueToString)(arg.defaultValue, arg.type)}` : 'no default value');
        }
    }
    needsJoinField({ sources, parentName, allTypesEqual, mergeContext, }) {
        if (!allTypesEqual) {
            return true;
        }
        if (mergeContext.some(({ usedOverridden }) => usedOverridden)) {
            return true;
        }
        for (const [idx, source] of sources.entries()) {
            const overridden = mergeContext.isUnusedOverridden(idx);
            if (source && !overridden) {
                const sourceMeta = this.subgraphs.values()[idx].metadata();
                if (this.isExternal(idx, source)
                    || source.hasAppliedDirective(sourceMeta.providesDirective())
                    || source.hasAppliedDirective(sourceMeta.requiresDirective())) {
                    return true;
                }
            }
            else {
                if (this.subgraphsSchema[idx].type(parentName)) {
                    return true;
                }
            }
        }
        return false;
    }
    addJoinField({ sources, dest, allTypesEqual, mergeContext, }) {
        var _a, _b, _c;
        if (!this.needsJoinField({
            sources,
            parentName: dest.parent.name,
            allTypesEqual,
            mergeContext,
        })) {
            return;
        }
        const joinFieldDirective = joinSpec.fieldDirective(this.merged);
        for (const [idx, source] of sources.entries()) {
            const usedOverridden = mergeContext.isUsedOverridden(idx);
            const unusedOverridden = mergeContext.isUnusedOverridden(idx);
            if (!source || unusedOverridden) {
                continue;
            }
            const external = this.isExternal(idx, source);
            const sourceMeta = this.subgraphs.values()[idx].metadata();
            const name = this.joinSpecName(idx);
            dest.applyDirective(joinFieldDirective, {
                graph: name,
                requires: this.getFieldSet(source, sourceMeta.requiresDirective()),
                provides: this.getFieldSet(source, sourceMeta.providesDirective()),
                override: (_b = (_a = source.appliedDirectivesOf(sourceMeta.overrideDirective()).pop()) === null || _a === void 0 ? void 0 : _a.arguments()) === null || _b === void 0 ? void 0 : _b.from,
                type: allTypesEqual ? undefined : (_c = source.type) === null || _c === void 0 ? void 0 : _c.toString(),
                external: external ? true : undefined,
                usedOverridden: usedOverridden ? true : undefined,
            });
        }
    }
    getFieldSet(element, directive) {
        const applications = element.appliedDirectivesOf(directive);
        (0, federation_internals_1.assert)(applications.length <= 1, () => `Found more than one application of ${directive} on ${element}`);
        return applications.length === 0 ? undefined : applications[0].arguments().fields;
    }
    mergeTypeReference(sources, dest, isInputPosition = false) {
        var _a;
        let destType;
        let hasSubtypes = false;
        let hasIncompatible = false;
        for (const source of sources) {
            if (!source) {
                continue;
            }
            const sourceType = source.type;
            if (!destType || (0, federation_internals_1.sameType)(destType, sourceType)) {
                destType = sourceType;
            }
            else if (this.isStrictSubtype(destType, sourceType)) {
                hasSubtypes = true;
                if (isInputPosition) {
                    destType = sourceType;
                }
            }
            else if (this.isStrictSubtype(sourceType, destType)) {
                hasSubtypes = true;
                if (!isInputPosition) {
                    destType = sourceType;
                }
            }
            else {
                hasIncompatible = true;
            }
        }
        (0, federation_internals_1.assert)(destType, () => `We should have found at least one subgraph with a type for ${dest.coordinate}`);
        dest.type = copyTypeReference(destType, this.merged);
        const isArgument = dest instanceof federation_internals_1.ArgumentDefinition;
        const elementKind = isArgument ? 'argument' : 'field';
        const base = (0, federation_internals_1.baseType)(dest.type);
        if ((0, federation_internals_1.isEnumType)(base)) {
            const existing = this.enumUsages.get(base.name);
            const thisPosition = isInputPosition ? 'Input' : 'Output';
            const position = existing && existing.position !== thisPosition ? 'Both' : thisPosition;
            const examples = (_a = existing === null || existing === void 0 ? void 0 : existing.examples) !== null && _a !== void 0 ? _a : {};
            if (!examples[thisPosition]) {
                const idx = sources.findIndex((s) => !!s);
                if (idx >= 0) {
                    const example = sources[idx];
                    examples[thisPosition] = {
                        coordinate: example.coordinate,
                        sourceAST: example.sourceAST ? (0, federation_internals_1.addSubgraphToASTNode)(example.sourceAST, this.names[idx]) : undefined,
                    };
                }
            }
            this.enumUsages.set(base.name, { position, examples });
        }
        if (hasIncompatible) {
            this.reportMismatchError(isArgument ? federation_internals_1.ERRORS.ARGUMENT_TYPE_MISMATCH : federation_internals_1.ERRORS.FIELD_TYPE_MISMATCH, `Type of ${elementKind} "${dest.coordinate}" is incompatible across subgraphs: it has `, dest, sources, field => `type "${field.type}"`);
            return false;
        }
        else if (hasSubtypes) {
            this.reportMismatchHint(isArgument ? hints_1.HINTS.INCONSISTENT_BUT_COMPATIBLE_ARGUMENT_TYPE : hints_1.HINTS.INCONSISTENT_BUT_COMPATIBLE_FIELD_TYPE, `Type of ${elementKind} "${dest.coordinate}" is inconsistent but compatible across subgraphs: `, dest, sources, field => field.type.toString(), (elt, subgraphs) => `will use type "${elt}" (from ${subgraphs}) in supergraph but "${dest.coordinate}" has `, (elt, subgraphs) => `${isInputPosition ? 'supertype' : 'subtype'} "${elt}" in ${subgraphs}`);
            return false;
        }
        return true;
    }
    isStrictSubtype(type, maybeSubType) {
        return (0, federation_internals_1.isStrictSubtype)(type, maybeSubType, this.options.allowedFieldTypeMergingSubtypingRules, (union, maybeMember) => this.merged.type(union.name).hasTypeMember(maybeMember.name), (maybeImplementer, itf) => this.merged.type(maybeImplementer.name).implementsInterface(itf));
    }
    addArgumentsShallow(sources, dest) {
        const argNames = new Set();
        for (const source of sources) {
            if (!source) {
                continue;
            }
            source.arguments().forEach((arg) => argNames.add(arg.name));
        }
        for (const argName of argNames) {
            const arg = dest.addArgument(argName);
            if (sources.some((s) => s && !s.argument(argName))) {
                const nonOptionalSources = sources.map((s, i) => { var _a; return s && ((_a = s.argument(argName)) === null || _a === void 0 ? void 0 : _a.isRequired()) ? this.names[i] : undefined; }).filter((s) => !!s);
                if (nonOptionalSources.length > 0) {
                    const nonOptionalSubgraphs = (0, federation_internals_1.printSubgraphNames)(nonOptionalSources);
                    const missingSources = (0, federation_internals_1.printSubgraphNames)(sources.map((s, i) => s && !s.argument(argName) ? this.names[i] : undefined).filter((s) => !!s));
                    this.errors.push(federation_internals_1.ERRORS.REQUIRED_ARGUMENT_MISSING_IN_SOME_SUBGRAPH.err({
                        message: `Argument "${arg.coordinate}" is required in some subgraphs but does not appear in all subgraphs: it is required in ${nonOptionalSubgraphs} but does not appear in ${missingSources}`,
                        nodes: (0, federation_internals_1.sourceASTs)(...sources.map((s) => s === null || s === void 0 ? void 0 : s.argument(argName))),
                    }));
                }
                else {
                    this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_ARGUMENT_PRESENCE, `Optional argument "${arg.coordinate}" will not be included in the supergraph as it does not appear in all subgraphs: `, arg, sources.map((s) => s ? s.argument(argName) : undefined), _ => 'yes', (_, subgraphs) => `it is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`, undefined, true);
                }
                arg.remove();
            }
        }
    }
    mergeArgument(sources, dest) {
        this.mergeDescription(sources, dest);
        this.mergeAppliedDirectives(sources, dest);
        this.mergeTypeReference(sources, dest, true);
        this.mergeDefaultValue(sources, dest, 'Argument');
    }
    mergeDefaultValue(sources, dest, kind) {
        let destDefault;
        let hasSeenSource = false;
        let isInconsistent = false;
        let isIncompatible = false;
        for (const source of sources) {
            if (!source) {
                continue;
            }
            const sourceDefault = source.defaultValue;
            if (destDefault === undefined) {
                destDefault = sourceDefault;
                if (hasSeenSource && sourceDefault !== undefined) {
                    isInconsistent = true;
                }
            }
            else if (!(0, federation_internals_1.valueEquals)(destDefault, sourceDefault)) {
                isInconsistent = true;
                if (sourceDefault !== undefined) {
                    isIncompatible = true;
                }
            }
            hasSeenSource = true;
        }
        if (!isInconsistent || isIncompatible) {
            dest.defaultValue = destDefault;
        }
        if (isIncompatible) {
            this.reportMismatchError(kind === 'Argument' ? federation_internals_1.ERRORS.ARGUMENT_DEFAULT_MISMATCH : federation_internals_1.ERRORS.INPUT_FIELD_DEFAULT_MISMATCH, `${kind} "${dest.coordinate}" has incompatible default values across subgraphs: it has `, dest, sources, arg => arg.defaultValue !== undefined ? `default value ${(0, federation_internals_1.valueToString)(arg.defaultValue, arg.type)}` : 'no default value');
        }
        else if (isInconsistent) {
            this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_DEFAULT_VALUE_PRESENCE, `${kind} "${dest.coordinate}" has a default value in only some subgraphs: `, dest, sources, arg => arg.defaultValue !== undefined ? (0, federation_internals_1.valueToString)(arg.defaultValue, arg.type) : undefined, (_, subgraphs) => `will not use a default in the supergraph (there is no default in ${subgraphs}) but `, (elt, subgraphs) => `"${dest.coordinate}" has default value ${elt} in ${subgraphs}`);
        }
    }
    mergeInterface(sources, dest) {
        this.addFieldsShallow(sources, dest);
        for (const destField of dest.fields()) {
            this.hintOnInconsistentValueTypeField(sources, dest, destField);
            const subgraphFields = sources.map(t => t === null || t === void 0 ? void 0 : t.field(destField.name));
            this.mergeField(subgraphFields, destField);
        }
    }
    mergeUnion(sources, dest) {
        for (const source of sources) {
            if (!source) {
                continue;
            }
            for (const type of source.types()) {
                if (!dest.hasTypeMember(type.name)) {
                    dest.addType(type.name);
                }
            }
        }
        for (const type of dest.types()) {
            this.hintOnInconsistentUnionMember(sources, dest, type.name);
        }
    }
    hintOnInconsistentUnionMember(sources, dest, memberName) {
        for (const source of sources) {
            if (source && !source.hasTypeMember(memberName)) {
                this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_UNION_MEMBER, `Union type "${dest}" includes member type "${memberName}" in some but not all defining subgraphs: `, dest, sources, type => type.hasTypeMember(memberName) ? 'yes' : 'no', (_, subgraphs) => `"${memberName}" is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`);
                return;
            }
        }
    }
    mergeEnum(sources, dest) {
        let usage = this.enumUsages.get(dest.name);
        if (!usage) {
            usage = { position: 'Output', examples: {} };
            this.hints.push(new hints_1.CompositionHint(hints_1.HINTS.UNUSED_ENUM_TYPE, `Enum type "${dest}" is defined but unused. It will be included in the supergraph with all the values appearing in any subgraph ("as if" it was only used as an output type).`));
        }
        for (const source of sources) {
            if (!source) {
                continue;
            }
            for (const value of source.values) {
                if (!dest.value(value.name)) {
                    dest.addValue(value.name);
                }
            }
        }
        for (const value of dest.values) {
            this.mergeEnumValue(sources, dest, value, usage);
        }
        if (dest.values.length === 0) {
            this.errors.push(federation_internals_1.ERRORS.EMPTY_MERGED_ENUM_TYPE.err({
                message: `None of the values of enum type "${dest}" are defined consistently in all the subgraphs defining that type. As only values common to all subgraphs are merged, this would result in an empty type.`,
                nodes: (0, federation_internals_1.sourceASTs)(...sources),
            }));
        }
    }
    mergeEnumValue(sources, dest, value, { position, examples }) {
        const valueSources = sources.map(s => s === null || s === void 0 ? void 0 : s.value(value.name));
        this.mergeDescription(valueSources, value);
        this.mergeAppliedDirectives(valueSources, value);
        const inaccessibleInSupergraph = this.mergedFederationDirectiveInSupergraph.get(inaccessibleSpec.inaccessibleDirectiveSpec.name);
        const isInaccessible = inaccessibleInSupergraph && value.hasAppliedDirective(inaccessibleInSupergraph);
        if (!isInaccessible && position !== 'Output' && sources.some((source) => source && !source.value(value.name))) {
            if (position === 'Both') {
                const inputExample = examples.Input;
                const outputExample = examples.Output;
                this.reportMismatchErrorWithSpecifics({
                    code: federation_internals_1.ERRORS.ENUM_VALUE_MISMATCH,
                    message: `Enum type "${dest}" is used as both input type (for example, as type of "${inputExample.coordinate}") and output type (for example, as type of "${outputExample.coordinate}"), but value "${value}" is not defined in all the subgraphs defining "${dest}": `,
                    mismatchedElement: dest,
                    subgraphElements: sources,
                    mismatchAccessor: (type) => (type === null || type === void 0 ? void 0 : type.value(value.name)) ? 'yes' : 'no',
                    supergraphElementPrinter: (_, subgraphs) => `"${value}" is defined in ${subgraphs}`,
                    otherElementsPrinter: (_, subgraphs) => ` but not in ${subgraphs}`,
                    extraNodes: (0, federation_internals_1.sourceASTs)(inputExample, outputExample),
                });
            }
            else {
                this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_ENUM_VALUE_FOR_INPUT_ENUM, `Value "${value}" of enum type "${dest}" will not be part of the supergraph as it is not defined in all the subgraphs defining "${dest}": `, dest, sources, (type) => type.value(value.name) ? 'yes' : 'no', (_, subgraphs) => `"${value}" is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`);
                value.remove();
            }
        }
        else if (position === 'Output') {
            this.hintOnInconsistentOutputEnumValue(sources, dest, value.name);
        }
    }
    hintOnInconsistentOutputEnumValue(sources, dest, valueName) {
        for (const source of sources) {
            if (source && !source.value(valueName)) {
                this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_ENUM_VALUE_FOR_OUTPUT_ENUM, `Value "${valueName}" of enum type "${dest}" has been added to the supergraph but is only defined in a subset of the subgraphs defining "${dest}": `, dest, sources, type => type.value(valueName) ? 'yes' : 'no', (_, subgraphs) => `"${valueName}" is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`);
                return;
            }
        }
    }
    mergeInput(sources, dest) {
        const inaccessibleInSupergraph = this.mergedFederationDirectiveInSupergraph.get(inaccessibleSpec.inaccessibleDirectiveSpec.name);
        this.addFieldsShallow(sources, dest);
        for (const destField of dest.fields()) {
            const name = destField.name;
            this.mergeInputField(sources.map(t => t === null || t === void 0 ? void 0 : t.field(name)), destField);
            const isInaccessible = inaccessibleInSupergraph && destField.hasAppliedDirective(inaccessibleInSupergraph);
            if (!isInaccessible && sources.some((source) => source && !source.field(name))) {
                const nonOptionalSources = sources.map((s, i) => { var _a; return s && ((_a = s.field(name)) === null || _a === void 0 ? void 0 : _a.isRequired()) ? this.names[i] : undefined; }).filter((s) => !!s);
                if (nonOptionalSources.length > 0) {
                    const nonOptionalSubgraphs = (0, federation_internals_1.printSubgraphNames)(nonOptionalSources);
                    const missingSources = (0, federation_internals_1.printSubgraphNames)(sources.map((s, i) => s && !s.field(name) ? this.names[i] : undefined).filter((s) => !!s));
                    this.errors.push(federation_internals_1.ERRORS.REQUIRED_INPUT_FIELD_MISSING_IN_SOME_SUBGRAPH.err({
                        message: `Input object field "${destField.coordinate}" is required in some subgraphs but does not appear in all subgraphs: it is required in ${nonOptionalSubgraphs} but does not appear in ${missingSources}`,
                        nodes: (0, federation_internals_1.sourceASTs)(...sources.map((s) => s === null || s === void 0 ? void 0 : s.field(name))),
                    }));
                }
                else {
                    this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_INPUT_OBJECT_FIELD, `Input object field "${destField.name}" will not be added to "${dest}" in the supergraph as it does not appear in all subgraphs: `, destField, sources.map((s) => s ? s.field(name) : undefined), _ => 'yes', (_, subgraphs) => `it is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`, undefined, true);
                }
                destField.remove();
            }
        }
        if (!dest.hasFields()) {
            this.errors.push(federation_internals_1.ERRORS.EMPTY_MERGED_INPUT_TYPE.err({
                message: `None of the fields of input object type "${dest}" are consistently defined in all the subgraphs defining that type. As only fields common to all subgraphs are merged, this would result in an empty type.`,
                nodes: (0, federation_internals_1.sourceASTs)(...sources),
            }));
        }
    }
    mergeInputField(sources, dest) {
        this.mergeDescription(sources, dest);
        this.mergeAppliedDirectives(sources, dest);
        const allTypesEqual = this.mergeTypeReference(sources, dest, true);
        const mergeContext = new FieldMergeContext(sources);
        this.addJoinField({ sources, dest, allTypesEqual, mergeContext });
        this.mergeDefaultValue(sources, dest, 'Input field');
    }
    mergeDirectiveDefinition(sources, dest) {
        this.mergeDescription(sources, dest);
        if (sources.some((s) => s && this.isMergedDirective(s))) {
            this.mergeExecutableDirectiveDefinition(sources, dest);
        }
    }
    mergeExecutableDirectiveDefinition(sources, dest) {
        let repeatable = undefined;
        let inconsistentRepeatable = false;
        let locations = undefined;
        let inconsistentLocations = false;
        for (const source of sources) {
            if (!source) {
                const usages = dest.remove();
                (0, federation_internals_1.assert)(usages.length === 0, () => `Found usages of executable directive ${dest}: ${usages}`);
                this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_EXECUTABLE_DIRECTIVE_PRESENCE, `Executable directive "${dest}" will not be part of the supergraph as it does not appear in all subgraphs: `, dest, sources, _ => 'yes', (_, subgraphs) => `it is defined in ${subgraphs}`, (_, subgraphs) => ` but not in ${subgraphs}`, undefined, true);
                return;
            }
            if (repeatable === undefined) {
                repeatable = source.repeatable;
            }
            else if (repeatable !== source.repeatable) {
                inconsistentRepeatable = true;
                repeatable = false;
            }
            const sourceLocations = this.extractExecutableLocations(source);
            if (!locations) {
                locations = sourceLocations;
            }
            else {
                if (!(0, federation_internals_1.arrayEquals)(locations, sourceLocations)) {
                    inconsistentLocations = true;
                }
                locations = locations.filter(loc => sourceLocations.includes(loc));
                if (locations.length === 0) {
                    const usages = dest.remove();
                    (0, federation_internals_1.assert)(usages.length === 0, () => `Found usages of executable directive ${dest}: ${usages}`);
                    this.reportMismatchHint(hints_1.HINTS.NO_EXECUTABLE_DIRECTIVE_LOCATIONS_INTERSECTION, `Executable directive "${dest}" has no location that is common to all subgraphs: `, dest, sources, directive => locationString(this.extractExecutableLocations(directive)), () => `it will not appear in the supergraph as there no intersection between `, (locs, subgraphs) => `${locs} in ${subgraphs}`);
                    return;
                }
            }
        }
        dest.repeatable = repeatable;
        dest.addLocations(...locations);
        if (inconsistentRepeatable) {
            this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_EXECUTABLE_DIRECTIVE_REPEATABLE, `Executable directive "${dest}" will not be marked repeatable in the supergraph as it is inconsistently marked repeatable in subgraphs: `, dest, sources, directive => directive.repeatable ? 'yes' : 'no', (_, subgraphs) => `it is not repeatable in ${subgraphs}`, (_, subgraphs) => ` but is repeatable in ${subgraphs}`);
        }
        if (inconsistentLocations) {
            this.reportMismatchHint(hints_1.HINTS.INCONSISTENT_EXECUTABLE_DIRECTIVE_LOCATIONS, `Executable directive "${dest}" has inconsistent locations across subgraphs `, dest, sources, directive => locationString(this.extractExecutableLocations(directive)), (locs, subgraphs) => `and will use ${locs} (intersection of all subgraphs) in the supergraph, but has: ${subgraphs ? `${locs} in ${subgraphs} and ` : ''}`, (locs, subgraphs) => `${locs} in ${subgraphs}`);
        }
        this.addArgumentsShallow(sources, dest);
        for (const destArg of dest.arguments()) {
            const subgraphArgs = sources.map(f => f === null || f === void 0 ? void 0 : f.argument(destArg.name));
            this.mergeArgument(subgraphArgs, destArg);
        }
    }
    extractExecutableLocations(source) {
        return this.filterExecutableDirectiveLocations(source).concat().sort();
    }
    filterExecutableDirectiveLocations(source) {
        return source.locations.filter(loc => federation_internals_1.executableDirectiveLocations.includes(loc));
    }
    mergeAppliedDirectives(sources, dest) {
        const names = this.gatherAppliedDirectiveNames(sources);
        for (const name of names) {
            this.mergeAppliedDirective(name, sources, dest);
        }
    }
    gatherAppliedDirectiveNames(sources) {
        const names = new Set();
        for (const source of sources) {
            if (source) {
                for (const directive of source.appliedDirectives) {
                    if (this.isMergedDirective(directive)) {
                        names.add(directive.name);
                    }
                }
            }
        }
        return names;
    }
    mergeAppliedDirective(name, sources, dest) {
        var _a, _b;
        let perSource = [];
        for (const source of sources) {
            if (!source) {
                continue;
            }
            const directives = source.appliedDirectivesOf(name);
            if (directives.length) {
                perSource.push(directives);
            }
        }
        while (perSource.length > 0) {
            const directive = this.pickNextDirective(perSource);
            if (!((_a = directive.definition) === null || _a === void 0 ? void 0 : _a.repeatable) && dest.hasAppliedDirective(directive.name)) {
                this.reportMismatchError(federation_internals_1.ERRORS.NON_REPEATABLE_DIRECTIVE_ARGUMENTS_MISMATCH, `Non-repeatable directive @${directive.name} is applied to "${(_b = dest['coordinate']) !== null && _b !== void 0 ? _b : dest}" in multiple subgraphs but with incompatible arguments: it uses `, dest, sources, (elt) => {
                    var _a;
                    const args = (_a = elt.appliedDirectivesOf(directive.name).pop()) === null || _a === void 0 ? void 0 : _a.arguments();
                    return args === undefined
                        ? undefined
                        : Object.values(args).length === 0 ? 'no arguments' : (`arguments ${(0, federation_internals_1.valueToString)(args)}`);
                });
                perSource = perSource
                    .map((ds) => ds.filter((d) => d.name !== directive.name))
                    .filter((ds) => ds.length > 0);
            }
            else {
                dest.applyDirective(directive.name, directive.arguments(false));
                perSource = this.removeDirective(directive, perSource);
            }
        }
    }
    pickNextDirective(directives) {
        return directives[0][0];
    }
    removeDirective(toRemove, directives) {
        return directives
            .map(ds => ds.filter(d => !(0, federation_internals_1.valueEquals)(toRemove.arguments(), d.arguments()))).
            filter(ds => ds.length);
    }
    mergeSchemaDefinition(sources, dest) {
        this.mergeDescription(sources, dest);
        this.mergeAppliedDirectives(sources, dest);
        for (const rootKind of federation_internals_1.allSchemaRootKinds) {
            let rootType;
            let isIncompatible = false;
            for (const sourceType of sources.map(s => filteredRoot(s, rootKind))) {
                if (!sourceType) {
                    continue;
                }
                if (rootType) {
                    isIncompatible = isIncompatible || rootType !== sourceType.name;
                }
                else {
                    rootType = sourceType.name;
                }
            }
            if (!rootType) {
                continue;
            }
            dest.setRoot(rootKind, rootType);
            (0, federation_internals_1.assert)(!isIncompatible, () => `Should not have incompatible root type for ${rootKind}`);
        }
    }
    filterSubgraphs(predicate) {
        return this.subgraphsSchema.map((s, i) => predicate(s) ? this.names[i] : undefined).filter(n => n !== undefined);
    }
    subgraphByName(name) {
        return this.subgraphsSchema[this.names.indexOf(name)];
    }
    postMergeValidations() {
        for (const type of this.merged.types()) {
            if (!(0, federation_internals_1.isObjectType)(type) && !(0, federation_internals_1.isInterfaceType)(type)) {
                continue;
            }
            for (const itf of type.interfaces()) {
                for (const itfField of itf.fields()) {
                    const field = type.field(itfField.name);
                    if (!field) {
                        const subgraphsWithTheField = this.filterSubgraphs(s => { var _a; return ((_a = s.typeOfKind(itf.name, 'InterfaceType')) === null || _a === void 0 ? void 0 : _a.field(itfField.name)) !== undefined; });
                        const subgraphsWithTypeImplementingItf = this.filterSubgraphs(s => {
                            const typeInSubgraph = s.type(type.name);
                            return typeInSubgraph !== undefined && typeInSubgraph.implementsInterface(itf.name);
                        });
                        this.errors.push(federation_internals_1.ERRORS.INTERFACE_FIELD_NO_IMPLEM.err({
                            message: `Interface field "${itfField.coordinate}" is declared in ${(0, federation_internals_1.printSubgraphNames)(subgraphsWithTheField)} but type "${type}", `
                                + `which implements "${itf}" only in ${(0, federation_internals_1.printSubgraphNames)(subgraphsWithTypeImplementingItf)} does not have field "${itfField.name}".`,
                            nodes: (0, federation_internals_1.sourceASTs)(...subgraphsWithTheField.map(s => { var _a; return (_a = this.subgraphByName(s).typeOfKind(itf.name, 'InterfaceType')) === null || _a === void 0 ? void 0 : _a.field(itfField.name); }), ...subgraphsWithTypeImplementingItf.map(s => this.subgraphByName(s).type(type.name)))
                        }));
                        continue;
                    }
                }
            }
        }
    }
    updateInaccessibleErrorsWithLinkToSubgraphs(errors) {
        function isRelevantSubgraphReferencer(subgraphReferencer, err, supergraphElements, hasInaccessibleElements) {
            switch ((0, federation_internals_1.errorCode)(err)) {
                case federation_internals_1.ERRORS.REFERENCED_INACCESSIBLE.code: {
                    if (!((subgraphReferencer instanceof federation_internals_1.FieldDefinition) ||
                        (subgraphReferencer instanceof federation_internals_1.ArgumentDefinition) ||
                        (subgraphReferencer instanceof federation_internals_1.InputFieldDefinition))) {
                        return false;
                    }
                    const subgraphType = subgraphReferencer.type;
                    const supergraphType = supergraphElements[0];
                    return !!subgraphType &&
                        (0, federation_internals_1.baseType)(subgraphType).name === supergraphType;
                }
                case federation_internals_1.ERRORS.DEFAULT_VALUE_USES_INACCESSIBLE.code: {
                    return true;
                }
                case federation_internals_1.ERRORS.REQUIRED_INACCESSIBLE.code: {
                    if (!((subgraphReferencer instanceof federation_internals_1.ArgumentDefinition) ||
                        (subgraphReferencer instanceof federation_internals_1.InputFieldDefinition))) {
                        return false;
                    }
                    const subgraphType = subgraphReferencer.type;
                    return (subgraphType && (0, federation_internals_1.isNonNullType)(subgraphType)) ||
                        subgraphReferencer.defaultValue === undefined;
                }
                case federation_internals_1.ERRORS.IMPLEMENTED_BY_INACCESSIBLE.code: {
                    return true;
                }
                case federation_internals_1.ERRORS.DISALLOWED_INACCESSIBLE.code: {
                    return hasInaccessibleElements;
                }
                case federation_internals_1.ERRORS.ONLY_INACCESSIBLE_CHILDREN.code: {
                    return hasInaccessibleElements;
                }
                default: {
                    return false;
                }
            }
        }
        return errors.map((err) => {
            const elements = err.extensions['inaccessible_elements'];
            if (!Array.isArray(elements))
                return err;
            const errorNodes = [];
            const subgraphHasInaccessibleElements = [];
            for (const coordinate of elements) {
                if (typeof coordinate !== 'string')
                    continue;
                errorNodes.push(...(0, federation_internals_1.sourceASTs)(...this.subgraphsSchema.flatMap((subgraphSchema, subgraphIndex) => {
                    const subgraphElement = subgraphSchema.elementByCoordinate(coordinate);
                    if (subgraphElement) {
                        const inaccessibleDirective = (0, federation_internals_1.federationMetadata)(subgraphSchema).inaccessibleDirective();
                        if (subgraphElement.hasAppliedDirective(inaccessibleDirective)) {
                            subgraphHasInaccessibleElements[subgraphIndex] = true;
                            return [subgraphElement];
                        }
                    }
                    return [];
                })));
            }
            const referencers = err.extensions['inaccessible_referencers'];
            if (Array.isArray(referencers)) {
                for (const coordinate of referencers) {
                    if (typeof coordinate !== 'string')
                        continue;
                    errorNodes.push(...(0, federation_internals_1.sourceASTs)(...this.subgraphsSchema.flatMap((subgraphSchema, subgraphIndex) => {
                        const subgraphReferencer = subgraphSchema.elementByCoordinate(coordinate);
                        if (subgraphReferencer &&
                            isRelevantSubgraphReferencer(subgraphReferencer, err, elements, subgraphHasInaccessibleElements[subgraphIndex])) {
                            return [subgraphReferencer];
                        }
                        return [];
                    })));
                }
            }
            return errorNodes.length > 0
                ? (0, federation_internals_1.withModifiedErrorNodes)(err, errorNodes)
                : err;
        });
    }
}
//# sourceMappingURL=merge.js.map