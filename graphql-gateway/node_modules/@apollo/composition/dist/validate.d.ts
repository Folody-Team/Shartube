import { Operation, Schema, SchemaRootKind } from "@apollo/federation-internals";
import { Edge, QueryGraph, RootPath, Transition, ConditionResolver, TransitionPathWithLazyIndirectPaths, RootVertex } from "@apollo/query-graphs";
export declare class ValidationError extends Error {
    readonly supergraphUnsatisfiablePath: RootPath<Transition>;
    readonly subgraphsPaths: RootPath<Transition>[];
    readonly witness: Operation;
    constructor(message: string, supergraphUnsatisfiablePath: RootPath<Transition>, subgraphsPaths: RootPath<Transition>[], witness: Operation);
}
export declare function validateGraphComposition(supergraph: QueryGraph, subgraphs: QueryGraph): {
    errors?: ValidationError[];
};
export declare function computeSubgraphPaths(supergraphPath: RootPath<Transition>, subgraphs: QueryGraph): {
    traversal?: ValidationState;
    isComplete?: boolean;
    error?: ValidationError;
};
export declare class ValidationState {
    readonly supergraphPath: RootPath<Transition>;
    readonly subgraphPaths: TransitionPathWithLazyIndirectPaths<RootVertex>[];
    constructor(supergraphPath: RootPath<Transition>, subgraphPaths: TransitionPathWithLazyIndirectPaths<RootVertex>[]);
    static initial({ supergraph, kind, subgraphs, conditionResolver, }: {
        supergraph: QueryGraph;
        kind: SchemaRootKind;
        subgraphs: QueryGraph;
        conditionResolver: ConditionValidationResolver;
    }): ValidationState;
    validateTransition(supergraphEdge: Edge): ValidationState | undefined | ValidationError;
    currentSubgraphs(): string[];
    toString(): string;
}
declare class ConditionValidationResolver {
    private readonly supergraphSchema;
    private readonly federatedQueryGraph;
    readonly resolver: ConditionResolver;
    constructor(supergraphSchema: Schema, federatedQueryGraph: QueryGraph);
    private validateConditions;
    private advanceState;
}
export {};
//# sourceMappingURL=validate.d.ts.map