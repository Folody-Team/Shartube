import { ASTNode, GraphQLError, StringValueNode } from "graphql";
import { CoreFeature, Directive, DirectiveDefinition, EnumType, NamedType, ScalarType, Schema, SchemaDefinition } from "./definitions";
import { DirectiveSpecification, TypeSpecification } from "./directiveAndTypeSpecification";
export declare const coreIdentity = "https://specs.apollo.dev/core";
export declare const linkIdentity = "https://specs.apollo.dev/link";
export declare const linkDirectiveDefaultName = "link";
export declare const ErrCoreCheckFailed: (causes: Error[]) => import("@apollo/core-schema/dist/error").GraphQLErrorExt<"CheckFailed"> & {
    message: string;
    causes: Error[];
};
export declare const corePurposes: ("SECURITY" | "EXECUTION")[];
export declare type CorePurpose = typeof corePurposes[number];
export declare abstract class FeatureDefinition {
    readonly url: FeatureUrl;
    constructor(url: FeatureUrl | string);
    get identity(): string;
    get version(): FeatureVersion;
    isSpecType(type: NamedType): boolean;
    isSpecDirective(directive: DirectiveDefinition): boolean;
    abstract addElementsToSchema(schema: Schema): GraphQLError[];
    abstract allElementNames(): string[];
    protected nameInSchema(schema: Schema): string | undefined;
    protected directiveNameInSchema(schema: Schema, directiveName: string): string | undefined;
    protected typeNameInSchema(schema: Schema, typeName: string): string | undefined;
    protected rootDirective<TApplicationArgs extends {
        [key: string]: any;
    }>(schema: Schema): DirectiveDefinition<TApplicationArgs> | undefined;
    protected directive<TApplicationArgs extends {
        [key: string]: any;
    }>(schema: Schema, elementName: string): DirectiveDefinition<TApplicationArgs> | undefined;
    protected type<T extends NamedType>(schema: Schema, elementName: string): T | undefined;
    protected addRootDirective(schema: Schema): DirectiveDefinition;
    protected addDirective(schema: Schema, name: string): DirectiveDefinition;
    protected addDirectiveSpec(schema: Schema, spec: DirectiveSpecification): GraphQLError[];
    protected addTypeSpec(schema: Schema, spec: TypeSpecification): GraphQLError[];
    protected addScalarType(schema: Schema, name: string): ScalarType;
    protected addEnumType(schema: Schema, name: string): EnumType;
    protected featureInSchema(schema: Schema): CoreFeature | undefined;
    get defaultCorePurpose(): CorePurpose | undefined;
    toString(): string;
}
export declare type CoreDirectiveArgs = {
    url: undefined;
    feature: string;
    as?: string;
    for?: string;
};
export declare type LinkDirectiveArgs = {
    url: string;
    feature: undefined;
    as?: string;
    for?: string;
    import?: (string | CoreImport)[];
};
export declare type CoreOrLinkDirectiveArgs = CoreDirectiveArgs | LinkDirectiveArgs;
export declare type CoreImport = {
    name: string;
    as?: string;
};
export declare function extractCoreFeatureImports(url: FeatureUrl, directive: Directive<SchemaDefinition, CoreOrLinkDirectiveArgs>): CoreImport[];
export declare function isCoreSpecDirectiveApplication(directive: Directive<SchemaDefinition, any>): directive is Directive<SchemaDefinition, CoreOrLinkDirectiveArgs>;
export declare class CoreSpecDefinition extends FeatureDefinition {
    private readonly directiveDefinitionSpec;
    constructor(version: FeatureVersion, identity?: string, name?: string);
    private createDefinitionArgumentSpecifications;
    addElementsToSchema(_: Schema): GraphQLError[];
    addToSchema(schema: Schema, alias?: string): GraphQLError[];
    addDefinitionsToSchema(schema: Schema, as?: string): GraphQLError[];
    allElementNames(): string[];
    private supportPurposes;
    private supportImport;
    private extractFeature;
    coreDirective(schema: Schema): DirectiveDefinition<CoreOrLinkDirectiveArgs>;
    coreVersion(schema: Schema): FeatureVersion;
    applyFeatureToSchema(schema: Schema, feature: FeatureDefinition, as?: string, purpose?: CorePurpose): GraphQLError[];
    extractFeatureUrl(args: CoreOrLinkDirectiveArgs): FeatureUrl;
    urlArgName(): 'feature' | 'url';
}
export declare class FeatureDefinitions<T extends FeatureDefinition = FeatureDefinition> {
    readonly identity: string;
    private readonly _definitions;
    constructor(identity: string);
    add(definition: T): FeatureDefinitions<T>;
    find(requested: FeatureVersion): T | undefined;
    versions(): FeatureVersion[];
    latest(): T;
}
export declare class FeatureVersion {
    readonly major: number;
    readonly minor: number;
    constructor(major: number, minor: number);
    static parse(input: string): FeatureVersion;
    satisfies(required: FeatureVersion): boolean;
    get series(): string;
    compareTo(other: FeatureVersion): number;
    strictlyGreaterThan(version: FeatureVersion): boolean;
    toString(): string;
    equals(other: FeatureVersion): boolean;
    private static VERSION_RE;
}
export declare class FeatureUrl {
    readonly identity: string;
    readonly name: string;
    readonly version: FeatureVersion;
    readonly element?: string | undefined;
    constructor(identity: string, name: string, version: FeatureVersion, element?: string | undefined);
    static parse(input: string, node?: ASTNode): FeatureUrl;
    static decode(node: StringValueNode): FeatureUrl;
    satisfies(requested: FeatureUrl): boolean;
    equals(other: FeatureUrl): boolean;
    get url(): string;
    get isDirective(): boolean | undefined;
    get elementName(): string | undefined;
    get base(): FeatureUrl;
    toString(): string;
}
export declare function findCoreSpecVersion(featureUrl: FeatureUrl): CoreSpecDefinition | undefined;
export declare const CORE_VERSIONS: FeatureDefinitions<CoreSpecDefinition>;
export declare const LINK_VERSIONS: FeatureDefinitions<CoreSpecDefinition>;
export declare function removeAllCoreFeatures(schema: Schema): void;
//# sourceMappingURL=coreSpec.d.ts.map