"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FEDERATION_VERSIONS = exports.FederationSpecDefinition = exports.FEDERATION_SPEC_TYPES = exports.ALL_FEDERATION_DIRECTIVES_DEFAULT_NAMES = exports.FEDERATION2_SPEC_DIRECTIVES = exports.FEDERATION2_ONLY_SPEC_DIRECTIVES = exports.overrideDirectiveSpec = exports.shareableDirectiveSpec = exports.providesDirectiveSpec = exports.requiresDirectiveSpec = exports.externalDirectiveSpec = exports.extendsDirectiveSpec = exports.keyDirectiveSpec = exports.fieldSetTypeSpec = exports.federationIdentity = void 0;
const definitions_1 = require("./definitions");
const coreSpec_1 = require("./coreSpec");
const directiveAndTypeSpecification_1 = require("./directiveAndTypeSpecification");
const graphql_1 = require("graphql");
const utils_1 = require("./utils");
const tagSpec_1 = require("./tagSpec");
const federation_1 = require("./federation");
const knownCoreFeatures_1 = require("./knownCoreFeatures");
const inaccessibleSpec_1 = require("./inaccessibleSpec");
exports.federationIdentity = 'https://specs.apollo.dev/federation';
exports.fieldSetTypeSpec = (0, directiveAndTypeSpecification_1.createScalarTypeSpecification)({ name: 'FieldSet' });
exports.keyDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'key',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
    repeatable: true,
    argumentFct: (schema) => ({
        args: [
            fieldsArgument(schema),
            { name: 'resolvable', type: schema.booleanType(), defaultValue: true },
        ],
        errors: [],
    }),
});
exports.extendsDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'extends',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
});
exports.externalDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'external',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [{ name: 'reason', type: schema.stringType() }],
        errors: [],
    }),
});
exports.requiresDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'requires',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [fieldsArgument(schema)],
        errors: [],
    }),
});
exports.providesDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'provides',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [fieldsArgument(schema)],
        errors: [],
    }),
});
exports.shareableDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'shareable',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.FIELD_DEFINITION],
});
exports.overrideDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: 'override',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [{ name: 'from', type: new definitions_1.NonNullType(schema.stringType()) }],
        errors: [],
    }),
});
function fieldsArgument(schema) {
    return { name: 'fields', type: fieldSetType(schema) };
}
function fieldSetType(schema) {
    const metadata = (0, federation_1.federationMetadata)(schema);
    (0, utils_1.assert)(metadata, `The schema is not a federation subgraph`);
    return new definitions_1.NonNullType(metadata.fieldSetType());
}
exports.FEDERATION2_ONLY_SPEC_DIRECTIVES = [
    exports.shareableDirectiveSpec,
    inaccessibleSpec_1.INACCESSIBLE_VERSIONS.latest().inaccessibleDirectiveSpec,
    exports.overrideDirectiveSpec,
];
exports.FEDERATION2_SPEC_DIRECTIVES = [
    exports.keyDirectiveSpec,
    exports.requiresDirectiveSpec,
    exports.providesDirectiveSpec,
    exports.externalDirectiveSpec,
    tagSpec_1.TAG_VERSIONS.latest().tagDirectiveSpec,
    exports.extendsDirectiveSpec,
    ...exports.FEDERATION2_ONLY_SPEC_DIRECTIVES,
];
exports.ALL_FEDERATION_DIRECTIVES_DEFAULT_NAMES = exports.FEDERATION2_SPEC_DIRECTIVES.map((spec) => spec.name);
exports.FEDERATION_SPEC_TYPES = [
    exports.fieldSetTypeSpec,
];
class FederationSpecDefinition extends coreSpec_1.FeatureDefinition {
    constructor(version) {
        super(new coreSpec_1.FeatureUrl(exports.federationIdentity, 'federation', version));
    }
    addElementsToSchema(schema) {
        const feature = this.featureInSchema(schema);
        (0, utils_1.assert)(feature, 'The federation specification should have been added to the schema before this is called');
        let errors = [];
        errors = errors.concat(this.addTypeSpec(schema, exports.fieldSetTypeSpec));
        for (const directive of exports.FEDERATION2_SPEC_DIRECTIVES) {
            errors = errors.concat(this.addDirectiveSpec(schema, directive));
        }
        return errors;
    }
    allElementNames() {
        return exports.FEDERATION2_SPEC_DIRECTIVES.map((spec) => `@${spec.name}`).concat([
            exports.fieldSetTypeSpec.name,
        ]);
    }
}
exports.FederationSpecDefinition = FederationSpecDefinition;
exports.FEDERATION_VERSIONS = new coreSpec_1.FeatureDefinitions(exports.federationIdentity)
    .add(new FederationSpecDefinition(new coreSpec_1.FeatureVersion(2, 0)));
(0, knownCoreFeatures_1.registerKnownFeature)(exports.FEDERATION_VERSIONS);
//# sourceMappingURL=federationSpec.js.map