"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeInactiveProvidesAndRequires = exports.addSubgraphToError = exports.addSubgraphToASTNode = exports.Subgraph = exports.FEDERATION_OPERATION_FIELDS = exports.entitiesFieldName = exports.serviceFieldName = exports.FEDERATION_OPERATION_TYPES = exports.entityTypeSpec = exports.serviceTypeSpec = exports.anyTypeSpec = exports.Subgraphs = exports.subgraphsFromServiceList = exports.collectTargetFields = exports.parseFieldSetArgument = exports.newEmptyFederation2Schema = exports.buildSubgraph = exports.isEntityType = exports.isFederationField = exports.isFederationSubgraphSchema = exports.federationMetadata = exports.printSubgraphNames = exports.asFed2SubgraphDocument = exports.FEDERATION2_LINK_WTH_FULL_IMPORTS = exports.setSchemaAsFed2Subgraph = exports.FederationBlueprint = exports.FederationMetadata = exports.collectUsedFields = exports.FEDERATION_UNNAMED_SUBGRAPH_NAME = exports.FEDERATION_RESERVED_SUBGRAPH_NAME = void 0;
const definitions_1 = require("./definitions");
const utils_1 = require("./utils");
const specifiedRules_1 = require("graphql/validation/specifiedRules");
const graphql_1 = require("graphql");
const KnownTypeNamesInFederationRule_1 = require("./validation/KnownTypeNamesInFederationRule");
const buildSchema_1 = require("./buildSchema");
const operations_1 = require("./operations");
const tagSpec_1 = require("./tagSpec");
const inaccessibleSpec_1 = require("./inaccessibleSpec");
const error_1 = require("./error");
const precompute_1 = require("./precompute");
const coreSpec_1 = require("./coreSpec");
const federationSpec_1 = require("./federationSpec");
const print_1 = require("./print");
const directiveAndTypeSpecification_1 = require("./directiveAndTypeSpecification");
const suggestions_1 = require("./suggestions");
const linkSpec = coreSpec_1.LINK_VERSIONS.latest();
const tagSpec = tagSpec_1.TAG_VERSIONS.latest();
const inaccessibleSpec = inaccessibleSpec_1.INACCESSIBLE_VERSIONS.latest();
const federationSpec = federationSpec_1.FEDERATION_VERSIONS.latest();
exports.FEDERATION_RESERVED_SUBGRAPH_NAME = '_';
exports.FEDERATION_UNNAMED_SUBGRAPH_NAME = '<unnamed>';
const FEDERATION_OMITTED_VALIDATION_RULES = [
    graphql_1.PossibleTypeExtensionsRule,
    graphql_1.KnownTypeNamesRule
];
const FEDERATION_SPECIFIC_VALIDATION_RULES = [
    KnownTypeNamesInFederationRule_1.KnownTypeNamesInFederationRule
];
const FEDERATION_VALIDATION_RULES = specifiedRules_1.specifiedSDLRules.filter(rule => !FEDERATION_OMITTED_VALIDATION_RULES.includes(rule)).concat(FEDERATION_SPECIFIC_VALIDATION_RULES);
function validateFieldSetSelections(directiveName, selectionSet, hasExternalInParents, federationMetadata, allowOnNonExternalLeafFields) {
    for (const selection of selectionSet.selections()) {
        if (selection.kind === 'FieldSelection') {
            const field = selection.element().definition;
            const isExternal = federationMetadata.isFieldExternal(field);
            if (field.hasArguments()) {
                throw error_1.ERROR_CATEGORIES.FIELDS_HAS_ARGS.get(directiveName).err({
                    message: `field ${field.coordinate} cannot be included because it has arguments (fields with argument are not allowed in @${directiveName})`,
                    nodes: field.sourceAST
                });
            }
            const mustBeExternal = !selection.selectionSet && !allowOnNonExternalLeafFields && !hasExternalInParents;
            if (!isExternal && mustBeExternal) {
                const errorCode = error_1.ERROR_CATEGORIES.DIRECTIVE_FIELDS_MISSING_EXTERNAL.get(directiveName);
                if (federationMetadata.isFieldFakeExternal(field)) {
                    throw errorCode.err({
                        message: `field "${field.coordinate}" should not be part of a @${directiveName} since it is already "effectively" provided by this subgraph `
                            + `(while it is marked @${federationSpec_1.externalDirectiveSpec.name}, it is a @${federationSpec_1.keyDirectiveSpec.name} field of an extension type, which are not internally considered external for historical/backward compatibility reasons)`,
                        nodes: field.sourceAST
                    });
                }
                else {
                    throw errorCode.err({
                        message: `field "${field.coordinate}" should not be part of a @${directiveName} since it is already provided by this subgraph (it is not marked @${federationSpec_1.externalDirectiveSpec.name})`,
                        nodes: field.sourceAST
                    });
                }
            }
            if (selection.selectionSet) {
                let newHasExternalInParents = hasExternalInParents || isExternal;
                const parentType = field.parent;
                if (!newHasExternalInParents && (0, definitions_1.isInterfaceType)(parentType)) {
                    for (const implem of parentType.possibleRuntimeTypes()) {
                        const fieldInImplem = implem.field(field.name);
                        if (fieldInImplem && federationMetadata.isFieldExternal(fieldInImplem)) {
                            newHasExternalInParents = true;
                            break;
                        }
                    }
                }
                validateFieldSetSelections(directiveName, selection.selectionSet, newHasExternalInParents, federationMetadata, allowOnNonExternalLeafFields);
            }
        }
        else {
            validateFieldSetSelections(directiveName, selection.selectionSet, hasExternalInParents, federationMetadata, allowOnNonExternalLeafFields);
        }
    }
}
function validateFieldSet(type, directive, federationMetadata, allowOnNonExternalLeafFields, onFields) {
    var _a;
    try {
        const fieldAccessor = onFields
            ? (type, fieldName) => {
                const field = type.field(fieldName);
                if (field) {
                    onFields(field);
                }
                return field;
            }
            : undefined;
        const selectionSet = parseFieldSetArgument({ parentType: type, directive, fieldAccessor });
        try {
            validateFieldSetSelections(directive.name, selectionSet, false, federationMetadata, allowOnNonExternalLeafFields);
            return undefined;
        }
        catch (e) {
            if (!(e instanceof graphql_1.GraphQLError)) {
                throw e;
            }
            const nodes = (0, definitions_1.sourceASTs)(directive);
            if (e.nodes) {
                nodes.push(...e.nodes);
            }
            const codeDef = (_a = (0, error_1.errorCodeDef)(e)) !== null && _a !== void 0 ? _a : error_1.ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS.get(directive.name);
            return codeDef.err({
                message: `${fieldSetErrorDescriptor(directive)}: ${e.message.trim()}`,
                nodes,
                originalError: e,
            });
        }
    }
    catch (e) {
        if (e instanceof graphql_1.GraphQLError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
function fieldSetErrorDescriptor(directive) {
    return `On ${fieldSetTargetDescription(directive)}, for ${directiveStrUsingASTIfPossible(directive)}`;
}
function directiveStrUsingASTIfPossible(directive) {
    return directive.sourceAST ? (0, graphql_1.print)(directive.sourceAST) : directive.toString();
}
function fieldSetTargetDescription(directive) {
    var _a;
    const targetKind = directive.parent instanceof definitions_1.FieldDefinition ? "field" : "type";
    return `${targetKind} "${(_a = directive.parent) === null || _a === void 0 ? void 0 : _a.coordinate}"`;
}
function validateAllFieldSet(definition, targetTypeExtractor, errorCollector, federationMetadata, isOnParentType, allowOnNonExternalLeafFields, onFields) {
    for (const application of definition.applications()) {
        const elt = application.parent;
        const type = targetTypeExtractor(elt);
        const parentType = isOnParentType ? type : elt.parent;
        if ((0, definitions_1.isInterfaceType)(parentType)) {
            const code = error_1.ERROR_CATEGORIES.DIRECTIVE_UNSUPPORTED_ON_INTERFACE.get(definition.name);
            errorCollector.push(code.err({
                message: isOnParentType
                    ? `Cannot use ${definition.coordinate} on interface "${parentType.coordinate}": ${definition.coordinate} is not yet supported on interfaces`
                    : `Cannot use ${definition.coordinate} on ${fieldSetTargetDescription(application)} of parent type "${parentType}": ${definition.coordinate} is not yet supported within interfaces`,
                nodes: (0, definitions_1.sourceASTs)(application).concat(isOnParentType ? [] : (0, definitions_1.sourceASTs)(type)),
            }));
        }
        const error = validateFieldSet(type, application, federationMetadata, allowOnNonExternalLeafFields, onFields);
        if (error) {
            errorCollector.push(error);
        }
    }
}
function collectUsedFields(metadata) {
    const usedFields = new Set();
    collectUsedFieldsForDirective(metadata.keyDirective(), type => type, usedFields);
    collectUsedFieldsForDirective(metadata.requiresDirective(), field => field.parent, usedFields);
    collectUsedFieldsForDirective(metadata.providesDirective(), field => {
        const type = (0, definitions_1.baseType)(field.type);
        return (0, definitions_1.isCompositeType)(type) ? type : undefined;
    }, usedFields);
    for (const itfType of metadata.schema.interfaceTypes()) {
        const runtimeTypes = itfType.possibleRuntimeTypes();
        for (const field of itfType.fields()) {
            for (const runtimeType of runtimeTypes) {
                const implemField = runtimeType.field(field.name);
                if (implemField) {
                    usedFields.add(implemField);
                }
            }
        }
    }
    return usedFields;
}
exports.collectUsedFields = collectUsedFields;
function collectUsedFieldsForDirective(definition, targetTypeExtractor, usedFieldDefs) {
    for (const application of definition.applications()) {
        const type = targetTypeExtractor(application.parent);
        if (!type) {
            continue;
        }
        collectTargetFields({
            parentType: type,
            directive: application,
            includeInterfaceFieldsImplementations: true,
            validate: false,
        }).forEach((field) => usedFieldDefs.add(field));
    }
}
function validateAllExternalFieldsUsed(metadata, errorCollector) {
    for (const type of metadata.schema.types()) {
        if (!(0, definitions_1.isObjectType)(type) && !(0, definitions_1.isInterfaceType)(type)) {
            continue;
        }
        for (const field of type.fields()) {
            if (!metadata.isFieldExternal(field) || metadata.isFieldUsed(field)) {
                continue;
            }
            errorCollector.push(error_1.ERRORS.EXTERNAL_UNUSED.err({
                message: `Field "${field.coordinate}" is marked @external but is not used in any federation directive (@key, @provides, @requires) or to satisfy an interface;`
                    + ' the field declaration has no use and should be removed (or the field should not be @external).',
                nodes: field.sourceAST,
            }));
        }
    }
}
function validateNoExternalOnInterfaceFields(metadata, errorCollector) {
    for (const itf of metadata.schema.interfaceTypes()) {
        for (const field of itf.fields()) {
            if (metadata.isFieldExternal(field)) {
                errorCollector.push(error_1.ERRORS.EXTERNAL_ON_INTERFACE.err({
                    message: `Interface type field "${field.coordinate}" is marked @external but @external is not allowed on interface fields (it is nonsensical).`,
                    nodes: field.sourceAST,
                }));
            }
        }
    }
}
function validateInterfaceRuntimeImplementationFieldsTypes(itf, metadata, errorCollector) {
    var _a;
    const requiresDirective = (_a = federationMetadata(itf.schema())) === null || _a === void 0 ? void 0 : _a.requiresDirective();
    (0, utils_1.assert)(requiresDirective, 'Schema should be a federation subgraph, but @requires directive not found');
    const runtimeTypes = itf.possibleRuntimeTypes();
    for (const field of itf.fields()) {
        const withExternalOrRequires = [];
        const typeToImplems = new utils_1.MultiMap();
        const nodes = [];
        for (const type of runtimeTypes) {
            const implemField = type.field(field.name);
            if (!implemField)
                continue;
            if (implemField.sourceAST) {
                nodes.push(implemField.sourceAST);
            }
            if (metadata.isFieldExternal(implemField) || implemField.hasAppliedDirective(requiresDirective)) {
                withExternalOrRequires.push(implemField);
            }
            const returnType = implemField.type;
            typeToImplems.add(returnType.toString(), implemField);
        }
        if (withExternalOrRequires.length > 0 && typeToImplems.size > 1) {
            const typeToImplemsArray = [...typeToImplems.entries()];
            errorCollector.push(error_1.ERRORS.INTERFACE_FIELD_IMPLEM_TYPE_MISMATCH.err({
                message: `Some of the runtime implementations of interface field "${field.coordinate}" are marked @external or have a @require (${withExternalOrRequires.map(printFieldCoordinate)}) so all the implementations should use the same type (a current limitation of federation; see https://github.com/apollographql/federation/issues/1257), but ${formatFieldsToReturnType(typeToImplemsArray[0])} while ${(0, utils_1.joinStrings)(typeToImplemsArray.slice(1).map(formatFieldsToReturnType), ' and ')}.`,
                nodes
            }));
        }
    }
}
const printFieldCoordinate = (f) => `"${f.coordinate}"`;
function formatFieldsToReturnType([type, implems]) {
    return `${(0, utils_1.joinStrings)(implems.map(printFieldCoordinate))} ${implems.length == 1 ? 'has' : 'have'} type "${type}"`;
}
class FederationMetadata {
    constructor(schema) {
        this.schema = schema;
    }
    onInvalidate() {
        this._externalTester = undefined;
        this._sharingPredicate = undefined;
        this._isFed2Schema = undefined;
        this._fieldUsedPredicate = undefined;
    }
    isFed2Schema() {
        if (!this._isFed2Schema) {
            const feature = this.federationFeature();
            this._isFed2Schema = !!feature && feature.url.version.satisfies(new coreSpec_1.FeatureVersion(2, 0));
        }
        return this._isFed2Schema;
    }
    federationFeature() {
        var _a;
        return (_a = this.schema.coreFeatures) === null || _a === void 0 ? void 0 : _a.getByIdentity(federationSpec.identity);
    }
    externalTester() {
        if (!this._externalTester) {
            this._externalTester = new ExternalTester(this.schema);
        }
        return this._externalTester;
    }
    sharingPredicate() {
        if (!this._sharingPredicate) {
            this._sharingPredicate = (0, precompute_1.computeShareables)(this.schema);
        }
        return this._sharingPredicate;
    }
    fieldUsedPredicate() {
        if (!this._fieldUsedPredicate) {
            const usedFields = collectUsedFields(this);
            this._fieldUsedPredicate = (field) => !!usedFields.has(field);
        }
        return this._fieldUsedPredicate;
    }
    isFieldUsed(field) {
        return this.fieldUsedPredicate()(field);
    }
    isFieldExternal(field) {
        return this.externalTester().isExternal(field);
    }
    isFieldPartiallyExternal(field) {
        return this.externalTester().isPartiallyExternal(field);
    }
    isFieldFullyExternal(field) {
        return this.externalTester().isFullyExternal(field);
    }
    isFieldFakeExternal(field) {
        return this.externalTester().isFakeExternal(field);
    }
    selectionSelectsAnyExternalField(selectionSet) {
        return this.externalTester().selectsAnyExternalField(selectionSet);
    }
    isFieldShareable(field) {
        return this.sharingPredicate()(field);
    }
    federationDirectiveNameInSchema(name) {
        if (this.isFed2Schema()) {
            const coreFeatures = this.schema.coreFeatures;
            (0, utils_1.assert)(coreFeatures, 'Schema should be a core schema');
            const federationFeature = coreFeatures.getByIdentity(federationSpec.identity);
            (0, utils_1.assert)(federationFeature, 'Schema should have the federation feature');
            return federationFeature.directiveNameInSchema(name);
        }
        else {
            return name;
        }
    }
    federationTypeNameInSchema(name) {
        if (name.charAt(0) === '_') {
            return name;
        }
        if (this.isFed2Schema()) {
            const coreFeatures = this.schema.coreFeatures;
            (0, utils_1.assert)(coreFeatures, 'Schema should be a core schema');
            const federationFeature = coreFeatures.getByIdentity(federationSpec.identity);
            (0, utils_1.assert)(federationFeature, 'Schema should have the federation feature');
            return federationFeature.typeNameInSchema(name);
        }
        else {
            return '_' + name;
        }
    }
    getFederationDirective(name) {
        const directive = this.schema.directive(this.federationDirectiveNameInSchema(name));
        (0, utils_1.assert)(directive, `The provided schema does not have federation directive @${name}`);
        return directive;
    }
    keyDirective() {
        return this.getFederationDirective(federationSpec_1.keyDirectiveSpec.name);
    }
    overrideDirective() {
        return this.getFederationDirective(federationSpec_1.overrideDirectiveSpec.name);
    }
    extendsDirective() {
        return this.getFederationDirective(federationSpec_1.extendsDirectiveSpec.name);
    }
    externalDirective() {
        return this.getFederationDirective(federationSpec_1.externalDirectiveSpec.name);
    }
    requiresDirective() {
        return this.getFederationDirective(federationSpec_1.requiresDirectiveSpec.name);
    }
    providesDirective() {
        return this.getFederationDirective(federationSpec_1.providesDirectiveSpec.name);
    }
    shareableDirective() {
        return this.getFederationDirective(federationSpec_1.shareableDirectiveSpec.name);
    }
    tagDirective() {
        return this.getFederationDirective(tagSpec.tagDirectiveSpec.name);
    }
    inaccessibleDirective() {
        return this.getFederationDirective(inaccessibleSpec.inaccessibleDirectiveSpec.name);
    }
    allFederationDirectives() {
        const baseDirectives = [
            this.keyDirective(),
            this.externalDirective(),
            this.requiresDirective(),
            this.providesDirective(),
            this.tagDirective(),
            this.extendsDirective(),
        ];
        return this.isFed2Schema()
            ? baseDirectives.concat(this.shareableDirective(), this.inaccessibleDirective(), this.overrideDirective())
            : baseDirectives;
    }
    entityType() {
        return this.schema.type(this.federationTypeNameInSchema(exports.entityTypeSpec.name));
    }
    anyType() {
        return this.schema.type(this.federationTypeNameInSchema(exports.anyTypeSpec.name));
    }
    serviceType() {
        return this.schema.type(this.federationTypeNameInSchema(exports.serviceTypeSpec.name));
    }
    fieldSetType() {
        return this.schema.type(this.federationTypeNameInSchema(federationSpec_1.fieldSetTypeSpec.name));
    }
    allFederationTypes() {
        const baseTypes = [
            this.anyType(),
            this.serviceType(),
            this.fieldSetType(),
        ];
        const entityType = this.entityType();
        if (entityType) {
            baseTypes.push(entityType);
        }
        return baseTypes;
    }
}
exports.FederationMetadata = FederationMetadata;
class FederationBlueprint extends definitions_1.SchemaBlueprint {
    constructor(withRootTypeRenaming) {
        super();
        this.withRootTypeRenaming = withRootTypeRenaming;
    }
    onAddedCoreFeature(schema, feature) {
        super.onAddedCoreFeature(schema, feature);
        if (feature.url.identity === federationSpec_1.federationIdentity) {
            const spec = federationSpec_1.FEDERATION_VERSIONS.find(feature.url.version);
            if (spec) {
                spec.addElementsToSchema(schema);
            }
        }
    }
    onMissingDirectiveDefinition(schema, name, args) {
        if (name === coreSpec_1.linkDirectiveDefaultName) {
            const url = args && args['url'];
            const as = url && url.startsWith(linkSpec.identity) ? args['as'] : undefined;
            const errors = linkSpec.addDefinitionsToSchema(schema, as);
            return errors.length > 0 ? errors : schema.directive(name);
        }
        return super.onMissingDirectiveDefinition(schema, name, args);
    }
    ignoreParsedField(type, fieldName) {
        if (!exports.FEDERATION_OPERATION_FIELDS.includes(fieldName)) {
            return false;
        }
        const metadata = federationMetadata(type.schema());
        return !!metadata && !metadata.isFed2Schema();
    }
    onConstructed(schema) {
        const existing = federationMetadata(schema);
        if (!existing) {
            schema['_federationMetadata'] = new FederationMetadata(schema);
        }
    }
    onDirectiveDefinitionAndSchemaParsed(schema) {
        return completeSubgraphSchema(schema);
    }
    onInvalidation(schema) {
        super.onInvalidation(schema);
        const metadata = federationMetadata(schema);
        (0, utils_1.assert)(metadata, 'Federation schema should have had its metadata set on construction');
        FederationMetadata.prototype['onInvalidate'].call(metadata);
    }
    onValidation(schema) {
        var _a;
        const errors = super.onValidation(schema);
        if (this.withRootTypeRenaming) {
            for (const k of definitions_1.allSchemaRootKinds) {
                const type = (_a = schema.schemaDefinition.root(k)) === null || _a === void 0 ? void 0 : _a.type;
                const defaultName = (0, definitions_1.defaultRootName)(k);
                if (type && type.name !== defaultName) {
                    const existing = schema.type(defaultName);
                    if (existing) {
                        errors.push(error_1.ERROR_CATEGORIES.ROOT_TYPE_USED.get(k).err({
                            message: `The schema has a type named "${defaultName}" but it is not set as the ${k} root type ("${type.name}" is instead): `
                                + 'this is not supported by federation. '
                                + 'If a root type does not use its default name, there should be no other type with that default name.',
                            nodes: (0, definitions_1.sourceASTs)(type, existing),
                        }));
                    }
                    type.rename(defaultName);
                }
            }
        }
        const metadata = federationMetadata(schema);
        (0, utils_1.assert)(metadata, 'Federation schema should have had its metadata set on construction');
        if (!metadata.isFed2Schema()) {
            return errors;
        }
        const keyDirective = metadata.keyDirective();
        validateAllFieldSet(keyDirective, type => type, errors, metadata, true, true, field => {
            const type = (0, definitions_1.baseType)(field.type);
            if ((0, definitions_1.isUnionType)(type) || (0, definitions_1.isInterfaceType)(type)) {
                let kind = type.kind;
                kind = kind.slice(0, kind.length - 'Type'.length);
                throw error_1.ERRORS.KEY_FIELDS_SELECT_INVALID_TYPE.err({
                    message: `field "${field.coordinate}" is a ${kind} type which is not allowed in @key`
                });
            }
        });
        validateAllFieldSet(metadata.requiresDirective(), field => field.parent, errors, metadata, false, false);
        validateAllFieldSet(metadata.providesDirective(), field => {
            if (metadata.isFieldExternal(field)) {
                throw new graphql_1.GraphQLError(`Cannot have both @provides and @external on field "${field.coordinate}"`, field.sourceAST);
            }
            const type = (0, definitions_1.baseType)(field.type);
            if (!(0, definitions_1.isCompositeType)(type)) {
                throw error_1.ERRORS.PROVIDES_ON_NON_OBJECT_FIELD.err({
                    message: `Invalid @provides directive on field "${field.coordinate}": field has type "${field.type}" which is not a Composite Type`,
                    nodes: field.sourceAST,
                });
            }
            return type;
        }, errors, metadata, false, false);
        validateNoExternalOnInterfaceFields(metadata, errors);
        validateAllExternalFieldsUsed(metadata, errors);
        const tagDirective = metadata.tagDirective();
        if (tagDirective) {
            const error = tagSpec.checkCompatibleDirective(tagDirective);
            if (error) {
                errors.push(error);
            }
        }
        for (const itf of schema.interfaceTypes()) {
            validateInterfaceRuntimeImplementationFieldsTypes(itf, metadata, errors);
        }
        return errors;
    }
    validationRules() {
        return FEDERATION_VALIDATION_RULES;
    }
    onUnknownDirectiveValidationError(schema, unknownDirectiveName, error) {
        const metadata = federationMetadata(schema);
        (0, utils_1.assert)(metadata, `This method should only have been called on a subgraph schema`);
        if (federationSpec_1.ALL_FEDERATION_DIRECTIVES_DEFAULT_NAMES.includes(unknownDirectiveName)) {
            if (metadata.isFed2Schema()) {
                const federationFeature = metadata.federationFeature();
                (0, utils_1.assert)(federationFeature, 'Fed2 subgraph _must_ link to the federation feature');
                const directiveNameInSchema = federationFeature.directiveNameInSchema(unknownDirectiveName);
                if (directiveNameInSchema.startsWith(federationFeature.nameInSchema + '__')) {
                    return (0, error_1.withModifiedErrorMessage)(error, `${error.message} If you meant the "@${unknownDirectiveName}" federation directive, you should use fully-qualified name "@${directiveNameInSchema}" or add "@${unknownDirectiveName}" to the \`import\` argument of the @link to the federation specification.`);
                }
                else {
                    return (0, error_1.withModifiedErrorMessage)(error, `${error.message} If you meant the "@${unknownDirectiveName}" federation directive, you should use "@${directiveNameInSchema}" as it is imported under that name in the @link to the federation specification of this schema.`);
                }
            }
            else {
                return (0, error_1.withModifiedErrorMessage)(error, `${error.message} If you meant the "@${unknownDirectiveName}" federation 2 directive, note that this schema is a federation 1 schema. To be a federation 2 schema, it needs to @link to the federation specifcation v2.`);
            }
        }
        else if (!metadata.isFed2Schema()) {
            const suggestions = (0, suggestions_1.suggestionList)(unknownDirectiveName, federationSpec_1.FEDERATION2_ONLY_SPEC_DIRECTIVES.map((spec) => spec.name));
            if (suggestions.length > 0) {
                return (0, error_1.withModifiedErrorMessage)(error, `${error.message}${(0, suggestions_1.didYouMean)(suggestions.map((s) => '@' + s))} If so, note that ${suggestions.length === 1 ? 'it is a federation 2 directive' : 'they are federation 2 directives'} but this schema is a federation 1 one. To be a federation 2 schema, it needs to @link to the federation specifcation v2.`);
            }
        }
        return error;
    }
}
exports.FederationBlueprint = FederationBlueprint;
function findUnusedNamedForLinkDirective(schema) {
    if (!schema.directive(linkSpec.url.name)) {
        return undefined;
    }
    const baseName = linkSpec.url.name;
    let n = 1;
    for (;;) {
        const candidate = baseName + n;
        if (!schema.directive(candidate)) {
            return candidate;
        }
    }
}
function setSchemaAsFed2Subgraph(schema) {
    let core = schema.coreFeatures;
    let spec;
    if (core) {
        spec = core.coreDefinition;
        (0, utils_1.assert)(spec.url.version.satisfies(linkSpec.version), `Fed2 schema must use @link with version >= 1.0, but schema uses ${spec.url}`);
    }
    else {
        const alias = findUnusedNamedForLinkDirective(schema);
        const errors = linkSpec.addToSchema(schema, alias);
        if (errors.length > 0) {
            throw (0, definitions_1.ErrGraphQLValidationFailed)(errors);
        }
        spec = linkSpec;
        core = schema.coreFeatures;
        (0, utils_1.assert)(core, 'Schema should now be a core schema');
    }
    (0, utils_1.assert)(!core.getByIdentity(federationSpec.identity), 'Schema already set as a federation subgraph');
    schema.schemaDefinition.applyDirective(core.coreItself.nameInSchema, {
        url: federationSpec.url.toString(),
        import: federationSpec_1.FEDERATION2_SPEC_DIRECTIVES.map((spec) => `@${spec.name}`),
    });
    const errors = completeSubgraphSchema(schema);
    if (errors.length > 0) {
        throw (0, definitions_1.ErrGraphQLValidationFailed)(errors);
    }
}
exports.setSchemaAsFed2Subgraph = setSchemaAsFed2Subgraph;
exports.FEDERATION2_LINK_WTH_FULL_IMPORTS = '@link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key", "@requires", "@provides", "@external", "@tag", "@extends", "@shareable", "@inaccessible", "@override"])';
function asFed2SubgraphDocument(document) {
    const fed2LinkExtension = {
        kind: graphql_1.Kind.SCHEMA_EXTENSION,
        directives: [{
                kind: graphql_1.Kind.DIRECTIVE,
                name: { kind: graphql_1.Kind.NAME, value: coreSpec_1.linkDirectiveDefaultName },
                arguments: [{
                        kind: graphql_1.Kind.ARGUMENT,
                        name: { kind: graphql_1.Kind.NAME, value: 'url' },
                        value: { kind: graphql_1.Kind.STRING, value: federationSpec.url.toString() }
                    },
                    {
                        kind: graphql_1.Kind.ARGUMENT,
                        name: { kind: graphql_1.Kind.NAME, value: 'import' },
                        value: { kind: graphql_1.Kind.LIST, values: federationSpec_1.FEDERATION2_SPEC_DIRECTIVES.map((spec) => ({ kind: graphql_1.Kind.STRING, value: `@${spec.name}` })) }
                    }]
            }]
    };
    return {
        kind: graphql_1.Kind.DOCUMENT,
        loc: document.loc,
        definitions: document.definitions.concat(fed2LinkExtension)
    };
}
exports.asFed2SubgraphDocument = asFed2SubgraphDocument;
function printSubgraphNames(names) {
    return (0, utils_1.printHumanReadableList)(names.map(n => `"${n}"`), {
        prefix: 'subgraph',
        prefixPlural: 'subgraphs',
    });
}
exports.printSubgraphNames = printSubgraphNames;
function federationMetadata(schema) {
    return schema['_federationMetadata'];
}
exports.federationMetadata = federationMetadata;
function isFederationSubgraphSchema(schema) {
    return !!federationMetadata(schema);
}
exports.isFederationSubgraphSchema = isFederationSubgraphSchema;
function isFederationField(field) {
    var _a;
    if (field.parent === ((_a = field.schema().schemaDefinition.root("query")) === null || _a === void 0 ? void 0 : _a.type)) {
        return exports.FEDERATION_OPERATION_FIELDS.includes(field.name);
    }
    return false;
}
exports.isFederationField = isFederationField;
function isEntityType(type) {
    if (type.kind !== "ObjectType") {
        return false;
    }
    const metadata = federationMetadata(type.schema());
    return !!metadata && type.hasAppliedDirective(metadata.keyDirective());
}
exports.isEntityType = isEntityType;
function buildSubgraph(name, url, source, withRootTypeRenaming = true) {
    const buildOptions = {
        blueprint: new FederationBlueprint(withRootTypeRenaming),
        validate: false,
    };
    let subgraph;
    try {
        const schema = typeof source === 'string'
            ? (0, buildSchema_1.buildSchema)(new graphql_1.Source(source, name), buildOptions)
            : (0, buildSchema_1.buildSchemaFromAST)(source, buildOptions);
        subgraph = new Subgraph(name, url, schema);
    }
    catch (e) {
        if (e instanceof graphql_1.GraphQLError && name !== exports.FEDERATION_UNNAMED_SUBGRAPH_NAME) {
            throw addSubgraphToError(e, name, error_1.ERRORS.INVALID_GRAPHQL);
        }
        else {
            throw e;
        }
    }
    return subgraph.validate();
}
exports.buildSubgraph = buildSubgraph;
function newEmptyFederation2Schema() {
    const schema = new definitions_1.Schema(new FederationBlueprint(true));
    setSchemaAsFed2Subgraph(schema);
    return schema;
}
exports.newEmptyFederation2Schema = newEmptyFederation2Schema;
function completeSubgraphSchema(schema) {
    const coreFeatures = schema.coreFeatures;
    if (coreFeatures) {
        const fedFeature = coreFeatures.getByIdentity(federationSpec_1.federationIdentity);
        if (fedFeature) {
            return completeFed2SubgraphSchema(schema);
        }
        else {
            return completeFed1SubgraphSchema(schema);
        }
    }
    else {
        const fedLink = schema.schemaDefinition.appliedDirectivesOf(coreSpec_1.linkDirectiveDefaultName).find(isFedSpecLinkDirective);
        if (fedLink) {
            const errors = linkSpec.addToSchema(schema);
            if (errors.length > 0) {
                return errors;
            }
            return completeFed2SubgraphSchema(schema);
        }
        else {
            return completeFed1SubgraphSchema(schema);
        }
    }
}
function isFedSpecLinkDirective(directive) {
    const args = directive.arguments();
    return directive.name === coreSpec_1.linkDirectiveDefaultName && args['url'] && args['url'].startsWith(federationSpec_1.federationIdentity);
}
function completeFed1SubgraphSchema(schema) {
    var _a, _b;
    for (const spec of [federationSpec_1.keyDirectiveSpec, federationSpec_1.providesDirectiveSpec, federationSpec_1.requiresDirectiveSpec]) {
        const directive = schema.directive(spec.name);
        if (!directive) {
            continue;
        }
        (0, utils_1.assert)(directive.applications().length === 0, `${directive} shouldn't have had validation at that places`);
        const fieldType = (_b = (_a = directive.argument('fields')) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.toString();
        const fieldTypeIsWrongInKnownWays = !!fieldType
            && directive.arguments().length === 1
            && (fieldType === 'String' || fieldType === '_FieldSet' || fieldType === 'FieldSet');
        if (directive.arguments().length === 0 || fieldTypeIsWrongInKnownWays) {
            directive.remove();
        }
    }
    return [
        federationSpec_1.fieldSetTypeSpec.checkOrAdd(schema, '_' + federationSpec_1.fieldSetTypeSpec.name),
        federationSpec_1.keyDirectiveSpec.checkOrAdd(schema),
        federationSpec_1.requiresDirectiveSpec.checkOrAdd(schema),
        federationSpec_1.providesDirectiveSpec.checkOrAdd(schema),
        federationSpec_1.extendsDirectiveSpec.checkOrAdd(schema),
        federationSpec_1.externalDirectiveSpec.checkOrAdd(schema),
        tagSpec.tagDirectiveSpec.checkOrAdd(schema),
    ].flat();
}
function completeFed2SubgraphSchema(schema) {
    const coreFeatures = schema.coreFeatures;
    (0, utils_1.assert)(coreFeatures, 'This method should not have been called on a non-core schema');
    const fedFeature = coreFeatures.getByIdentity(federationSpec_1.federationIdentity);
    (0, utils_1.assert)(fedFeature, 'This method should not have been called on a schema with no @link for federation');
    const spec = federationSpec_1.FEDERATION_VERSIONS.find(fedFeature.url.version);
    if (!spec) {
        return [error_1.ERRORS.UNKNOWN_FEDERATION_LINK_VERSION.err({
                message: `Invalid version ${fedFeature.url.version} for the federation feature in @link direction on schema`,
                nodes: fedFeature.directive.sourceAST
            })];
    }
    return spec.addElementsToSchema(schema);
}
function parseFieldSetArgument({ parentType, directive, fieldAccessor, validate, }) {
    var _a;
    try {
        return (0, operations_1.parseSelectionSet)({
            parentType,
            source: validateFieldSetValue(directive),
            fieldAccessor,
            validate,
        });
    }
    catch (e) {
        if (!(e instanceof graphql_1.GraphQLError)) {
            throw e;
        }
        const nodes = (0, definitions_1.sourceASTs)(directive);
        if (e.nodes) {
            nodes.push(...e.nodes);
        }
        let msg = e.message.trim();
        if (msg.startsWith('Cannot query field')) {
            if (msg.endsWith('.')) {
                msg = msg.slice(0, msg.length - 1);
            }
            if (directive.name === federationSpec_1.keyDirectiveSpec.name) {
                msg = msg + ' (the field should be either be added to this subgraph or, if it should not be resolved by this subgraph, you need to add it to this subgraph with @external).';
            }
            else {
                msg = msg + ' (if the field is defined in another subgraph, you need to add it to this subgraph with @external).';
            }
        }
        const codeDef = (_a = (0, error_1.errorCodeDef)(e)) !== null && _a !== void 0 ? _a : error_1.ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS.get(directive.name);
        throw codeDef.err({
            message: `${fieldSetErrorDescriptor(directive)}: ${msg}`,
            nodes,
            originalError: e,
        });
    }
}
exports.parseFieldSetArgument = parseFieldSetArgument;
function collectTargetFields({ parentType, directive, includeInterfaceFieldsImplementations, validate = true, }) {
    const fields = [];
    try {
        parseFieldSetArgument({
            parentType,
            directive,
            fieldAccessor: (t, f) => {
                const field = t.field(f);
                if (field) {
                    fields.push(field);
                    if (includeInterfaceFieldsImplementations && (0, definitions_1.isInterfaceType)(t)) {
                        for (const implType of t.possibleRuntimeTypes()) {
                            const implField = implType.field(f);
                            if (implField) {
                                fields.push(implField);
                            }
                        }
                    }
                }
                return field;
            },
            validate,
        });
    }
    catch (e) {
        const isGraphQLError = (0, definitions_1.errorCauses)(e) !== undefined;
        if (!isGraphQLError || validate) {
            throw e;
        }
    }
    return fields;
}
exports.collectTargetFields = collectTargetFields;
function validateFieldSetValue(directive) {
    var _a;
    const fields = directive.arguments().fields;
    const nodes = directive.sourceAST;
    if (typeof fields !== 'string') {
        throw error_1.ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS_TYPE.get(directive.name).err({
            message: `Invalid value for argument "${directive.definition.argument('fields').name}": must be a string.`,
            nodes,
        });
    }
    if (nodes && nodes.kind === 'Directive') {
        for (const argNode of (_a = nodes.arguments) !== null && _a !== void 0 ? _a : []) {
            if (argNode.name.value === 'fields') {
                if (argNode.value.kind !== 'StringValue') {
                    throw error_1.ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS_TYPE.get(directive.name).err({
                        message: `Invalid value for argument "${directive.definition.argument('fields').name}": must be a string.`,
                        nodes,
                    });
                }
                break;
            }
        }
    }
    return fields;
}
function subgraphsFromServiceList(serviceList) {
    var _a;
    let errors = [];
    const subgraphs = new Subgraphs();
    for (const service of serviceList) {
        try {
            subgraphs.add(buildSubgraph(service.name, (_a = service.url) !== null && _a !== void 0 ? _a : '', service.typeDefs));
        }
        catch (e) {
            const causes = (0, definitions_1.errorCauses)(e);
            if (causes) {
                errors = errors.concat(causes);
            }
            else {
                throw e;
            }
        }
    }
    return errors.length === 0 ? subgraphs : errors;
}
exports.subgraphsFromServiceList = subgraphsFromServiceList;
class Subgraphs {
    constructor() {
        this.subgraphs = new utils_1.OrderedMap();
    }
    add(subgraph) {
        if (this.subgraphs.has(subgraph.name)) {
            throw new Error(`A subgraph named ${subgraph.name} already exists` + (subgraph.url ? ` (with url '${subgraph.url}')` : ''));
        }
        this.subgraphs.add(subgraph.name, subgraph);
        return subgraph;
    }
    get(name) {
        return this.subgraphs.get(name);
    }
    size() {
        return this.subgraphs.size;
    }
    names() {
        return this.subgraphs.keys();
    }
    values() {
        return this.subgraphs.values();
    }
    *[Symbol.iterator]() {
        for (const subgraph of this.subgraphs) {
            yield subgraph;
        }
    }
    validate() {
        let errors = [];
        for (const subgraph of this.values()) {
            try {
                subgraph.validate();
            }
            catch (e) {
                const causes = (0, definitions_1.errorCauses)(e);
                if (!causes) {
                    throw e;
                }
                errors = errors.concat(causes);
            }
        }
        return errors.length === 0 ? undefined : errors;
    }
    toString() {
        return '[' + this.subgraphs.keys().join(', ') + ']';
    }
}
exports.Subgraphs = Subgraphs;
exports.anyTypeSpec = (0, directiveAndTypeSpecification_1.createScalarTypeSpecification)({ name: '_Any' });
exports.serviceTypeSpec = (0, directiveAndTypeSpecification_1.createObjectTypeSpecification)({
    name: '_Service',
    fieldsFct: (schema) => [{ name: 'sdl', type: schema.stringType() }],
});
exports.entityTypeSpec = (0, directiveAndTypeSpecification_1.createUnionTypeSpecification)({
    name: '_Entity',
    membersFct: (schema) => {
        return schema.objectTypes().filter(isEntityType).map((t) => t.name);
    },
});
exports.FEDERATION_OPERATION_TYPES = [exports.anyTypeSpec, exports.serviceTypeSpec, exports.entityTypeSpec];
exports.serviceFieldName = '_service';
exports.entitiesFieldName = '_entities';
exports.FEDERATION_OPERATION_FIELDS = [exports.serviceFieldName, exports.entitiesFieldName];
class Subgraph {
    constructor(name, url, schema) {
        this.name = name;
        this.url = url;
        this.schema = schema;
        if (name === exports.FEDERATION_RESERVED_SUBGRAPH_NAME) {
            throw error_1.ERRORS.INVALID_SUBGRAPH_NAME.err({ message: `Invalid name ${exports.FEDERATION_RESERVED_SUBGRAPH_NAME} for a subgraph: this name is reserved` });
        }
    }
    metadata() {
        const metadata = federationMetadata(this.schema);
        (0, utils_1.assert)(metadata, 'The subgraph schema should have built with the federation built-ins.');
        return metadata;
    }
    isFed2Subgraph() {
        return this.metadata().isFed2Schema();
    }
    addFederationOperations() {
        const metadata = this.metadata();
        for (const type of exports.FEDERATION_OPERATION_TYPES) {
            type.checkOrAdd(this.schema);
        }
        const queryRoot = this.schema.schemaDefinition.root("query");
        const queryType = queryRoot ? queryRoot.type : this.schema.addType(new definitions_1.ObjectType("Query"));
        const entityField = queryType.field(exports.entitiesFieldName);
        const entityType = metadata.entityType();
        if (entityType) {
            const entityFieldType = new definitions_1.NonNullType(new definitions_1.ListType(entityType));
            if (!entityField) {
                queryType.addField(exports.entitiesFieldName, entityFieldType)
                    .addArgument('representations', new definitions_1.NonNullType(new definitions_1.ListType(new definitions_1.NonNullType(metadata.anyType()))));
            }
            else if (!entityField.type) {
                entityField.type = entityType;
            }
        }
        else if (entityField) {
            entityField.remove();
        }
        if (!queryType.field(exports.serviceFieldName)) {
            queryType.addField(exports.serviceFieldName, new definitions_1.NonNullType(metadata.serviceType()));
        }
    }
    validate() {
        try {
            this.addFederationOperations();
            this.schema.validate();
            return this;
        }
        catch (e) {
            if (e instanceof graphql_1.GraphQLError) {
                throw addSubgraphToError(e, this.name, error_1.ERRORS.INVALID_GRAPHQL);
            }
            else {
                throw e;
            }
        }
    }
    isPrintedDirective(d) {
        var _a;
        if (this.metadata().allFederationDirectives().includes(d)) {
            return false;
        }
        const core = this.schema.coreFeatures;
        return !core || ((_a = core.sourceFeature(d)) === null || _a === void 0 ? void 0 : _a.url.identity) !== coreSpec_1.linkIdentity;
    }
    isPrintedType(t) {
        var _a;
        if (this.metadata().allFederationTypes().includes(t)) {
            return false;
        }
        if ((0, definitions_1.isObjectType)(t) && t.isQueryRootType() && t.fields().filter((f) => !isFederationField(f)).length === 0) {
            return false;
        }
        const core = this.schema.coreFeatures;
        return !core || ((_a = core.sourceFeature(t)) === null || _a === void 0 ? void 0 : _a.url.identity) !== coreSpec_1.linkIdentity;
    }
    isPrintedDirectiveApplication(d) {
        if (!this.schema.coreFeatures || d.name !== linkSpec.url.name) {
            return true;
        }
        const args = d.arguments();
        let urlArg = undefined;
        if ('url' in args) {
            try {
                urlArg = coreSpec_1.FeatureUrl.parse(args['url']);
            }
            catch (e) {
            }
        }
        const isDefaultLinkToLink = (urlArg === null || urlArg === void 0 ? void 0 : urlArg.identity) === coreSpec_1.linkIdentity && Object.keys(args).length === 1;
        return !isDefaultLinkToLink;
    }
    toString(basePrintOptions = print_1.defaultPrintOptions) {
        return (0, print_1.printSchema)(this.schema, {
            ...basePrintOptions,
            directiveDefinitionFilter: (d) => this.isPrintedDirective(d),
            typeFilter: (t) => this.isPrintedType(t),
            fieldFilter: (f) => !isFederationField(f),
            directiveApplicationFilter: (d) => this.isPrintedDirectiveApplication(d),
        });
    }
}
exports.Subgraph = Subgraph;
function addSubgraphToASTNode(node, subgraph) {
    return {
        ...node,
        subgraph
    };
}
exports.addSubgraphToASTNode = addSubgraphToASTNode;
function addSubgraphToError(e, subgraphName, errorCode) {
    const updatedCauses = (0, definitions_1.errorCauses)(e).map(cause => {
        var _a;
        const message = `[${subgraphName}] ${cause.message}`;
        const nodes = cause.nodes
            ? cause.nodes.map(node => addSubgraphToASTNode(node, subgraphName))
            : undefined;
        const code = (_a = (0, error_1.errorCodeDef)(cause)) !== null && _a !== void 0 ? _a : errorCode;
        if (code) {
            return code.err({
                message,
                nodes,
                source: cause.source,
                positions: cause.positions,
                path: cause.path,
                originalError: cause,
                extensions: cause.extensions,
            });
        }
        else {
            return new graphql_1.GraphQLError(message, nodes, cause.source, cause.positions, cause.path, cause, cause.extensions);
        }
    });
    return updatedCauses.length === 1 ? updatedCauses[0] : (0, definitions_1.ErrGraphQLValidationFailed)(updatedCauses);
}
exports.addSubgraphToError = addSubgraphToError;
class ExternalTester {
    constructor(schema) {
        this.schema = schema;
        this.fakeExternalFields = new Set();
        this.providedFields = new Set();
        this.externalDirective = this.metadata().externalDirective();
        this.collectFakeExternals();
        this.collectProvidedFields();
    }
    metadata() {
        const metadata = federationMetadata(this.schema);
        (0, utils_1.assert)(metadata, 'Schema should be a subgraphs schema');
        return metadata;
    }
    collectFakeExternals() {
        const metadata = this.metadata();
        const extendsDirective = metadata.extendsDirective();
        for (const key of metadata.keyDirective().applications()) {
            const parentType = key.parent;
            if (!(key.ofExtension() || parentType.hasAppliedDirective(extendsDirective))) {
                continue;
            }
            collectTargetFields({
                parentType,
                directive: key,
                includeInterfaceFieldsImplementations: false,
                validate: false,
            }).filter((field) => field.hasAppliedDirective(this.externalDirective))
                .forEach((field) => this.fakeExternalFields.add(field.coordinate));
        }
    }
    collectProvidedFields() {
        for (const provides of this.metadata().providesDirective().applications()) {
            const parent = provides.parent;
            collectTargetFields({
                parentType: (0, definitions_1.baseType)(parent.type),
                directive: provides,
                includeInterfaceFieldsImplementations: true,
                validate: false,
            }).forEach((f) => this.providedFields.add(f.coordinate));
        }
    }
    isExternal(field) {
        return field.hasAppliedDirective(this.externalDirective) && !this.isFakeExternal(field);
    }
    isFakeExternal(field) {
        return this.fakeExternalFields.has(field.coordinate);
    }
    selectsAnyExternalField(selectionSet) {
        for (const selection of selectionSet.selections()) {
            if (selection.kind === 'FieldSelection' && this.isExternal(selection.element().definition)) {
                return true;
            }
            if (selection.selectionSet) {
                if (this.selectsAnyExternalField(selection.selectionSet)) {
                    return true;
                }
            }
        }
        return false;
    }
    isPartiallyExternal(field) {
        return this.isExternal(field) && this.providedFields.has(field.coordinate);
    }
    isFullyExternal(field) {
        return this.isExternal(field) && !this.providedFields.has(field.coordinate);
    }
}
function removeInactiveProvidesAndRequires(schema, onModified = () => { }) {
    const metadata = federationMetadata(schema);
    if (!metadata) {
        return;
    }
    const providesDirective = metadata.providesDirective();
    const requiresDirective = metadata.requiresDirective();
    for (const type of schema.types()) {
        if (!(0, definitions_1.isObjectType)(type) && !(0, definitions_1.isInterfaceType)(type)) {
            continue;
        }
        for (const field of type.fields()) {
            const fieldBaseType = (0, definitions_1.baseType)(field.type);
            removeInactiveApplications(providesDirective, field, fieldBaseType, onModified);
            removeInactiveApplications(requiresDirective, field, type, onModified);
        }
    }
}
exports.removeInactiveProvidesAndRequires = removeInactiveProvidesAndRequires;
function removeInactiveApplications(directiveDefinition, field, parentType, onModified) {
    for (const application of field.appliedDirectivesOf(directiveDefinition)) {
        let selection;
        try {
            selection = parseFieldSetArgument({ parentType, directive: application });
        }
        catch (e) {
            continue;
        }
        if (selectsNonExternalLeafField(selection)) {
            application.remove();
            const updated = withoutNonExternalLeafFields(selection);
            if (!updated.isEmpty()) {
                const updatedDirective = field.applyDirective(directiveDefinition, { fields: updated.toString(true, false) });
                onModified(field, application, updatedDirective);
            }
            else {
                onModified(field, application);
            }
        }
    }
}
function isExternalOrHasExternalImplementations(field) {
    const metadata = federationMetadata(field.schema());
    if (!metadata) {
        return false;
    }
    if (field.hasAppliedDirective(metadata.externalDirective())) {
        return true;
    }
    const parentType = field.parent;
    if ((0, definitions_1.isInterfaceType)(parentType)) {
        for (const implem of parentType.possibleRuntimeTypes()) {
            const fieldInImplem = implem.field(field.name);
            if (fieldInImplem && fieldInImplem.hasAppliedDirective(metadata.externalDirective())) {
                return true;
            }
        }
    }
    return false;
}
function selectsNonExternalLeafField(selection) {
    return selection.selections().some(s => {
        if (s.kind === 'FieldSelection') {
            if (isExternalOrHasExternalImplementations(s.field.definition)) {
                return false;
            }
            return !s.selectionSet || selectsNonExternalLeafField(s.selectionSet);
        }
        else {
            return selectsNonExternalLeafField(s.selectionSet);
        }
    });
}
function withoutNonExternalLeafFields(selectionSet) {
    const newSelectionSet = new operations_1.SelectionSet(selectionSet.parentType);
    for (const selection of selectionSet.selections()) {
        if (selection.kind === 'FieldSelection') {
            if (isExternalOrHasExternalImplementations(selection.field.definition)) {
                newSelectionSet.add(selection);
                continue;
            }
        }
        if (selection.selectionSet) {
            const updated = withoutNonExternalLeafFields(selection.selectionSet);
            if (!updated.isEmpty()) {
                newSelectionSet.add((0, operations_1.selectionOfElement)(selection.element(), updated));
            }
        }
    }
    return newSelectionSet;
}
//# sourceMappingURL=federation.js.map