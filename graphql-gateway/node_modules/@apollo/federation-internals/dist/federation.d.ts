import { CompositeType, CoreFeature, Directive, DirectiveDefinition, FieldDefinition, InputFieldDefinition, InterfaceType, NamedType, ObjectType, ScalarType, Schema, SchemaBlueprint, UnionType } from "./definitions";
import { SDLValidationRule } from "graphql/validation/ValidationContext";
import { ASTNode, DocumentNode, GraphQLError } from "graphql";
import { SelectionSet } from './operations';
import { ErrorCodeDefinition } from "./error";
import { PrintOptions as PrintOptions } from "./print";
export declare const FEDERATION_RESERVED_SUBGRAPH_NAME = "_";
export declare const FEDERATION_UNNAMED_SUBGRAPH_NAME = "<unnamed>";
export declare function collectUsedFields(metadata: FederationMetadata): Set<FieldDefinition<CompositeType>>;
export declare class FederationMetadata {
    readonly schema: Schema;
    private _externalTester?;
    private _sharingPredicate?;
    private _fieldUsedPredicate?;
    private _isFed2Schema?;
    constructor(schema: Schema);
    private onInvalidate;
    isFed2Schema(): boolean;
    federationFeature(): CoreFeature | undefined;
    private externalTester;
    private sharingPredicate;
    private fieldUsedPredicate;
    isFieldUsed(field: FieldDefinition<CompositeType>): boolean;
    isFieldExternal(field: FieldDefinition<any> | InputFieldDefinition): boolean;
    isFieldPartiallyExternal(field: FieldDefinition<any> | InputFieldDefinition): boolean;
    isFieldFullyExternal(field: FieldDefinition<any> | InputFieldDefinition): boolean;
    isFieldFakeExternal(field: FieldDefinition<any> | InputFieldDefinition): boolean;
    selectionSelectsAnyExternalField(selectionSet: SelectionSet): boolean;
    isFieldShareable(field: FieldDefinition<any>): boolean;
    federationDirectiveNameInSchema(name: string): string;
    federationTypeNameInSchema(name: string): string;
    private getFederationDirective;
    keyDirective(): DirectiveDefinition<{
        fields: any;
        resolvable?: boolean;
    }>;
    overrideDirective(): DirectiveDefinition<{
        from: string;
    }>;
    extendsDirective(): DirectiveDefinition<Record<string, never>>;
    externalDirective(): DirectiveDefinition<{
        reason: string;
    }>;
    requiresDirective(): DirectiveDefinition<{
        fields: any;
    }>;
    providesDirective(): DirectiveDefinition<{
        fields: any;
    }>;
    shareableDirective(): DirectiveDefinition<{}>;
    tagDirective(): DirectiveDefinition<{
        name: string;
    }>;
    inaccessibleDirective(): DirectiveDefinition<{}>;
    allFederationDirectives(): DirectiveDefinition[];
    entityType(): UnionType | undefined;
    anyType(): ScalarType;
    serviceType(): ObjectType;
    fieldSetType(): ScalarType;
    allFederationTypes(): NamedType[];
}
export declare class FederationBlueprint extends SchemaBlueprint {
    private readonly withRootTypeRenaming;
    constructor(withRootTypeRenaming: boolean);
    onAddedCoreFeature(schema: Schema, feature: CoreFeature): void;
    onMissingDirectiveDefinition(schema: Schema, name: string, args?: {
        [key: string]: any;
    }): DirectiveDefinition | GraphQLError[] | undefined;
    ignoreParsedField(type: NamedType, fieldName: string): boolean;
    onConstructed(schema: Schema): void;
    onDirectiveDefinitionAndSchemaParsed(schema: Schema): GraphQLError[];
    onInvalidation(schema: Schema): void;
    onValidation(schema: Schema): GraphQLError[];
    validationRules(): readonly SDLValidationRule[];
    onUnknownDirectiveValidationError(schema: Schema, unknownDirectiveName: string, error: GraphQLError): GraphQLError;
}
export declare function setSchemaAsFed2Subgraph(schema: Schema): void;
export declare const FEDERATION2_LINK_WTH_FULL_IMPORTS = "@link(url: \"https://specs.apollo.dev/federation/v2.0\", import: [\"@key\", \"@requires\", \"@provides\", \"@external\", \"@tag\", \"@extends\", \"@shareable\", \"@inaccessible\", \"@override\"])";
export declare function asFed2SubgraphDocument(document: DocumentNode): DocumentNode;
export declare function printSubgraphNames(names: string[]): string;
export declare function federationMetadata(schema: Schema): FederationMetadata | undefined;
export declare function isFederationSubgraphSchema(schema: Schema): boolean;
export declare function isFederationField(field: FieldDefinition<CompositeType>): boolean;
export declare function isEntityType(type: NamedType): boolean;
export declare function buildSubgraph(name: string, url: string, source: DocumentNode | string, withRootTypeRenaming?: boolean): Subgraph;
export declare function newEmptyFederation2Schema(): Schema;
export declare function parseFieldSetArgument({ parentType, directive, fieldAccessor, validate, }: {
    parentType: CompositeType;
    directive: Directive<NamedType | FieldDefinition<CompositeType>, {
        fields: any;
    }>;
    fieldAccessor?: (type: CompositeType, fieldName: string) => FieldDefinition<any> | undefined;
    validate?: boolean;
}): SelectionSet;
export declare function collectTargetFields({ parentType, directive, includeInterfaceFieldsImplementations, validate, }: {
    parentType: CompositeType;
    directive: Directive<NamedType | FieldDefinition<CompositeType>, {
        fields: any;
    }>;
    includeInterfaceFieldsImplementations: boolean;
    validate?: boolean;
}): FieldDefinition<CompositeType>[];
export interface ServiceDefinition {
    typeDefs: DocumentNode;
    name: string;
    url?: string;
}
export declare function subgraphsFromServiceList(serviceList: ServiceDefinition[]): Subgraphs | GraphQLError[];
export declare class Subgraphs {
    private readonly subgraphs;
    add(subgraph: Subgraph): Subgraph;
    get(name: string): Subgraph | undefined;
    size(): number;
    names(): readonly string[];
    values(): readonly Subgraph[];
    [Symbol.iterator](): Generator<Subgraph, void, unknown>;
    validate(): GraphQLError[] | undefined;
    toString(): string;
}
export declare const anyTypeSpec: import("./directiveAndTypeSpecification").TypeSpecification;
export declare const serviceTypeSpec: import("./directiveAndTypeSpecification").TypeSpecification;
export declare const entityTypeSpec: import("./directiveAndTypeSpecification").TypeSpecification;
export declare const FEDERATION_OPERATION_TYPES: import("./directiveAndTypeSpecification").TypeSpecification[];
export declare const serviceFieldName = "_service";
export declare const entitiesFieldName = "_entities";
export declare const FEDERATION_OPERATION_FIELDS: readonly string[];
export declare class Subgraph {
    readonly name: string;
    readonly url: string;
    readonly schema: Schema;
    constructor(name: string, url: string, schema: Schema);
    metadata(): FederationMetadata;
    isFed2Subgraph(): boolean;
    private addFederationOperations;
    validate(): Subgraph;
    private isPrintedDirective;
    private isPrintedType;
    private isPrintedDirectiveApplication;
    toString(basePrintOptions?: PrintOptions): string;
}
export declare type SubgraphASTNode = ASTNode & {
    subgraph: string;
};
export declare function addSubgraphToASTNode(node: ASTNode, subgraph: string): SubgraphASTNode;
export declare function addSubgraphToError(e: GraphQLError, subgraphName: string, errorCode?: ErrorCodeDefinition): GraphQLError;
export declare type ProvidesOrRequiresApplication = Directive<FieldDefinition<ObjectType | InterfaceType>, {
    fields: any;
}>;
export declare function removeInactiveProvidesAndRequires(schema: Schema, onModified?: (field: FieldDefinition<any>, original: ProvidesOrRequiresApplication, updated?: ProvidesOrRequiresApplication) => void): void;
//# sourceMappingURL=federation.d.ts.map