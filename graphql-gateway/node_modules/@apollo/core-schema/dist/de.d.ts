import { ASTNode, DefinitionNode, DirectiveNode, NamedTypeNode } from 'graphql';
import GRef, { HasGref } from './gref';
export declare const ErrNoDefinition: (gref: GRef, ...nodes: ASTNode[]) => import("./error").GraphQLErrorExt<"NoDefinition"> & {
    message: string;
    gref: GRef;
    nodes: ASTNode[];
};
export declare type De<T> = T extends (infer E)[] ? De<E>[] : T extends Locatable ? {
    [K in keyof T]: K extends 'kind' | 'loc' ? T[K] : De<T[K]>;
} & HasGref : T extends object ? {
    [K in keyof T]: K extends 'kind' | 'loc' ? T[K] : De<T[K]>;
} : T;
export declare type Def = De<DefinitionNode> | Redirect;
export declare type Defs = Iterable<Def>;
export interface Redirect {
    code: 'Redirect';
    gref: GRef;
    toGref: GRef;
    via: DirectiveNode;
}
export declare const isRedirect: (o: any) => o is Redirect;
export declare type Locatable = DefinitionNode | DirectiveNode | NamedTypeNode;
export declare type Located = Locatable & HasGref;
export declare function fill(source: Defs, atlas?: Defs): Defs;
export declare function refNodesIn(defs: Defs | Iterable<ASTNode>): Iterable<Located | Redirect>;
export declare const deepRefs: (root: ASTNode | ASTNode[]) => Iterable<Located>;
declare type ChildOf<T> = T extends (infer E)[] ? E : T extends object ? {
    [k in keyof T]: T[k] extends (infer E)[] ? E : T[k];
}[keyof T] : T;
export declare function children<T>(root: T): Iterable<ChildOf<T>>;
export declare const hasRef: (o?: any) => o is HasGref;
export declare function isLocatable(o: any): o is Locatable;
export declare function isLocated(o: any): o is Located;
export {};
//# sourceMappingURL=de.d.ts.map