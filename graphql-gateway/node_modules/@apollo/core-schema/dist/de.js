"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLocated = exports.isLocatable = exports.hasRef = exports.children = exports.deepRefs = exports.refNodesIn = exports.fill = exports.isRedirect = exports.ErrNoDefinition = void 0;
const recall_1 = require("@protoplasm/recall");
const graphql_1 = require("graphql");
const each_1 = require("./each");
const error_1 = __importDefault(require("./error"));
const gref_1 = __importStar(require("./gref"));
const is_1 = require("./is");
const link_url_1 = __importDefault(require("./link-url"));
const ErrNoDefinition = (gref, ...nodes) => (0, error_1.default)('NoDefinition', {
    message: `no definitions found for reference: ${gref}`,
    gref,
    nodes
});
exports.ErrNoDefinition = ErrNoDefinition;
const isRedirect = (o) => (o === null || o === void 0 ? void 0 : o.code) === 'Redirect';
exports.isRedirect = isRedirect;
function* fill(source, atlas) {
    const notDefined = new Map();
    const seen = new Set((0, gref_1.byGref)(onlyDefinitions(source)).keys());
    const atlasDefs = atlas ? (0, gref_1.byGref)(atlas) : null;
    ingest(source);
    while (notDefined.size) {
        const [ref, nodes] = (0, each_1.first)(notDefined.entries());
        notDefined.delete(ref);
        if (seen.has(ref))
            continue;
        seen.add(ref);
        const defs = atlasDefs === null || atlasDefs === void 0 ? void 0 : atlasDefs.get(ref);
        if (!defs) {
            (0, recall_1.report)((0, exports.ErrNoDefinition)(ref, ...nodes));
            continue;
        }
        ingest(defs);
        yield* defs;
    }
    function ingest(defs) {
        for (const node of refNodesIn(defs))
            if ((0, exports.isRedirect)(node))
                addGref(node.toGref, node.via);
            else
                addGref(node.gref, node);
    }
    function addGref(gref, node) {
        if (seen.has(gref) || gref.graph === link_url_1.default.GRAPHQL_SPEC)
            return;
        const existing = notDefined.get(gref);
        if (existing)
            existing.push(node);
        else
            notDefined.set(gref, [node]);
    }
}
exports.fill = fill;
function* onlyDefinitions(defs) {
    for (const def of defs)
        if (!(0, exports.isRedirect)(def))
            yield def;
}
function* refNodesIn(defs) {
    for (const def of defs) {
        if ((0, exports.isRedirect)(def))
            yield def;
        else
            yield* (0, exports.deepRefs)(def);
    }
}
exports.refNodesIn = refNodesIn;
exports.deepRefs = (0, recall_1.replay)(function* (root) {
    if (isLocatable(root) && (0, exports.hasRef)(root))
        yield root;
    for (const child of children(root)) {
        if ((0, is_1.isAst)(child))
            yield* (0, exports.deepRefs)(child);
    }
});
function* children(root) {
    if (Array.isArray(root))
        return yield* root;
    if (typeof root === 'object') {
        for (const child of Object.values(root)) {
            if (Array.isArray(child))
                yield* child;
            else
                yield child;
        }
    }
}
exports.children = children;
const hasRef = (o) => (o === null || o === void 0 ? void 0 : o.gref) instanceof gref_1.default;
exports.hasRef = hasRef;
const LOCATABLE_KINDS = new Set([
    ...Object.values(graphql_1.Kind)
        .filter(k => k.endsWith('Definition') || k.endsWith('Extension'))
        .filter(k => !k.startsWith('Field'))
        .filter(k => k !== 'OperationDefinition' && k !== 'FragmentDefinition'),
    graphql_1.Kind.DIRECTIVE,
    graphql_1.Kind.NAMED_TYPE,
]);
function isLocatable(o) {
    return LOCATABLE_KINDS.has(o === null || o === void 0 ? void 0 : o.kind);
}
exports.isLocatable = isLocatable;
function isLocated(o) {
    return isLocatable(o) && (0, exports.hasRef)(o);
}
exports.isLocated = isLocated;
//# sourceMappingURL=de.js.map