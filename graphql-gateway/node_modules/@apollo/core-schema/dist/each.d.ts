import { Recall } from "@protoplasm/recall";
declare type ItemType<G extends (item: any) => any> = Parameters<G>[0];
declare type ElementType<I extends Iterable<any>> = I extends Iterable<infer T> ? T : never;
export declare const ErrEmpty: (iterable?: Iterable<any> | undefined) => import("./error").GraphQLErrorExt<"Empty"> & {
    message: string;
    iterable: Iterable<any> | undefined;
};
export declare const ErrTooMany: (iterable: Iterable<any>) => import("./error").GraphQLErrorExt<"TooMany"> & {
    message: string;
    iterable: Iterable<any>;
};
export declare function first<I extends Iterable<any>>(iter?: I): ElementType<I>;
export declare function only<I extends Iterable<any>>(iter?: I): ElementType<I>;
export declare function maybe<I extends Iterable<any>>(iter?: I): ElementType<I> | undefined;
export declare function maybeOne<I extends Iterable<any>>(iter?: I): ElementType<I> | undefined;
export declare const groupBy: Recall<(<G extends (item: any) => any>(grouper: G) => <T extends ItemType<G>>(...sources: Iterable<T>[]) => Readonly<Map<ReturnType<G>, Iterable<T>>>)>;
export declare const flat: import("@protoplasm/recall").Replay<(<I extends Iterable<Iterable<any>>>(iters: I) => Iterator<ElementType<ElementType<I>>, any, undefined>)>;
export declare const concat: <I>(...iters: Iterable<I>[]) => Iterable<I>;
export {};
//# sourceMappingURL=each.d.ts.map