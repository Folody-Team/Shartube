"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneLinks = exports.Schema = void 0;
const recall_1 = __importStar(require("@protoplasm/recall"));
const graphql_1 = require("graphql");
const de_1 = require("./de");
const linker_1 = require("./linker");
const directives_1 = __importDefault(require("./directives"));
const gref_1 = require("./gref");
const scope_1 = __importStar(require("./scope"));
const is_1 = require("./is");
const gql_1 = __importDefault(require("./gql"));
const link_url_1 = __importDefault(require("./link-url"));
const each_1 = require("./each");
class Schema {
    constructor(document, frame) {
        this.document = document;
        this.frame = frame;
    }
    static from(document, frame = scope_1.default.EMPTY) {
        if (frame instanceof Schema)
            return new this(document, frame.scope);
        return new this(document, frame);
    }
    static basic(document) {
        return this.from(document, this.BASIC);
    }
    get scope() {
        return this.frame.child(scope => {
            for (const dir of (0, directives_1.default)(this.document)) {
                const linker = linker_1.Linker.from(scope, dir);
                if (!linker)
                    continue;
                for (const link of linker.links(dir)) {
                    scope.add(link);
                }
            }
            const self = selfIn(scope, (0, directives_1.default)(this.document));
            if (self) {
                scope.add({
                    ...self,
                    name: '',
                    implicit: true,
                });
                scope.add({
                    ...self,
                    name: '@' + self.name,
                    gref: gref_1.GRef.rootDirective(self.gref.graph),
                    implicit: true,
                });
            }
        });
    }
    get url() { return this.scope.url; }
    get self() { return this.scope.self; }
    *[Symbol.iterator]() {
        const { scope } = this;
        for (const link of scope) {
            if (!link.name || !link.gref.name || link.implicit || !link.via)
                continue;
            yield {
                code: 'Redirect',
                gref: gref_1.GRef.named(link.name, scope.url),
                toGref: link.gref,
                via: link.via,
            };
        }
        for (const def of this.document.definitions) {
            if ((0, de_1.isLocatable)(def))
                yield scope.denormalize(def);
        }
    }
    get refs() {
        return (0, de_1.refNodesIn)(this);
    }
    definitions(ref) {
        var _a;
        if (!ref)
            return this;
        if (this.url && !ref.graph)
            ref = ref.setGraph(this.url);
        return (_a = (0, gref_1.byGref)(this).get(ref)) !== null && _a !== void 0 ? _a : [];
    }
    locate(node) {
        return this.scope.locate(node);
    }
    standardize(...urls) {
        const graphs = new Set(urls.map(u => link_url_1.default.from(u)));
        const standard = scope_1.default.create(scope => {
            for (const graph of graphs) {
                const { name } = graph;
                if (!name)
                    throw new Error('urls sent to standardize must have names');
                scope.add({
                    name, gref: gref_1.GRef.schema(graph)
                });
            }
        });
        const newScope = scope_1.default.create((scope) => {
            const flat = this.scope.flat;
            for (const link of flat) {
                if (!graphs.has(link.gref.graph))
                    scope.add(link);
            }
            for (const link of standard)
                scope.add(link);
        });
        return Schema.from({
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [
                ...newScope.renormalizeDefs([
                    ...newScope.header(),
                    ...(0, exports.pruneLinks)(this)
                ]),
            ],
        });
    }
    compile(atlas) {
        const extras = [...(0, de_1.fill)(this, atlas)];
        const scope = this.scope.child((0, scope_1.including)((0, de_1.refNodesIn)(extras))).flat;
        const header = scope.header();
        const body = [...(0, exports.pruneLinks)(this)];
        const linkExtras = [...(0, de_1.fill)((0, each_1.concat)(header, extras), atlas)];
        return Schema.from({
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [
                ...scope.renormalizeDefs((0, each_1.concat)(header, body, linkExtras, extras))
            ]
        }).shrinkwrap();
    }
    shrinkwrap() {
        const { scope } = this;
        const safe = new Set();
        for (const ref of this.refs) {
            const name = this.scope.name(ref.gref);
            if (!ref.gref.graph || !name)
                continue;
            const [prefix, bare] = name;
            const link = scope.lookup(prefix !== null && prefix !== void 0 ? prefix : bare);
            if (!(link === null || link === void 0 ? void 0 : link.via))
                continue;
            safe.add(link.via);
        }
        const candidates = new Set([...this.scope].map(link => link.via).filter(Boolean));
        return Schema.from((0, graphql_1.visit)(this.document, {
            Directive(dir) {
                if (!candidates.has(dir))
                    return undefined;
                if (!safe.has(dir))
                    return null;
                return undefined;
            }
        }), this.scope.parent);
    }
    dangerousRemoveHeaders() {
        return Schema.from({
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [...this.scope.renormalizeDefs((0, exports.pruneLinks)(this))]
        }, this.scope);
    }
    print() {
        return (0, graphql_1.print)(this.document);
    }
}
Schema.BASIC = Schema.from((0, gql_1.default) `${'builtin:schema/basic'}
      @link(url: "https://specs.apollo.dev/link/v1.0")
      @link(url: "https://specs.graphql.org", import: """
        @deprecated @specifiedBy
        Int Float String Boolean ID
      """)
      @link(url: "https://specs.apollo.dev/id/v1.0")
    `);
__decorate([
    (0, recall_1.use)(recall_1.replay)
], Schema.prototype, "refs", null);
exports.Schema = Schema;
exports.default = Schema;
const selfIn = (0, recall_1.default)(function self(scope, directives) {
    for (const dir of directives) {
        const self = (0, linker_1.id)(scope, dir);
        if (self)
            return self;
    }
    return null;
});
exports.pruneLinks = (0, recall_1.replay)(function* pruneLinks(defs) {
    var _a, _b;
    for (const def of defs) {
        if ((0, de_1.isRedirect)(def))
            continue;
        if ((0, is_1.isAst)(def, graphql_1.Kind.SCHEMA_DEFINITION, graphql_1.Kind.SCHEMA_EXTENSION)) {
            if (!def.directives)
                yield def;
            const directives = (_a = def.directives) === null || _a === void 0 ? void 0 : _a.filter(dir => !linker_1.LINK_DIRECTIVES.has(dir.gref));
            if (!(directives === null || directives === void 0 ? void 0 : directives.length) && !((_b = def.operationTypes) === null || _b === void 0 ? void 0 : _b.length) && !def.description)
                continue;
            yield { ...def, directives };
            continue;
        }
        yield def;
    }
});
//# sourceMappingURL=schema.js.map