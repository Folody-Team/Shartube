"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UplinkFetcher = void 0;
const resolvable_1 = __importDefault(require("@josephg/resolvable"));
const loadSupergraphSdlFromStorage_1 = require("./loadSupergraphSdlFromStorage");
class UplinkFetcher {
    constructor(options) {
        var _a;
        this.timerRef = null;
        this.errorReportingEndpoint = (_a = process.env.APOLLO_OUT_OF_BAND_REPORTER_ENDPOINT) !== null && _a !== void 0 ? _a : undefined;
        this.fetchCount = 0;
        this.minDelayMs = null;
        this.earliestFetchTime = null;
        this.config = options;
        this.state = { phase: 'initialized' };
    }
    async initialize({ update, healthCheck }) {
        this.update = update;
        if (this.config.subgraphHealthCheck) {
            this.healthCheck = healthCheck;
        }
        let initialSupergraphSdl = null;
        try {
            const result = await this.updateSupergraphSdl();
            initialSupergraphSdl = (result === null || result === void 0 ? void 0 : result.supergraphSdl) || null;
            if (result === null || result === void 0 ? void 0 : result.minDelaySeconds) {
                this.minDelayMs = 1000 * (result === null || result === void 0 ? void 0 : result.minDelaySeconds);
                this.earliestFetchTime = new Date(Date.now() + this.minDelayMs);
            }
        }
        catch (e) {
            this.logUpdateFailure(e);
            throw e;
        }
        this.beginPolling();
        return {
            supergraphSdl: initialSupergraphSdl,
            cleanup: async () => {
                if (this.state.phase === 'polling') {
                    await this.state.pollingPromise;
                }
                this.state = { phase: 'stopped' };
                if (this.timerRef) {
                    clearTimeout(this.timerRef);
                    this.timerRef = null;
                }
            },
        };
    }
    async updateSupergraphSdl() {
        var _a, _b;
        const result = await (0, loadSupergraphSdlFromStorage_1.loadSupergraphSdlFromUplinks)({
            graphRef: this.config.graphRef,
            apiKey: this.config.apiKey,
            endpoints: this.config.uplinkEndpoints,
            errorReportingEndpoint: this.errorReportingEndpoint,
            fetcher: this.config.fetcher,
            compositionId: (_a = this.compositionId) !== null && _a !== void 0 ? _a : null,
            maxRetries: this.config.maxRetries,
            roundRobinSeed: this.fetchCount++,
            earliestFetchTime: this.earliestFetchTime,
        });
        if (!result) {
            return null;
        }
        else {
            this.compositionId = result.id;
            await ((_b = this.healthCheck) === null || _b === void 0 ? void 0 : _b.call(this, result.supergraphSdl));
            const { supergraphSdl, minDelaySeconds } = result;
            return { supergraphSdl, minDelaySeconds };
        }
    }
    beginPolling() {
        this.state = { phase: 'polling' };
        this.poll();
    }
    poll() {
        this.timerRef = setTimeout(async () => {
            var _a;
            if (this.state.phase === 'polling') {
                const pollingPromise = (0, resolvable_1.default)();
                this.state.pollingPromise = pollingPromise;
                try {
                    const result = await this.updateSupergraphSdl();
                    const maybeNewSupergraphSdl = (result === null || result === void 0 ? void 0 : result.supergraphSdl) || null;
                    if (result === null || result === void 0 ? void 0 : result.minDelaySeconds) {
                        this.minDelayMs = 1000 * (result === null || result === void 0 ? void 0 : result.minDelaySeconds);
                        this.earliestFetchTime = new Date(Date.now() + this.minDelayMs);
                    }
                    if (maybeNewSupergraphSdl) {
                        (_a = this.update) === null || _a === void 0 ? void 0 : _a.call(this, maybeNewSupergraphSdl);
                    }
                }
                catch (e) {
                    this.logUpdateFailure(e);
                }
                pollingPromise.resolve();
            }
            this.poll();
        }, this.minDelayMs
            ? Math.max(this.minDelayMs, this.config.fallbackPollIntervalInMs)
            : this.config.fallbackPollIntervalInMs);
    }
    logUpdateFailure(e) {
        var _a, _b;
        (_a = this.config.logger) === null || _a === void 0 ? void 0 : _a.error('UplinkFetcher failed to update supergraph with the following error: ' +
            ((_b = e.message) !== null && _b !== void 0 ? _b : e));
    }
}
exports.UplinkFetcher = UplinkFetcher;
//# sourceMappingURL=index.js.map