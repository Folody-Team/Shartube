"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeQueryPlan = exports.MAX_COMPUTED_PLANS = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const query_graphs_1 = require("@apollo/query-graphs");
const graphql_1 = require("graphql");
const QueryPlan_1 = require("./QueryPlan");
const debug = (0, federation_internals_1.newDebugLogger)('plan');
exports.MAX_COMPUTED_PLANS = 10000;
function mapOptionsToSelections(selectionSet, options) {
    return selectionSet.selections(true).map(node => [node, options]);
}
class QueryPlanningTaversal {
    constructor(supergraphSchema, subgraphs, selectionSet, variableDefinitions, startVertex, rootKind, costFunction, initialContext, excludedEdges = [], excludedConditions = []) {
        this.supergraphSchema = supergraphSchema;
        this.subgraphs = subgraphs;
        this.variableDefinitions = variableDefinitions;
        this.startVertex = startVertex;
        this.rootKind = rootKind;
        this.costFunction = costFunction;
        this.closedBranches = [];
        this.isTopLevel = (0, query_graphs_1.isRootVertex)(startVertex);
        this.conditionResolver = (0, query_graphs_1.cachingConditionResolver)(subgraphs, (edge, context, excludedEdges, excludedConditions) => this.resolveConditionPlan(edge, context, excludedEdges, excludedConditions));
        const initialPath = query_graphs_1.GraphPath.create(subgraphs, startVertex);
        const initialOptions = [new query_graphs_1.SimultaneousPathsWithLazyIndirectPaths([initialPath], initialContext, this.conditionResolver, excludedEdges, excludedConditions)];
        this.stack = mapOptionsToSelections(selectionSet, initialOptions);
    }
    debugStack() {
        if (this.isTopLevel && debug.enabled) {
            debug.group('Query planning open branches:');
            for (const [selection, options] of this.stack) {
                debug.groupedValues(options, opt => `${(0, query_graphs_1.simultaneousPathsToString)(opt)}`, `${selection}:`);
            }
            debug.groupEnd();
        }
    }
    findBestPlan() {
        while (this.stack.length > 0) {
            this.debugStack();
            const [selection, options] = this.stack.pop();
            this.handleOpenBranch(selection, options);
        }
        this.computeBestPlanFromClosedBranches();
        return this.bestPlan;
    }
    handleOpenBranch(selection, options) {
        const operation = selection.element();
        let newOptions = [];
        for (const option of options) {
            const followupForOption = (0, query_graphs_1.advanceSimultaneousPathsWithOperation)(this.supergraphSchema, option, operation);
            if (!followupForOption) {
                continue;
            }
            if (followupForOption.length === 0) {
                if (operation.kind === 'FragmentElement') {
                    this.closedBranches.push([option.paths.map(p => (0, query_graphs_1.terminateWithNonRequestedTypenameField)(p))]);
                }
                return;
            }
            newOptions = newOptions.concat(followupForOption);
        }
        if (newOptions.length === 0) {
            if (this.isTopLevel) {
                debug.log(`No valid options to advance ${selection} from ${(0, query_graphs_1.advanceOptionsToString)(options)}`);
                throw new Error(`Was not able to find any options for ${selection}: This shouldn't have happened.`);
            }
            else {
                this.stack.splice(0, this.stack.length);
                this.closedBranches.splice(0, this.closedBranches.length);
                return;
            }
        }
        if (selection.selectionSet) {
            for (const branch of mapOptionsToSelections(selection.selectionSet, newOptions)) {
                this.stack.push(branch);
            }
        }
        else {
            const updated = this.maybeEliminateStrictlyMoreCostlyPaths(newOptions);
            this.closedBranches.push(updated);
        }
    }
    maybeEliminateStrictlyMoreCostlyPaths(options) {
        if (options.length === 1) {
            return [options[0].paths];
        }
        const singlePathOptions = options.filter(opt => opt.paths.length === 1);
        if (singlePathOptions.length === 0) {
            return options.map(opt => opt.paths);
        }
        let minJumps = Number.MAX_SAFE_INTEGER;
        let withMinJumps = [];
        for (const option of singlePathOptions) {
            const jumps = option.paths[0].subgraphJumps();
            if (jumps < minJumps) {
                minJumps = jumps;
                withMinJumps = [option.paths];
            }
            else if (jumps === minJumps) {
                withMinJumps.push(option.paths);
            }
        }
        for (const option of singlePathOptions.filter(opt => opt.paths.length > 1)) {
            const jumps = option.paths.reduce((acc, p) => Math.min(acc, p.subgraphJumps()), Number.MAX_SAFE_INTEGER);
            if (jumps <= minJumps) {
                withMinJumps.push(option.paths);
            }
        }
        return withMinJumps;
    }
    newDependencyGraph() {
        return FetchDependencyGraph.create(this.subgraphs);
    }
    reorderFirstBranch() {
        const firstBranch = this.closedBranches[0];
        let i = 1;
        while (i < this.closedBranches.length && this.closedBranches[i].length > firstBranch.length) {
            i++;
        }
        this.closedBranches[0] = this.closedBranches[i - 1];
        this.closedBranches[i - 1] = firstBranch;
    }
    computeBestPlanFromClosedBranches() {
        if (this.closedBranches.length === 0) {
            return;
        }
        this.closedBranches.sort((b1, b2) => b1.length > b2.length ? -1 : (b1.length < b2.length ? 1 : 0));
        let planCount = possiblePlans(this.closedBranches);
        debug.log(() => `Query has ${planCount} possible plans`);
        let firstBranch = this.closedBranches[0];
        while (planCount > exports.MAX_COMPUTED_PLANS && firstBranch.length > 1) {
            const prevSize = firstBranch.length;
            firstBranch.pop();
            planCount -= planCount / prevSize;
            this.reorderFirstBranch();
            firstBranch = this.closedBranches[0];
            debug.log(() => `Reduced plans to consider to ${planCount} plans`);
        }
        debug.log(() => `All branches:${this.closedBranches.map((opts, i) => `\n${i}:${opts.map((opt => `\n - ${(0, query_graphs_1.simultaneousPathsToString)(opt)}`))}`)}`);
        let idxFirstOfLengthOne = 0;
        while (idxFirstOfLengthOne < this.closedBranches.length && this.closedBranches[idxFirstOfLengthOne].length > 1) {
            idxFirstOfLengthOne++;
        }
        let initialTree;
        let initialDependencyGraph;
        if (idxFirstOfLengthOne === this.closedBranches.length) {
            initialTree = query_graphs_1.PathTree.createOp(this.subgraphs, this.startVertex);
            initialDependencyGraph = this.newDependencyGraph();
        }
        else {
            initialTree = query_graphs_1.PathTree.createFromOpPaths(this.subgraphs, this.startVertex, this.closedBranches.slice(idxFirstOfLengthOne).flat(2));
            initialDependencyGraph = this.updatedDependencyGraph(this.newDependencyGraph(), initialTree);
            if (idxFirstOfLengthOne === 0) {
                this.onNewPlan(initialDependencyGraph, initialTree);
                return;
            }
        }
        const otherTrees = this.closedBranches.slice(0, idxFirstOfLengthOne).map(b => b.map(opt => query_graphs_1.PathTree.createFromOpPaths(this.subgraphs, this.startVertex, opt)));
        this.generateAllPlans(initialDependencyGraph, initialTree, otherTrees);
    }
    generateAllPlans(initialDependencyGraph, initialTree, others) {
        const eltIndexes = new Array(others.length);
        let totalCombinations = 1;
        for (let i = 0; i < others.length; ++i) {
            const eltSize = others[i].length;
            (0, federation_internals_1.assert)(eltSize, "Got empty option: this shouldn't have happened");
            if (!eltSize) {
                totalCombinations = 0;
                break;
            }
            eltIndexes[i] = 0;
            totalCombinations *= eltSize;
        }
        for (let i = 0; i < totalCombinations; ++i) {
            const dependencyGraph = initialDependencyGraph.clone();
            let tree = initialTree;
            for (let j = 0; j < others.length; ++j) {
                const t = others[j][eltIndexes[j]];
                this.updatedDependencyGraph(dependencyGraph, t);
                tree = tree.merge(t);
            }
            this.onNewPlan(dependencyGraph, tree);
            for (let idx = 0; idx < others.length; ++idx) {
                if (eltIndexes[idx] == others[idx].length - 1) {
                    eltIndexes[idx] = 0;
                }
                else {
                    eltIndexes[idx] += 1;
                    break;
                }
            }
        }
    }
    cost(dependencyGraph) {
        return this.costFunction.finalize(dependencyGraph.process(this.costFunction), true);
    }
    updatedDependencyGraph(dependencyGraph, tree) {
        return (0, query_graphs_1.isRootPathTree)(tree)
            ? computeRootFetchGroups(dependencyGraph, tree, this.rootKind)
            : computeNonRootFetchGroups(dependencyGraph, tree, this.rootKind);
    }
    resolveConditionPlan(edge, context, excludedEdges, excludedConditions) {
        const bestPlan = new QueryPlanningTaversal(this.supergraphSchema, this.subgraphs, edge.conditions, this.variableDefinitions, edge.head, 'query', this.costFunction, context, excludedEdges, (0, query_graphs_1.addConditionExclusion)(excludedConditions, edge.conditions)).findBestPlan();
        return bestPlan ? { satisfied: true, cost: bestPlan[2], pathTree: bestPlan[1] } : query_graphs_1.unsatisfiedConditionsResolution;
    }
    onNewPlan(dependencyGraph, tree) {
        const cost = this.cost(dependencyGraph);
        if (!this.bestPlan || cost < this.bestPlan[2]) {
            debug.log(() => this.bestPlan ? `Found better with cost ${cost} (previous had cost ${this.bestPlan[2]}): ${tree}` : `Computed plan with cost ${cost}: ${tree}`);
            this.bestPlan = [dependencyGraph, tree, cost];
        }
        else {
            debug.log(() => `Ignoring plan with cost ${cost} (a better plan with cost ${this.bestPlan[2]} exists): ${tree}`);
        }
    }
}
function possiblePlans(closedBranches) {
    let totalCombinations = 1;
    for (let i = 0; i < closedBranches.length; ++i) {
        const eltSize = closedBranches[i].length;
        if (!eltSize) {
            totalCombinations = 0;
            break;
        }
        totalCombinations *= eltSize;
    }
    return totalCombinations;
}
function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
}
const fetchCost = 10000;
const pipeliningCost = 100;
const sameLevelFetchCost = 100;
function selectionCost(selection, depth = 1) {
    return selection ? selection.selections().reduce((prev, curr) => prev + depth + selectionCost(curr.selectionSet, depth + 1), 0) : 0;
}
const defaultCostFunction = {
    onFetchGroup: (group) => selectionCost(group.selection),
    reduceParallel: (values) => values,
    reduceSequence: (values) => values.reduceRight((acc, value, idx) => {
        const valueArray = Array.isArray(value) ? value : [value];
        return acc + ((idx + 1) * pipeliningCost) * (fetchCost * valueArray.length) * (Math.max(...valueArray) + (valueArray.length - 1) * sameLevelFetchCost);
    }, 0),
    finalize: (roots, rootsAreParallel) => roots.length === 0 ? 0 : (rootsAreParallel ? (Math.max(...roots) + (roots.length - 1) * sameLevelFetchCost) : sum(roots))
};
function isIntrospectionSelection(selection) {
    return selection.kind == 'FieldSelection' && selection.element().definition.isIntrospectionField();
}
function withoutIntrospection(operation) {
    if (!operation.selectionSet.selections().some(isIntrospectionSelection)) {
        return operation;
    }
    const newSelections = operation.selectionSet.selections().filter(s => !isIntrospectionSelection(s));
    return new federation_internals_1.Operation(operation.rootKind, new federation_internals_1.SelectionSet(operation.selectionSet.parentType).addAll(newSelections), operation.variableDefinitions, operation.name);
}
function computeQueryPlan(supergraphSchema, federatedQueryGraph, operation) {
    if (operation.rootKind === 'subscription') {
        throw new graphql_1.GraphQLError('Query planning does not support subscriptions for now.', [(0, graphql_1.parse)(operation.toString())]);
    }
    operation = operation.expandAllFragments();
    operation = withoutIntrospection(operation);
    debug.group(() => `Computing plan for\n${operation}`);
    if (operation.selectionSet.isEmpty()) {
        debug.groupEnd('Empty plan');
        return { kind: 'QueryPlan' };
    }
    const root = federatedQueryGraph.root(operation.rootKind);
    (0, federation_internals_1.assert)(root, () => `Shouldn't have a ${operation.rootKind} operation if the subgraphs don't have a ${operation.rootKind} root`);
    const processor = fetchGroupToPlanProcessor(operation.variableDefinitions, operation.selectionSet.fragments, operation.name);
    if (operation.rootKind === 'mutation') {
        const dependencyGraphs = computeRootSerialDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root);
        const rootNode = processor.finalize(dependencyGraphs.flatMap(g => g.process(processor)), false);
        debug.groupEnd('Mutation plan computed');
        return { kind: 'QueryPlan', node: rootNode };
    }
    else {
        const dependencyGraph = computeRootParallelDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root);
        const rootNode = processor.finalize(dependencyGraph.process(processor), true);
        debug.groupEnd('Query plan computed');
        return { kind: 'QueryPlan', node: rootNode };
    }
}
exports.computeQueryPlan = computeQueryPlan;
function computeRootParallelDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root) {
    return computeRootParallelBestPlan(supergraphSchema, operation.selectionSet, operation.variableDefinitions, federatedQueryGraph, root)[0];
}
function computeRootParallelBestPlan(supergraphSchema, selection, variables, federatedQueryGraph, root) {
    const planningTraversal = new QueryPlanningTaversal(supergraphSchema, federatedQueryGraph, selection, variables, root, root.rootKind, defaultCostFunction, query_graphs_1.emptyContext);
    const plan = planningTraversal.findBestPlan();
    return plan !== null && plan !== void 0 ? plan : createEmptyPlan(federatedQueryGraph, root);
}
function createEmptyPlan(federatedQueryGraph, root) {
    return [
        FetchDependencyGraph.create(federatedQueryGraph),
        query_graphs_1.PathTree.createOp(federatedQueryGraph, root),
        0
    ];
}
function onlyRootSubgraph(graph) {
    const subgraphs = graph.rootSubgraphs();
    (0, federation_internals_1.assert)(subgraphs.length === 1, () => `${graph} should have only one root, but has [${graph.rootSubgraphs()}]`);
    return subgraphs[0];
}
function computeRootSerialDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root) {
    const splittedRoots = splitTopLevelFields(operation.selectionSet);
    const graphs = [];
    let [prevDepGraph, prevPaths] = computeRootParallelBestPlan(supergraphSchema, splittedRoots[0], operation.variableDefinitions, federatedQueryGraph, root);
    let prevSubgraph = onlyRootSubgraph(prevDepGraph);
    for (let i = 1; i < splittedRoots.length; i++) {
        const [newDepGraph, newPaths] = computeRootParallelBestPlan(supergraphSchema, splittedRoots[i], operation.variableDefinitions, federatedQueryGraph, root);
        const newSubgraph = onlyRootSubgraph(newDepGraph);
        if (prevSubgraph === newSubgraph) {
            prevPaths = prevPaths.concat(newPaths);
            prevDepGraph = computeRootFetchGroups(FetchDependencyGraph.create(federatedQueryGraph), prevPaths, root.rootKind);
        }
        else {
            graphs.push(prevDepGraph);
            [prevDepGraph, prevPaths, prevSubgraph] = [newDepGraph, newPaths, newSubgraph];
        }
    }
    graphs.push(prevDepGraph);
    return graphs;
}
function splitTopLevelFields(selectionSet) {
    return selectionSet.selections().flatMap(selection => {
        if (selection.kind === 'FieldSelection') {
            return [(0, federation_internals_1.selectionSetOf)(selectionSet.parentType, selection)];
        }
        else {
            return splitTopLevelFields(selection.selectionSet).map(s => (0, federation_internals_1.selectionSetOfElement)(selection.element(), s));
        }
    });
}
function toValidGraphQLName(subgraphName) {
    const sanitized = subgraphName
        .replace(/-/ig, '_')
        .replace(/[^_0-9A-Za-z]/ig, '');
    return sanitized.match(/^[0-9].*/i) ? '_' + sanitized : sanitized;
}
function fetchGroupToPlanProcessor(variableDefinitions, fragments, operationName) {
    let counter = 0;
    return {
        onFetchGroup: (group) => group.toPlanNode(variableDefinitions, fragments, operationName ? `${operationName}__${toValidGraphQLName(group.subgraphName)}__${counter++}` : undefined),
        reduceParallel: (values) => flatWrap('Parallel', values),
        reduceSequence: (values) => flatWrap('Sequence', values),
        finalize: (roots, rootsAreParallel) => roots.length == 0 ? undefined : flatWrap(rootsAreParallel ? 'Parallel' : 'Sequence', roots)
    };
}
function addToResponsePath(path, responseName, type) {
    path = path.concat(responseName);
    while (!(0, federation_internals_1.isNamedType)(type)) {
        if ((0, federation_internals_1.isListType)(type)) {
            path.push('@');
        }
        type = type.ofType;
    }
    return path;
}
class LazySelectionSet {
    constructor(_computed, _toCloneOnWrite) {
        this._computed = _computed;
        this._toCloneOnWrite = _toCloneOnWrite;
        (0, federation_internals_1.assert)(_computed || _toCloneOnWrite, 'Should have one of the argument');
    }
    forRead() {
        return this._computed ? this._computed : this._toCloneOnWrite;
    }
    forWrite() {
        if (!this._computed) {
            this._computed = this._toCloneOnWrite.clone();
        }
        return this._computed;
    }
    clone() {
        if (this._computed) {
            return new LazySelectionSet(undefined, this._computed);
        }
        else {
            return this;
        }
    }
    toString() {
        return this.forRead().toString();
    }
}
class FetchGroup {
    constructor(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, _selection, _inputs, mergeAt) {
        this.dependencyGraph = dependencyGraph;
        this.index = index;
        this.subgraphName = subgraphName;
        this.rootKind = rootKind;
        this.parentType = parentType;
        this.isEntityFetch = isEntityFetch;
        this._selection = _selection;
        this._inputs = _inputs;
        this.mergeAt = mergeAt;
    }
    static create(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, mergeAt) {
        return new FetchGroup(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, new LazySelectionSet(new federation_internals_1.SelectionSet(parentType)), isEntityFetch ? new LazySelectionSet(new federation_internals_1.SelectionSet(parentType)) : undefined, mergeAt);
    }
    clone(newDependencyGraph) {
        var _a;
        return new FetchGroup(newDependencyGraph, this.index, this.subgraphName, this.rootKind, this.parentType, this.isEntityFetch, this._selection.clone(), (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.clone(), this.mergeAt);
    }
    get isTopLevel() {
        return !this.mergeAt;
    }
    get selection() {
        return this._selection.forRead();
    }
    get inputs() {
        var _a;
        return (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.forRead();
    }
    clonedInputs() {
        var _a;
        return (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.clone();
    }
    addDependencyOn(groups, pathInGroups) {
        this.dependencyGraph.addDependency(this, groups, pathInGroups);
    }
    removeDependencyOn(groups) {
        this.dependencyGraph.removeDependency(this, groups);
    }
    addInputs(selection) {
        (0, federation_internals_1.assert)(this._inputs, "Shouldn't try to add inputs to a root fetch group");
        if (selection instanceof federation_internals_1.SelectionSet) {
            this._inputs.forWrite().mergeIn(selection);
        }
        else {
            this._inputs.forWrite().add(selection);
        }
    }
    addSelection(path) {
        this._selection.forWrite().addPath(path);
    }
    addSelections(selection) {
        this._selection.forWrite().mergeIn(selection);
    }
    mergeIn(toMerge, mergePath) {
        (0, federation_internals_1.assert)(!toMerge.isTopLevel, () => `Shouldn't merge top level group ${toMerge} into ${this}`);
        const mergePathConditionalDirectives = (0, federation_internals_1.conditionalDirectivesInOperationPath)(mergePath);
        const selectionSet = (0, federation_internals_1.selectionSetOfPath)(mergePath, (endOfPathSet) => {
            (0, federation_internals_1.assert)(endOfPathSet, () => `Merge path ${mergePath} ends on a non-selectable type`);
            for (const selection of toMerge.selection.selections()) {
                const withoutUneededFragments = removeRedundantFragments(selection, endOfPathSet.parentType, mergePathConditionalDirectives);
                addSelectionOrSelectionSet(endOfPathSet, withoutUneededFragments);
            }
        });
        this._selection.forWrite().mergeIn(selectionSet);
        this.dependencyGraph.onMergedIn(this, toMerge);
    }
    toPlanNode(variableDefinitions, fragments, operationName) {
        var _a;
        addTypenameFieldForAbstractTypes(this.selection);
        this.selection.validate();
        const inputs = (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.forRead();
        if (inputs) {
            inputs.validate();
        }
        const inputNodes = inputs ? inputs.toSelectionSetNode() : undefined;
        const operation = this.isEntityFetch
            ? operationForEntitiesFetch(this.dependencyGraph.subgraphSchemas.get(this.subgraphName), this.selection, variableDefinitions, fragments, operationName)
            : operationForQueryFetch(this.rootKind, this.selection, variableDefinitions, fragments, operationName);
        const fetchNode = {
            kind: 'Fetch',
            serviceName: this.subgraphName,
            requires: inputNodes ? (0, QueryPlan_1.trimSelectionNodes)(inputNodes.selections) : undefined,
            variableUsages: this.selection.usedVariables().map(v => v.name),
            operation: (0, graphql_1.stripIgnoredCharacters)((0, graphql_1.print)((0, federation_internals_1.operationToDocument)(operation))),
            operationKind: schemaRootKindToOperationKind(operation.rootKind),
            operationName: operation.name,
        };
        return this.isTopLevel
            ? fetchNode
            : {
                kind: 'Flatten',
                path: this.mergeAt,
                node: fetchNode,
            };
    }
    toString() {
        return this.isTopLevel
            ? `[${this.index}]${this.subgraphName}[${this._selection}]`
            : `[${this.index}]${this.subgraphName}@(${this.mergeAt})[${this._inputs} => ${this._selection}]`;
    }
}
function addSelectionOrSelectionSet(selectionSet, toAdd) {
    if (toAdd instanceof federation_internals_1.SelectionSet) {
        selectionSet.mergeIn(toAdd);
    }
    else {
        selectionSet.add(toAdd);
    }
}
function removeRedundantFragmentsOfSet(selectionSet, type, unneededDirectives) {
    let newSet = undefined;
    const selections = selectionSet.selections();
    for (let i = 0; i < selections.length; i++) {
        const selection = selections[i];
        const updated = removeRedundantFragments(selection, type, unneededDirectives);
        if (newSet) {
            addSelectionOrSelectionSet(newSet, updated);
        }
        else if (selection !== updated) {
            newSet = new federation_internals_1.SelectionSet(type);
            for (let j = 0; j < i; j++) {
                newSet.add(selections[j]);
            }
            addSelectionOrSelectionSet(newSet, updated);
        }
    }
    return newSet ? newSet : selectionSet;
}
function removeRedundantFragments(selection, type, unneededDirectives) {
    if (selection.kind !== 'FragmentSelection') {
        return selection;
    }
    const fragment = selection.element();
    const fragmentType = fragment.typeCondition;
    if (!fragmentType) {
        return selection;
    }
    let neededDirectives = [];
    if (fragment.appliedDirectives.length > 0) {
        neededDirectives = (0, federation_internals_1.directiveApplicationsSubstraction)(fragment.appliedDirectives, unneededDirectives);
    }
    if ((0, federation_internals_1.sameType)(type, fragmentType) && neededDirectives.length === 0) {
        return removeRedundantFragmentsOfSet(selection.selectionSet, type, unneededDirectives);
    }
    else if (neededDirectives.length === fragment.appliedDirectives.length) {
        return selection;
    }
    else {
        const updatedFragement = new federation_internals_1.FragmentElement(type, fragment.typeCondition);
        neededDirectives.forEach((d) => updatedFragement.applyDirective(d.definition, d.arguments()));
        return (0, federation_internals_1.selectionSetOfElement)(updatedFragement, selection.selectionSet);
    }
}
function schemaRootKindToOperationKind(operation) {
    switch (operation) {
        case "query": return graphql_1.OperationTypeNode.QUERY;
        case "mutation": return graphql_1.OperationTypeNode.MUTATION;
        case "subscription": return graphql_1.OperationTypeNode.SUBSCRIPTION;
    }
}
function removeInPlace(value, array) {
    const idx = array.indexOf(value);
    if (idx >= 0) {
        array.splice(idx, 1);
    }
}
function sameMergeAt(m1, m2) {
    if (!m1) {
        return !m2;
    }
    if (!m2) {
        return false;
    }
    return (0, federation_internals_1.arrayEquals)(m1, m2);
}
class FetchDependencyGraph {
    constructor(subgraphSchemas, federatedQueryGraph, rootGroups, groups, adjacencies, inEdges, pathsInParents) {
        this.subgraphSchemas = subgraphSchemas;
        this.federatedQueryGraph = federatedQueryGraph;
        this.rootGroups = rootGroups;
        this.groups = groups;
        this.adjacencies = adjacencies;
        this.inEdges = inEdges;
        this.pathsInParents = pathsInParents;
        this.isReduced = false;
    }
    static create(federatedQueryGraph) {
        return new FetchDependencyGraph(federatedQueryGraph.sources, federatedQueryGraph, new federation_internals_1.MapWithCachedArrays(), [], [], [], []);
    }
    federationMetadata(subgraphName) {
        const schema = this.subgraphSchemas.get(subgraphName);
        (0, federation_internals_1.assert)(schema, () => `Unknown schema ${subgraphName}`);
        const metadata = (0, federation_internals_1.federationMetadata)(schema);
        (0, federation_internals_1.assert)(metadata, () => `Schema ${subgraphName} should be a federation subgraph`);
        return metadata;
    }
    clone() {
        const cloned = new FetchDependencyGraph(this.subgraphSchemas, this.federatedQueryGraph, new federation_internals_1.MapWithCachedArrays(), new Array(this.groups.length), this.adjacencies.map(a => a.concat()), this.inEdges.map(a => a.concat()), this.pathsInParents.concat());
        for (let i = 0; i < this.groups.length; i++) {
            cloned.groups[i] = this.groups[i].clone(cloned);
        }
        for (const group of this.rootGroups.values()) {
            cloned.rootGroups.set(group.subgraphName, cloned.groups[group.index]);
        }
        return cloned;
    }
    getOrCreateRootFetchGroup(subgraphName, rootKind, parentType) {
        let group = this.rootGroups.get(subgraphName);
        if (!group) {
            group = this.createRootFetchGroup(subgraphName, rootKind, parentType);
            this.rootGroups.set(subgraphName, group);
        }
        return group;
    }
    rootSubgraphs() {
        return this.rootGroups.keys();
    }
    createRootFetchGroup(subgraphName, rootKind, parentType) {
        const group = this.newFetchGroup(subgraphName, parentType, false, rootKind);
        this.rootGroups.set(subgraphName, group);
        return group;
    }
    newFetchGroup(subgraphName, parentType, isEntityFetch, rootKind, mergeAt, directParent, pathInParent) {
        this.onModification();
        const newGroup = FetchGroup.create(this, this.groups.length, subgraphName, rootKind, parentType, isEntityFetch, mergeAt);
        this.groups.push(newGroup);
        this.adjacencies.push([]);
        this.inEdges.push([]);
        if (directParent) {
            this.addEdge(directParent.index, newGroup.index, pathInParent);
        }
        return newGroup;
    }
    getOrCreateKeyFetchGroup(subgraphName, mergeAt, directParent, pathInParent, conditionsGroups) {
        for (const existing of this.dependents(directParent)) {
            if (existing.subgraphName === subgraphName
                && existing.mergeAt
                && sameMergeAt(existing.mergeAt, mergeAt)
                && !this.isDependedOn(existing, conditionsGroups)) {
                const existingPathInParent = this.pathInParent(existing);
                if (pathInParent && existingPathInParent && !(0, federation_internals_1.sameOperationPaths)(existingPathInParent, pathInParent)) {
                    this.pathsInParents[existing.index] = undefined;
                }
                return existing;
            }
        }
        const entityType = this.federationMetadata(subgraphName).entityType();
        (0, federation_internals_1.assert)(entityType, () => `Subgraph ${subgraphName} has not entities defined`);
        return this.newFetchGroup(subgraphName, entityType, true, 'query', mergeAt, directParent, pathInParent);
    }
    newRootTypeFetchGroup(subgraphName, rootKind, parentType, mergeAt, directParent, pathInParent) {
        return this.newFetchGroup(subgraphName, parentType, false, rootKind, mergeAt, directParent, pathInParent);
    }
    isDependedOn(toCheck, conditions) {
        const stack = conditions.concat();
        while (stack.length > 0) {
            const group = stack.pop();
            if (toCheck.index === group.index) {
                return true;
            }
            stack.push(...this.dependencies(group));
        }
        return false;
    }
    newKeyFetchGroup(subgraphName, mergeAt) {
        const entityType = this.federationMetadata(subgraphName).entityType();
        (0, federation_internals_1.assert)(entityType, () => `Subgraph ${subgraphName} has not entities defined`);
        return this.newFetchGroup(subgraphName, entityType, true, 'query', mergeAt);
    }
    addDependency(dependentGroup, dependentOn, pathInDependentOn) {
        this.onModification();
        const groups = Array.isArray(dependentOn) ? dependentOn : [dependentOn];
        for (const group of groups) {
            this.addEdge(group.index, dependentGroup.index, pathInDependentOn);
        }
    }
    removeDependency(dependentGroup, dependentOn) {
        this.onModification();
        const groups = Array.isArray(dependentOn) ? dependentOn : [dependentOn];
        for (const group of groups) {
            this.removeEdge(group.index, dependentGroup.index);
        }
    }
    pathInParent(group) {
        return this.pathsInParents[group.index];
    }
    addEdge(from, to, pathInFrom) {
        if (!this.adjacencies[from].includes(to)) {
            this.adjacencies[from].push(to);
            this.inEdges[to].push(from);
            const parentsCount = this.inEdges[to].length;
            if (pathInFrom && parentsCount === 1) {
                this.pathsInParents[to] = pathInFrom;
            }
            else if (parentsCount > 1) {
                this.pathsInParents[to] = undefined;
            }
        }
    }
    removeEdge(from, to) {
        if (this.adjacencies[from].includes(to)) {
            removeInPlace(to, this.adjacencies[from]);
            removeInPlace(from, this.inEdges[to]);
            this.pathsInParents[to] = undefined;
        }
    }
    onMergedIn(mergedInto, merged) {
        (0, federation_internals_1.assert)(!merged.isTopLevel, "Shouldn't remove top level groups");
        this.onModification();
        this.relocateDependentsOnMergedIn(mergedInto, merged.index);
        this.removeInternal(merged.index);
    }
    relocateDependentsOnMergedIn(mergedInto, mergedIndex) {
        for (const dependentIdx of this.adjacencies[mergedIndex]) {
            this.addEdge(mergedInto.index, dependentIdx);
            const idxInIns = this.inEdges[dependentIdx].indexOf(mergedIndex);
            if (idxInIns >= 0) {
                this.inEdges[dependentIdx].splice(idxInIns, 1);
            }
        }
    }
    remove(group) {
        this.onModification();
        const dependents = this.dependents(group);
        const dependencies = this.dependencies(group);
        (0, federation_internals_1.assert)(dependents.length === 0, () => `Cannot remove group ${group} with dependents [${dependents}]`);
        (0, federation_internals_1.assert)(dependencies.length <= 1, () => `Cannot remove group ${group} with more/less than one dependency: [${dependencies}]`);
        this.removeInternal(group.index);
    }
    removeInternal(mergedIndex) {
        for (const dependedIdx of this.inEdges[mergedIndex]) {
            const idxInAdj = this.adjacencies[dependedIdx].indexOf(mergedIndex);
            this.adjacencies[dependedIdx].splice(idxInAdj, 1);
        }
        this.groups.splice(mergedIndex, 1);
        this.adjacencies.splice(mergedIndex, 1);
        this.inEdges.splice(mergedIndex, 1);
        this.pathsInParents.splice(mergedIndex, 1);
        this.groups.forEach(g => {
            if (g.index > mergedIndex) {
                --g.index;
            }
        });
        this.adjacencies.forEach(adj => {
            adj.forEach((v, i) => {
                if (v > mergedIndex) {
                    adj[i] = v - 1;
                }
            });
        });
        this.inEdges.forEach(ins => {
            ins.forEach((v, i) => {
                if (v > mergedIndex) {
                    ins[i] = v - 1;
                }
            });
        });
    }
    onModification() {
        this.isReduced = false;
    }
    reduce() {
        if (this.isReduced) {
            return;
        }
        for (const group of this.groups) {
            this.dfsRemoveRedundantEdges(group);
        }
        for (const group of this.rootGroups.values()) {
            this.removeEmptyGroups(group);
        }
        for (const group of this.rootGroups.values()) {
            this.mergeDependentFetchesForSameSubgraphAndPath(group);
        }
        this.isReduced = true;
    }
    removeEmptyGroups(group) {
        const dependents = this.dependents(group);
        if (group.selection.isEmpty()) {
            for (const dependent of dependents) {
                (0, federation_internals_1.assert)(this.dependencies(dependent).length > 1, () => `Empty group ${group} is the *only* dependency of ${dependent}`);
                this.removeDependency(dependent, group);
            }
            this.remove(group);
        }
        for (const g of dependents) {
            this.removeEmptyGroups(g);
        }
    }
    mergeDependentFetchesForSameSubgraphAndPath(group) {
        const dependents = this.dependents(group);
        if (dependents.length > 1) {
            for (const g1 of dependents) {
                for (const g2 of dependents) {
                    if (g1.index !== g2.index
                        && g1.subgraphName === g2.subgraphName
                        && sameMergeAt(g1.mergeAt, g2.mergeAt)
                        && this.dependencies(g1).length === 1
                        && this.dependencies(g2).length === 1) {
                        const merged = FetchGroup.create(this, g1.index, g1.subgraphName, g1.rootKind, g1.selection.parentType, g1.isEntityFetch, g1.mergeAt);
                        this.pathsInParents[g1.index] = undefined;
                        if (g1.inputs) {
                            merged.addInputs(g1.inputs);
                        }
                        merged.addSelections(g1.selection);
                        this.groups[merged.index] = merged;
                        if (g2.inputs) {
                            merged.addInputs(g2.inputs);
                        }
                        merged.addSelections(g2.selection);
                        this.onMergedIn(merged, g2);
                        this.dfsRemoveRedundantEdges(merged);
                        this.mergeDependentFetchesForSameSubgraphAndPath(group);
                        return;
                    }
                }
            }
        }
        for (const g of dependents) {
            this.mergeDependentFetchesForSameSubgraphAndPath(g);
        }
    }
    dependencies(group) {
        return this.inEdges[group.index].map(i => this.groups[i]);
    }
    dependents(group) {
        return this.adjacencies[group.index].map(i => this.groups[i]);
    }
    dfsRemoveRedundantEdges(from) {
        for (const startVertex of this.adjacencies[from.index]) {
            const parentAdjacencies = this.adjacencies[from.index];
            const stack = [...this.adjacencies[startVertex]];
            while (stack.length > 0) {
                const v = stack.pop();
                removeInPlace(v, parentAdjacencies);
                removeInPlace(from.index, this.inEdges[v]);
                stack.push(...this.adjacencies[v]);
            }
        }
    }
    outGroups(group) {
        return this.adjacencies[group.index].map(i => this.groups[i]);
    }
    inGroups(group) {
        return this.inEdges[group.index].map(i => this.groups[i]);
    }
    processGroup(processor, group, isRootGroup) {
        const outGroups = this.outGroups(group);
        const processed = processor.onFetchGroup(group, isRootGroup);
        if (outGroups.length == 0) {
            return [processed, []];
        }
        const allOutGroupsHaveThisAsIn = outGroups.every(g => this.inGroups(g).length === 1);
        if (allOutGroupsHaveThisAsIn) {
            const nodes = [processed];
            let nextNodes = outGroups;
            let remainingNext = [];
            while (nextNodes.length > 0) {
                const [node, toHandle, remaining] = this.processParallelGroups(processor, nextNodes, remainingNext);
                nodes.push(node);
                const [canHandle, newRemaining] = this.mergeRemainings(remainingNext, remaining);
                remainingNext = newRemaining;
                nextNodes = canHandle.concat(toHandle);
            }
            return [processor.reduceSequence(nodes), remainingNext];
        }
        else {
            return [processed, outGroups.map(g => [g, this.inEdges[g.index].filter(e => e !== group.index)])];
        }
    }
    processParallelGroups(processor, groups, remaining) {
        const parallelNodes = [];
        let remainingNext = remaining;
        const toHandleNext = [];
        for (const group of groups) {
            const [node, remaining] = this.processGroup(processor, group, false);
            parallelNodes.push(node);
            const [canHandle, newRemaining] = this.mergeRemainings(remainingNext, remaining);
            toHandleNext.push(...canHandle);
            remainingNext = newRemaining;
        }
        return [
            processor.reduceParallel(parallelNodes),
            toHandleNext,
            remainingNext
        ];
    }
    mergeRemainings(r1, r2) {
        const unhandled = [];
        const toHandle = [];
        for (const [g, edges] of r1) {
            const newEdges = this.mergeRemaingsAndRemoveIfFound(g, edges, r2);
            if (newEdges.length == 0) {
                toHandle.push(g);
            }
            else {
                unhandled.push([g, newEdges]);
            }
        }
        unhandled.push(...r2);
        return [toHandle, unhandled];
    }
    mergeRemaingsAndRemoveIfFound(group, inEdges, otherGroups) {
        const idx = otherGroups.findIndex(g => g[0].index === group.index);
        if (idx < 0) {
            return inEdges;
        }
        else {
            const otherEdges = otherGroups[idx][1];
            otherGroups.splice(idx, 1);
            return inEdges.filter(e => otherEdges.includes(e));
        }
    }
    process(processor) {
        this.reduce();
        const rootNodes = this.rootGroups.values().map(rootGroup => {
            const [node, remaining] = this.processGroup(processor, rootGroup, true);
            (0, federation_internals_1.assert)(remaining.length == 0, () => `Root group ${rootGroup} should have no remaining groups unhandled, but got ${remaining}`);
            return node;
        });
        return rootNodes;
    }
    dumpOnConsole(msg) {
        if (msg) {
            console.log(msg);
        }
        console.log('Groups:');
        for (const group of this.groups) {
            const pathInParent = this.pathsInParents[group.index];
            console.log(`  ${group}${pathInParent ? ` (path in parent: ${pathInParent.map(p => p.toString()).join('::')})` : ''}`);
        }
        console.log('Adjacencies:');
        for (const [i, adj] of this.adjacencies.entries()) {
            console.log(`  ${i} => [${adj.join(', ')}]`);
        }
        console.log('In-Edges:');
        for (const [i, ins] of this.inEdges.entries()) {
            console.log(`  ${i} => [${ins.join(', ')}]`);
        }
    }
    toString() {
        return this.rootGroups.values().map(g => this.toStringInternal(g, "")).join('\n');
    }
    toStringInternal(group, indent) {
        const groupDependents = this.adjacencies[group.index];
        return [indent + group.subgraphName + ' <- ' + groupDependents.map(i => this.groups[i].subgraphName).join(', ')]
            .concat(groupDependents
            .flatMap(g => this.adjacencies[g].length == 0
            ? []
            : this.toStringInternal(this.groups[g], indent + "  ")))
            .join('\n');
    }
}
function computeRootFetchGroups(dependencyGraph, pathTree, rootKind) {
    for (const [edge, _trigger, _conditions, child] of pathTree.childElements()) {
        (0, federation_internals_1.assert)(edge !== null, `The root edge should not be null`);
        const source = edge.tail.source;
        const rootType = edge.tail.type;
        const group = dependencyGraph.getOrCreateRootFetchGroup(source, rootKind, rootType);
        computeGroupsForTree(dependencyGraph, child, group);
    }
    return dependencyGraph;
}
function computeNonRootFetchGroups(dependencyGraph, pathTree, rootKind) {
    const source = pathTree.vertex.source;
    const rootType = pathTree.vertex.type;
    (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(rootType), () => `Should not have condition on non-selectable type ${rootType}`);
    const group = dependencyGraph.getOrCreateRootFetchGroup(source, rootKind, rootType);
    computeGroupsForTree(dependencyGraph, pathTree, group);
    return dependencyGraph;
}
function createNewFetchSelectionContext(type, selections, context) {
    const typeCast = new federation_internals_1.FragmentElement(type, type.name);
    let inputSelection = (0, federation_internals_1.selectionOfElement)(typeCast, selections);
    let path = [typeCast];
    if (context.isEmpty()) {
        return [inputSelection, path];
    }
    const schema = type.schema();
    const [name0, ifs0] = context.directives[0];
    typeCast.applyDirective(schema.directive(name0), { 'if': ifs0 });
    for (let i = 1; i < context.directives.length; i++) {
        const [name, ifs] = context.directives[i];
        const fragment = new federation_internals_1.FragmentElement(type, type.name);
        fragment.applyDirective(schema.directive(name), { 'if': ifs });
        inputSelection = (0, federation_internals_1.selectionOfElement)(fragment, (0, federation_internals_1.selectionSetOf)(type, inputSelection));
        path = [fragment].concat(path);
    }
    return [inputSelection, path];
}
function extractPathInParentForKeyFetch(type, path) {
    var _a;
    const lastElement = path[path.length - 1];
    return (lastElement && lastElement.kind === 'FragmentElement' && ((_a = lastElement.typeCondition) === null || _a === void 0 ? void 0 : _a.name) === type.name)
        ? path.slice(0, path.length - 1)
        : path;
}
function computeGroupsForTree(dependencyGraph, pathTree, startGroup, initialMergeAt = [], initialPath = [], initialContext = query_graphs_1.emptyContext) {
    const stack = [{ tree: pathTree, group: startGroup, mergeAt: initialMergeAt, path: initialPath, context: initialContext }];
    const createdGroups = [];
    while (stack.length > 0) {
        const { tree, group, mergeAt, path, context } = stack.pop();
        if (tree.isLeaf()) {
            group.addSelection(path);
        }
        else {
            for (const [edge, operation, conditions, child] of tree.childElements(true)) {
                if ((0, query_graphs_1.isPathContext)(operation)) {
                    const newContext = operation;
                    (0, federation_internals_1.assert)(edge !== null, () => `Unexpected 'null' edge with no trigger at ${path}`);
                    (0, federation_internals_1.assert)(edge.head.source !== edge.tail.source, () => `Key/Query edge ${edge} should change the underlying subgraph`);
                    if (edge.transition.kind === 'KeyResolution') {
                        (0, federation_internals_1.assert)(conditions, () => `Key edge ${edge} should have some conditions paths`);
                        const groupsForConditions = computeGroupsForTree(dependencyGraph, conditions, group, mergeAt, path);
                        const type = edge.tail.type;
                        const pathInParent = extractPathInParentForKeyFetch(type, path);
                        const newGroup = dependencyGraph.getOrCreateKeyFetchGroup(edge.tail.source, mergeAt, group, pathInParent, groupsForConditions);
                        createdGroups.push(newGroup);
                        newGroup.addDependencyOn(groupsForConditions);
                        const inputSelections = new federation_internals_1.SelectionSet(type);
                        inputSelections.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(type.typenameField())));
                        inputSelections.mergeIn(edge.conditions);
                        const [inputs, newPath] = createNewFetchSelectionContext(type, inputSelections, newContext);
                        newGroup.addInputs(inputs);
                        group.addSelection(path.concat(new federation_internals_1.Field(edge.head.type.typenameField())));
                        stack.push({ tree: child, group: newGroup, mergeAt, path: newPath, context: newContext });
                    }
                    else {
                        (0, federation_internals_1.assert)(edge.transition.kind === 'RootTypeResolution', () => `Unexpected non-collecting edge ${edge}`);
                        const rootKind = edge.transition.rootKind;
                        (0, federation_internals_1.assert)(!conditions, () => `Root type resolution edge ${edge} should not have conditions`);
                        (0, federation_internals_1.assert)((0, federation_internals_1.isObjectType)(edge.head.type) && (0, federation_internals_1.isObjectType)(edge.tail.type), () => `Expected an objects for the vertices of ${edge}`);
                        const type = edge.tail.type;
                        (0, federation_internals_1.assert)(type === type.schema().schemaDefinition.rootType(rootKind), () => `Expected ${type} to be the root ${rootKind} type, but that is ${type.schema().schemaDefinition.rootType(rootKind)}`);
                        group.addSelection(path.concat(new federation_internals_1.Field(edge.head.type.typenameField())));
                        const newGroup = dependencyGraph.newRootTypeFetchGroup(edge.tail.source, rootKind, type, mergeAt, group, path);
                        const newPath = createNewFetchSelectionContext(type, undefined, newContext)[1];
                        stack.push({ tree: child, group: newGroup, mergeAt, path: newPath, context: newContext });
                    }
                }
                else if (edge === null) {
                    const newPath = operation.appliedDirectives.length === 0 ? path : path.concat(operation);
                    stack.push({ tree: child, group, mergeAt, path: newPath, context });
                }
                else {
                    (0, federation_internals_1.assert)(edge.head.source === edge.tail.source, () => `Collecting edge ${edge} for ${operation} should not change the underlying subgraph`);
                    const updated = { tree: child, group, mergeAt, path, context };
                    if (conditions) {
                        const requireResult = handleRequires(dependencyGraph, edge, conditions, group, mergeAt, path, context);
                        updated.group = requireResult.group;
                        updated.mergeAt = requireResult.mergeAt;
                        updated.path = requireResult.path;
                        createdGroups.push(...requireResult.createdGroups);
                    }
                    if (operation.kind === 'Field') {
                        updated.mergeAt = addToResponsePath(updated.mergeAt, operation.responseName(), edge.transition.definition.type);
                    }
                    updated.path = updated.path.concat(operation);
                    stack.push(updated);
                }
            }
        }
    }
    return createdGroups;
}
function addTypenameFieldForAbstractTypes(selectionSet) {
    for (const selection of selectionSet.selections()) {
        if (selection.kind == 'FieldSelection') {
            const fieldBaseType = (0, federation_internals_1.baseType)(selection.field.definition.type);
            if ((0, federation_internals_1.isAbstractType)(fieldBaseType)) {
                selection.selectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(fieldBaseType.typenameField())));
            }
            if (selection.selectionSet) {
                addTypenameFieldForAbstractTypes(selection.selectionSet);
            }
        }
        else {
            addTypenameFieldForAbstractTypes(selection.selectionSet);
        }
    }
}
function withoutTypename(selectionSet) {
    return selectionSet.filter((selection) => selection.kind !== 'FieldSelection' || selection.element().name === '__typename');
}
function pathHasOnlyFragments(path) {
    return path.every((element) => element.kind === 'FragmentElement');
}
function handleRequires(dependencyGraph, edge, requiresConditions, group, mergeAt, path, context) {
    const entityType = edge.head.type;
    if (!group.isTopLevel && pathHasOnlyFragments(path)) {
        const originalInputs = group.clonedInputs();
        const newGroup = dependencyGraph.newKeyFetchGroup(group.subgraphName, group.mergeAt);
        newGroup.addInputs(originalInputs.forRead());
        const createdGroups = computeGroupsForTree(dependencyGraph, requiresConditions, newGroup, mergeAt, path);
        if (createdGroups.length == 0) {
            group.mergeIn(newGroup, path);
            return { group, mergeAt, path, createdGroups: [] };
        }
        const newGroupIsUnneeded = newGroup.inputs.contains(withoutTypename(newGroup.selection));
        const parents = dependencyGraph.dependencies(group);
        const pathInParent = dependencyGraph.pathInParent(group);
        const unmergedGroups = [];
        const shouldMergeNewGroupToParent = newGroupIsUnneeded && !newGroup.inputs.contains(newGroup.selection);
        if (newGroupIsUnneeded && (pathInParent || !shouldMergeNewGroupToParent)) {
            for (const created of createdGroups) {
                const createdPathInParent = dependencyGraph.pathInParent(created);
                if (pathInParent
                    && createdPathInParent
                    && created.subgraphName === parents[0].subgraphName) {
                    parents[0].mergeIn(created, (0, federation_internals_1.concatOperationPaths)(pathInParent, createdPathInParent));
                }
                else {
                    created.removeDependencyOn(newGroup);
                    const pathInParents = pathInParent && createdPathInParent
                        ? (0, federation_internals_1.concatOperationPaths)(pathInParent, createdPathInParent)
                        : undefined;
                    created.addDependencyOn(parents, pathInParents);
                    unmergedGroups.push(created);
                }
            }
            if (shouldMergeNewGroupToParent) {
                parents[0].mergeIn(newGroup, pathInParent);
            }
            else {
                dependencyGraph.remove(newGroup);
            }
        }
        else {
            group.mergeIn(newGroup, path);
            for (const created of createdGroups) {
                if (pathInParent
                    && created.subgraphName === parents[0].subgraphName
                    && sameMergeAt(created.mergeAt, group.mergeAt)
                    && originalInputs.forRead().contains(created.inputs)) {
                    parents[0].mergeIn(created, pathInParent);
                }
                else {
                    unmergedGroups.push(created);
                }
            }
        }
        if (unmergedGroups.length == 0) {
            group.addInputs(inputsForRequire(dependencyGraph.federatedQueryGraph, entityType, edge, context, false)[0]);
            return { group, mergeAt, path, createdGroups: [] };
        }
        const postRequireGroup = dependencyGraph.newKeyFetchGroup(group.subgraphName, group.mergeAt);
        postRequireGroup.addDependencyOn(unmergedGroups);
        const [inputs, newPath] = inputsForRequire(dependencyGraph.federatedQueryGraph, entityType, edge, context);
        postRequireGroup.addInputs(inputs);
        return {
            group: postRequireGroup,
            mergeAt,
            path: newPath,
            createdGroups: unmergedGroups.concat(postRequireGroup),
        };
    }
    else {
        const createdGroups = computeGroupsForTree(dependencyGraph, requiresConditions, group, mergeAt, path);
        if (createdGroups.length == 0) {
            return { group, mergeAt, path, createdGroups: [] };
        }
        const newGroup = dependencyGraph.newKeyFetchGroup(group.subgraphName, mergeAt);
        newGroup.addDependencyOn(createdGroups);
        const [inputs, newPath] = inputsForRequire(dependencyGraph.federatedQueryGraph, entityType, edge, context);
        newGroup.addInputs(inputs);
        return { group: newGroup, mergeAt, path: newPath, createdGroups };
    }
}
function inputsForRequire(graph, entityType, edge, context, includeKeyInputs = true) {
    const fullSelectionSet = new federation_internals_1.SelectionSet(entityType);
    fullSelectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(entityType.typenameField())));
    fullSelectionSet.mergeIn(edge.conditions);
    if (includeKeyInputs) {
        const keyCondition = (0, query_graphs_1.getLocallySatisfiableKey)(graph, edge.head);
        (0, federation_internals_1.assert)(keyCondition, () => `Due to @require, validation should have required a key to be present for ${edge}`);
        fullSelectionSet.mergeIn(keyCondition);
    }
    return createNewFetchSelectionContext(entityType, fullSelectionSet, context);
}
const representationsVariable = new federation_internals_1.Variable('representations');
function representationsVariableDefinition(schema) {
    const metadata = (0, federation_internals_1.federationMetadata)(schema);
    (0, federation_internals_1.assert)(metadata, 'Expected schema to be a federation subgraph');
    const representationsType = new federation_internals_1.NonNullType(new federation_internals_1.ListType(new federation_internals_1.NonNullType(metadata.anyType())));
    return new federation_internals_1.VariableDefinition(schema, representationsVariable, representationsType);
}
function operationForEntitiesFetch(subgraphSchema, selectionSet, allVariableDefinitions, fragments, operationName) {
    const variableDefinitions = new federation_internals_1.VariableDefinitions();
    variableDefinitions.add(representationsVariableDefinition(subgraphSchema));
    variableDefinitions.addAll(allVariableDefinitions.filter(selectionSet.usedVariables()));
    const queryType = subgraphSchema.schemaDefinition.rootType('query');
    (0, federation_internals_1.assert)(queryType, `Subgraphs should always have a query root (they should at least provides _entities)`);
    const entities = queryType.field(federation_internals_1.entitiesFieldName);
    (0, federation_internals_1.assert)(entities, `Subgraphs should always have the _entities field`);
    const entitiesCall = new federation_internals_1.SelectionSet(queryType);
    entitiesCall.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(entities, { representations: representationsVariable }, variableDefinitions), selectionSet));
    return new federation_internals_1.Operation('query', entitiesCall, variableDefinitions, operationName).optimize(fragments);
}
function flatWrap(kind, nodes) {
    (0, federation_internals_1.assert)(nodes.length !== 0, 'programming error: should always be called with nodes');
    if (nodes.length === 1) {
        return nodes[0];
    }
    return {
        kind,
        nodes: nodes.flatMap(n => (n.kind === kind ? n.nodes : [n])),
    };
}
function operationForQueryFetch(rootKind, selectionSet, allVariableDefinitions, fragments, operationName) {
    return new federation_internals_1.Operation(rootKind, selectionSet, allVariableDefinitions.filter(selectionSet.usedVariables()), operationName).optimize(fragments);
}
//# sourceMappingURL=buildPlan.js.map